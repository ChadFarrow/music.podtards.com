"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x4) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x4, {
    get: (a3, b3) => (typeof require !== "undefined" ? require : a3)[b3]
  }) : x4)(function(x4) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x4 + '" is not supported');
  });
  var __commonJS = (cb, mod2) => function __require2() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to2, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // node_modules/crypto-js/core.js
  var require_core = __commonJS({
    "node_modules/crypto-js/core.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory();
        } else if (typeof define === "function" && define.amd) {
          define([], factory);
        } else {
          root.CryptoJS = factory();
        }
      })(exports, function() {
        var CryptoJS = CryptoJS || function(Math2, undefined2) {
          var crypto3;
          if (typeof window !== "undefined" && window.crypto) {
            crypto3 = window.crypto;
          }
          if (typeof self !== "undefined" && self.crypto) {
            crypto3 = self.crypto;
          }
          if (typeof globalThis !== "undefined" && globalThis.crypto) {
            crypto3 = globalThis.crypto;
          }
          if (!crypto3 && typeof window !== "undefined" && window.msCrypto) {
            crypto3 = window.msCrypto;
          }
          if (!crypto3 && typeof global !== "undefined" && global.crypto) {
            crypto3 = global.crypto;
          }
          if (!crypto3 && typeof __require === "function") {
            try {
              crypto3 = require_crypto();
            } catch (err) {
            }
          }
          var cryptoSecureRandomInt = function() {
            if (crypto3) {
              if (typeof crypto3.getRandomValues === "function") {
                try {
                  return crypto3.getRandomValues(new Uint32Array(1))[0];
                } catch (err) {
                }
              }
              if (typeof crypto3.randomBytes === "function") {
                try {
                  return crypto3.randomBytes(4).readInt32LE();
                } catch (err) {
                }
              }
            }
            throw new Error("Native crypto module could not be used to get secure random number.");
          };
          var create = Object.create || function() {
            function F2() {
            }
            return function(obj) {
              var subtype;
              F2.prototype = obj;
              subtype = new F2();
              F2.prototype = null;
              return subtype;
            };
          }();
          var C3 = {};
          var C_lib = C3.lib = {};
          var Base = C_lib.Base = function() {
            return {
              /**
               * Creates a new object that inherits from this object.
               *
               * @param {Object} overrides Properties to copy into the new object.
               *
               * @return {Object} The new object.
               *
               * @static
               *
               * @example
               *
               *     var MyType = CryptoJS.lib.Base.extend({
               *         field: 'value',
               *
               *         method: function () {
               *         }
               *     });
               */
              extend: function(overrides) {
                var subtype = create(this);
                if (overrides) {
                  subtype.mixIn(overrides);
                }
                if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                  subtype.init = function() {
                    subtype.$super.init.apply(this, arguments);
                  };
                }
                subtype.init.prototype = subtype;
                subtype.$super = this;
                return subtype;
              },
              /**
               * Extends this object and runs the init method.
               * Arguments to create() will be passed to init().
               *
               * @return {Object} The new object.
               *
               * @static
               *
               * @example
               *
               *     var instance = MyType.create();
               */
              create: function() {
                var instance = this.extend();
                instance.init.apply(instance, arguments);
                return instance;
              },
              /**
               * Initializes a newly created object.
               * Override this method to add some logic when your objects are created.
               *
               * @example
               *
               *     var MyType = CryptoJS.lib.Base.extend({
               *         init: function () {
               *             // ...
               *         }
               *     });
               */
              init: function() {
              },
              /**
               * Copies properties into this object.
               *
               * @param {Object} properties The properties to mix in.
               *
               * @example
               *
               *     MyType.mixIn({
               *         field: 'value'
               *     });
               */
              mixIn: function(properties) {
                for (var propertyName in properties) {
                  if (properties.hasOwnProperty(propertyName)) {
                    this[propertyName] = properties[propertyName];
                  }
                }
                if (properties.hasOwnProperty("toString")) {
                  this.toString = properties.toString;
                }
              },
              /**
               * Creates a copy of this object.
               *
               * @return {Object} The clone.
               *
               * @example
               *
               *     var clone = instance.clone();
               */
              clone: function() {
                return this.init.prototype.extend(this);
              }
            };
          }();
          var WordArray = C_lib.WordArray = Base.extend({
            /**
             * Initializes a newly created word array.
             *
             * @param {Array} words (Optional) An array of 32-bit words.
             * @param {number} sigBytes (Optional) The number of significant bytes in the words.
             *
             * @example
             *
             *     var wordArray = CryptoJS.lib.WordArray.create();
             *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
             *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
             */
            init: function(words, sigBytes) {
              words = this.words = words || [];
              if (sigBytes != undefined2) {
                this.sigBytes = sigBytes;
              } else {
                this.sigBytes = words.length * 4;
              }
            },
            /**
             * Converts this word array to a string.
             *
             * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
             *
             * @return {string} The stringified word array.
             *
             * @example
             *
             *     var string = wordArray + '';
             *     var string = wordArray.toString();
             *     var string = wordArray.toString(CryptoJS.enc.Utf8);
             */
            toString: function(encoder) {
              return (encoder || Hex).stringify(this);
            },
            /**
             * Concatenates a word array to this word array.
             *
             * @param {WordArray} wordArray The word array to append.
             *
             * @return {WordArray} This word array.
             *
             * @example
             *
             *     wordArray1.concat(wordArray2);
             */
            concat: function(wordArray) {
              var thisWords = this.words;
              var thatWords = wordArray.words;
              var thisSigBytes = this.sigBytes;
              var thatSigBytes = wordArray.sigBytes;
              this.clamp();
              if (thisSigBytes % 4) {
                for (var i4 = 0; i4 < thatSigBytes; i4++) {
                  var thatByte = thatWords[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
                  thisWords[thisSigBytes + i4 >>> 2] |= thatByte << 24 - (thisSigBytes + i4) % 4 * 8;
                }
              } else {
                for (var j2 = 0; j2 < thatSigBytes; j2 += 4) {
                  thisWords[thisSigBytes + j2 >>> 2] = thatWords[j2 >>> 2];
                }
              }
              this.sigBytes += thatSigBytes;
              return this;
            },
            /**
             * Removes insignificant bits.
             *
             * @example
             *
             *     wordArray.clamp();
             */
            clamp: function() {
              var words = this.words;
              var sigBytes = this.sigBytes;
              words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
              words.length = Math2.ceil(sigBytes / 4);
            },
            /**
             * Creates a copy of this word array.
             *
             * @return {WordArray} The clone.
             *
             * @example
             *
             *     var clone = wordArray.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              clone.words = this.words.slice(0);
              return clone;
            },
            /**
             * Creates a word array filled with random bytes.
             *
             * @param {number} nBytes The number of random bytes to generate.
             *
             * @return {WordArray} The random word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.lib.WordArray.random(16);
             */
            random: function(nBytes) {
              var words = [];
              for (var i4 = 0; i4 < nBytes; i4 += 4) {
                words.push(cryptoSecureRandomInt());
              }
              return new WordArray.init(words, nBytes);
            }
          });
          var C_enc = C3.enc = {};
          var Hex = C_enc.Hex = {
            /**
             * Converts a word array to a hex string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The hex string.
             *
             * @static
             *
             * @example
             *
             *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var hexChars = [];
              for (var i4 = 0; i4 < sigBytes; i4++) {
                var bite = words[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 15).toString(16));
              }
              return hexChars.join("");
            },
            /**
             * Converts a hex string to a word array.
             *
             * @param {string} hexStr The hex string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
             */
            parse: function(hexStr) {
              var hexStrLength = hexStr.length;
              var words = [];
              for (var i4 = 0; i4 < hexStrLength; i4 += 2) {
                words[i4 >>> 3] |= parseInt(hexStr.substr(i4, 2), 16) << 24 - i4 % 8 * 4;
              }
              return new WordArray.init(words, hexStrLength / 2);
            }
          };
          var Latin1 = C_enc.Latin1 = {
            /**
             * Converts a word array to a Latin1 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The Latin1 string.
             *
             * @static
             *
             * @example
             *
             *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var latin1Chars = [];
              for (var i4 = 0; i4 < sigBytes; i4++) {
                var bite = words[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
                latin1Chars.push(String.fromCharCode(bite));
              }
              return latin1Chars.join("");
            },
            /**
             * Converts a Latin1 string to a word array.
             *
             * @param {string} latin1Str The Latin1 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
             */
            parse: function(latin1Str) {
              var latin1StrLength = latin1Str.length;
              var words = [];
              for (var i4 = 0; i4 < latin1StrLength; i4++) {
                words[i4 >>> 2] |= (latin1Str.charCodeAt(i4) & 255) << 24 - i4 % 4 * 8;
              }
              return new WordArray.init(words, latin1StrLength);
            }
          };
          var Utf8 = C_enc.Utf8 = {
            /**
             * Converts a word array to a UTF-8 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-8 string.
             *
             * @static
             *
             * @example
             *
             *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
             */
            stringify: function(wordArray) {
              try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
              } catch (e8) {
                throw new Error("Malformed UTF-8 data");
              }
            },
            /**
             * Converts a UTF-8 string to a word array.
             *
             * @param {string} utf8Str The UTF-8 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
             */
            parse: function(utf8Str) {
              return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
            }
          };
          var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
            /**
             * Resets this block algorithm's data buffer to its initial state.
             *
             * @example
             *
             *     bufferedBlockAlgorithm.reset();
             */
            reset: function() {
              this._data = new WordArray.init();
              this._nDataBytes = 0;
            },
            /**
             * Adds new data to this block algorithm's buffer.
             *
             * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
             *
             * @example
             *
             *     bufferedBlockAlgorithm._append('data');
             *     bufferedBlockAlgorithm._append(wordArray);
             */
            _append: function(data) {
              if (typeof data == "string") {
                data = Utf8.parse(data);
              }
              this._data.concat(data);
              this._nDataBytes += data.sigBytes;
            },
            /**
             * Processes available data blocks.
             *
             * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
             *
             * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
             *
             * @return {WordArray} The processed data.
             *
             * @example
             *
             *     var processedData = bufferedBlockAlgorithm._process();
             *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
             */
            _process: function(doFlush) {
              var processedWords;
              var data = this._data;
              var dataWords = data.words;
              var dataSigBytes = data.sigBytes;
              var blockSize = this.blockSize;
              var blockSizeBytes = blockSize * 4;
              var nBlocksReady = dataSigBytes / blockSizeBytes;
              if (doFlush) {
                nBlocksReady = Math2.ceil(nBlocksReady);
              } else {
                nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
              }
              var nWordsReady = nBlocksReady * blockSize;
              var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
              if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                  this._doProcessBlock(dataWords, offset);
                }
                processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
              }
              return new WordArray.init(processedWords, nBytesReady);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = bufferedBlockAlgorithm.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              clone._data = this._data.clone();
              return clone;
            },
            _minBufferSize: 0
          });
          var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
            /**
             * Configuration options.
             */
            cfg: Base.extend(),
            /**
             * Initializes a newly created hasher.
             *
             * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
             *
             * @example
             *
             *     var hasher = CryptoJS.algo.SHA256.create();
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
              this.reset();
            },
            /**
             * Resets this hasher to its initial state.
             *
             * @example
             *
             *     hasher.reset();
             */
            reset: function() {
              BufferedBlockAlgorithm.reset.call(this);
              this._doReset();
            },
            /**
             * Updates this hasher with a message.
             *
             * @param {WordArray|string} messageUpdate The message to append.
             *
             * @return {Hasher} This hasher.
             *
             * @example
             *
             *     hasher.update('message');
             *     hasher.update(wordArray);
             */
            update: function(messageUpdate) {
              this._append(messageUpdate);
              this._process();
              return this;
            },
            /**
             * Finalizes the hash computation.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} messageUpdate (Optional) A final message update.
             *
             * @return {WordArray} The hash.
             *
             * @example
             *
             *     var hash = hasher.finalize();
             *     var hash = hasher.finalize('message');
             *     var hash = hasher.finalize(wordArray);
             */
            finalize: function(messageUpdate) {
              if (messageUpdate) {
                this._append(messageUpdate);
              }
              var hash2 = this._doFinalize();
              return hash2;
            },
            blockSize: 512 / 32,
            /**
             * Creates a shortcut function to a hasher's object interface.
             *
             * @param {Hasher} hasher The hasher to create a helper for.
             *
             * @return {Function} The shortcut function.
             *
             * @static
             *
             * @example
             *
             *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
             */
            _createHelper: function(hasher) {
              return function(message, cfg) {
                return new hasher.init(cfg).finalize(message);
              };
            },
            /**
             * Creates a shortcut function to the HMAC's object interface.
             *
             * @param {Hasher} hasher The hasher to use in this HMAC helper.
             *
             * @return {Function} The shortcut function.
             *
             * @static
             *
             * @example
             *
             *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
             */
            _createHmacHelper: function(hasher) {
              return function(message, key) {
                return new C_algo.HMAC.init(hasher, key).finalize(message);
              };
            }
          });
          var C_algo = C3.algo = {};
          return C3;
        }(Math);
        return CryptoJS;
      });
    }
  });

  // node_modules/crypto-js/x64-core.js
  var require_x64_core = __commonJS({
    "node_modules/crypto-js/x64-core.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function(undefined2) {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var Base = C_lib.Base;
          var X32WordArray = C_lib.WordArray;
          var C_x64 = C3.x64 = {};
          var X64Word = C_x64.Word = Base.extend({
            /**
             * Initializes a newly created 64-bit word.
             *
             * @param {number} high The high 32 bits.
             * @param {number} low The low 32 bits.
             *
             * @example
             *
             *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
             */
            init: function(high, low) {
              this.high = high;
              this.low = low;
            }
            /**
             * Bitwise NOTs this word.
             *
             * @return {X64Word} A new x64-Word object after negating.
             *
             * @example
             *
             *     var negated = x64Word.not();
             */
            // not: function () {
            // var high = ~this.high;
            // var low = ~this.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise ANDs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to AND with this word.
             *
             * @return {X64Word} A new x64-Word object after ANDing.
             *
             * @example
             *
             *     var anded = x64Word.and(anotherX64Word);
             */
            // and: function (word) {
            // var high = this.high & word.high;
            // var low = this.low & word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise ORs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to OR with this word.
             *
             * @return {X64Word} A new x64-Word object after ORing.
             *
             * @example
             *
             *     var ored = x64Word.or(anotherX64Word);
             */
            // or: function (word) {
            // var high = this.high | word.high;
            // var low = this.low | word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Bitwise XORs this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to XOR with this word.
             *
             * @return {X64Word} A new x64-Word object after XORing.
             *
             * @example
             *
             *     var xored = x64Word.xor(anotherX64Word);
             */
            // xor: function (word) {
            // var high = this.high ^ word.high;
            // var low = this.low ^ word.low;
            // return X64Word.create(high, low);
            // },
            /**
             * Shifts this word n bits to the left.
             *
             * @param {number} n The number of bits to shift.
             *
             * @return {X64Word} A new x64-Word object after shifting.
             *
             * @example
             *
             *     var shifted = x64Word.shiftL(25);
             */
            // shiftL: function (n) {
            // if (n < 32) {
            // var high = (this.high << n) | (this.low >>> (32 - n));
            // var low = this.low << n;
            // } else {
            // var high = this.low << (n - 32);
            // var low = 0;
            // }
            // return X64Word.create(high, low);
            // },
            /**
             * Shifts this word n bits to the right.
             *
             * @param {number} n The number of bits to shift.
             *
             * @return {X64Word} A new x64-Word object after shifting.
             *
             * @example
             *
             *     var shifted = x64Word.shiftR(7);
             */
            // shiftR: function (n) {
            // if (n < 32) {
            // var low = (this.low >>> n) | (this.high << (32 - n));
            // var high = this.high >>> n;
            // } else {
            // var low = this.high >>> (n - 32);
            // var high = 0;
            // }
            // return X64Word.create(high, low);
            // },
            /**
             * Rotates this word n bits to the left.
             *
             * @param {number} n The number of bits to rotate.
             *
             * @return {X64Word} A new x64-Word object after rotating.
             *
             * @example
             *
             *     var rotated = x64Word.rotL(25);
             */
            // rotL: function (n) {
            // return this.shiftL(n).or(this.shiftR(64 - n));
            // },
            /**
             * Rotates this word n bits to the right.
             *
             * @param {number} n The number of bits to rotate.
             *
             * @return {X64Word} A new x64-Word object after rotating.
             *
             * @example
             *
             *     var rotated = x64Word.rotR(7);
             */
            // rotR: function (n) {
            // return this.shiftR(n).or(this.shiftL(64 - n));
            // },
            /**
             * Adds this word with the passed word.
             *
             * @param {X64Word} word The x64-Word to add with this word.
             *
             * @return {X64Word} A new x64-Word object after adding.
             *
             * @example
             *
             *     var added = x64Word.add(anotherX64Word);
             */
            // add: function (word) {
            // var low = (this.low + word.low) | 0;
            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
            // var high = (this.high + word.high + carry) | 0;
            // return X64Word.create(high, low);
            // }
          });
          var X64WordArray = C_x64.WordArray = Base.extend({
            /**
             * Initializes a newly created word array.
             *
             * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
             * @param {number} sigBytes (Optional) The number of significant bytes in the words.
             *
             * @example
             *
             *     var wordArray = CryptoJS.x64.WordArray.create();
             *
             *     var wordArray = CryptoJS.x64.WordArray.create([
             *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
             *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
             *     ]);
             *
             *     var wordArray = CryptoJS.x64.WordArray.create([
             *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
             *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
             *     ], 10);
             */
            init: function(words, sigBytes) {
              words = this.words = words || [];
              if (sigBytes != undefined2) {
                this.sigBytes = sigBytes;
              } else {
                this.sigBytes = words.length * 8;
              }
            },
            /**
             * Converts this 64-bit word array to a 32-bit word array.
             *
             * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
             *
             * @example
             *
             *     var x32WordArray = x64WordArray.toX32();
             */
            toX32: function() {
              var x64Words = this.words;
              var x64WordsLength = x64Words.length;
              var x32Words = [];
              for (var i4 = 0; i4 < x64WordsLength; i4++) {
                var x64Word = x64Words[i4];
                x32Words.push(x64Word.high);
                x32Words.push(x64Word.low);
              }
              return X32WordArray.create(x32Words, this.sigBytes);
            },
            /**
             * Creates a copy of this word array.
             *
             * @return {X64WordArray} The clone.
             *
             * @example
             *
             *     var clone = x64WordArray.clone();
             */
            clone: function() {
              var clone = Base.clone.call(this);
              var words = clone.words = this.words.slice(0);
              var wordsLength = words.length;
              for (var i4 = 0; i4 < wordsLength; i4++) {
                words[i4] = words[i4].clone();
              }
              return clone;
            }
          });
        })();
        return CryptoJS;
      });
    }
  });

  // node_modules/crypto-js/lib-typedarrays.js
  var require_lib_typedarrays = __commonJS({
    "node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          if (typeof ArrayBuffer != "function") {
            return;
          }
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var WordArray = C_lib.WordArray;
          var superInit = WordArray.init;
          var subInit = WordArray.init = function(typedArray) {
            if (typedArray instanceof ArrayBuffer) {
              typedArray = new Uint8Array(typedArray);
            }
            if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
              typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
            }
            if (typedArray instanceof Uint8Array) {
              var typedArrayByteLength = typedArray.byteLength;
              var words = [];
              for (var i4 = 0; i4 < typedArrayByteLength; i4++) {
                words[i4 >>> 2] |= typedArray[i4] << 24 - i4 % 4 * 8;
              }
              superInit.call(this, words, typedArrayByteLength);
            } else {
              superInit.apply(this, arguments);
            }
          };
          subInit.prototype = WordArray;
        })();
        return CryptoJS.lib.WordArray;
      });
    }
  });

  // node_modules/crypto-js/enc-utf16.js
  var require_enc_utf16 = __commonJS({
    "node_modules/crypto-js/enc-utf16.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C3.enc;
          var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
            /**
             * Converts a word array to a UTF-16 BE string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-16 BE string.
             *
             * @static
             *
             * @example
             *
             *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var utf16Chars = [];
              for (var i4 = 0; i4 < sigBytes; i4 += 2) {
                var codePoint = words[i4 >>> 2] >>> 16 - i4 % 4 * 8 & 65535;
                utf16Chars.push(String.fromCharCode(codePoint));
              }
              return utf16Chars.join("");
            },
            /**
             * Converts a UTF-16 BE string to a word array.
             *
             * @param {string} utf16Str The UTF-16 BE string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
             */
            parse: function(utf16Str) {
              var utf16StrLength = utf16Str.length;
              var words = [];
              for (var i4 = 0; i4 < utf16StrLength; i4++) {
                words[i4 >>> 1] |= utf16Str.charCodeAt(i4) << 16 - i4 % 2 * 16;
              }
              return WordArray.create(words, utf16StrLength * 2);
            }
          };
          C_enc.Utf16LE = {
            /**
             * Converts a word array to a UTF-16 LE string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The UTF-16 LE string.
             *
             * @static
             *
             * @example
             *
             *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var utf16Chars = [];
              for (var i4 = 0; i4 < sigBytes; i4 += 2) {
                var codePoint = swapEndian(words[i4 >>> 2] >>> 16 - i4 % 4 * 8 & 65535);
                utf16Chars.push(String.fromCharCode(codePoint));
              }
              return utf16Chars.join("");
            },
            /**
             * Converts a UTF-16 LE string to a word array.
             *
             * @param {string} utf16Str The UTF-16 LE string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
             */
            parse: function(utf16Str) {
              var utf16StrLength = utf16Str.length;
              var words = [];
              for (var i4 = 0; i4 < utf16StrLength; i4++) {
                words[i4 >>> 1] |= swapEndian(utf16Str.charCodeAt(i4) << 16 - i4 % 2 * 16);
              }
              return WordArray.create(words, utf16StrLength * 2);
            }
          };
          function swapEndian(word) {
            return word << 8 & 4278255360 | word >>> 8 & 16711935;
          }
        })();
        return CryptoJS.enc.Utf16;
      });
    }
  });

  // node_modules/crypto-js/enc-base64.js
  var require_enc_base64 = __commonJS({
    "node_modules/crypto-js/enc-base64.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C3.enc;
          var Base64 = C_enc.Base64 = {
            /**
             * Converts a word array to a Base64 string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @return {string} The Base64 string.
             *
             * @static
             *
             * @example
             *
             *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
             */
            stringify: function(wordArray) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var map = this._map;
              wordArray.clamp();
              var base64Chars = [];
              for (var i4 = 0; i4 < sigBytes; i4 += 3) {
                var byte1 = words[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
                var byte2 = words[i4 + 1 >>> 2] >>> 24 - (i4 + 1) % 4 * 8 & 255;
                var byte3 = words[i4 + 2 >>> 2] >>> 24 - (i4 + 2) % 4 * 8 & 255;
                var triplet = byte1 << 16 | byte2 << 8 | byte3;
                for (var j2 = 0; j2 < 4 && i4 + j2 * 0.75 < sigBytes; j2++) {
                  base64Chars.push(map.charAt(triplet >>> 6 * (3 - j2) & 63));
                }
              }
              var paddingChar = map.charAt(64);
              if (paddingChar) {
                while (base64Chars.length % 4) {
                  base64Chars.push(paddingChar);
                }
              }
              return base64Chars.join("");
            },
            /**
             * Converts a Base64 string to a word array.
             *
             * @param {string} base64Str The Base64 string.
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
             */
            parse: function(base64Str) {
              var base64StrLength = base64Str.length;
              var map = this._map;
              var reverseMap = this._reverseMap;
              if (!reverseMap) {
                reverseMap = this._reverseMap = [];
                for (var j2 = 0; j2 < map.length; j2++) {
                  reverseMap[map.charCodeAt(j2)] = j2;
                }
              }
              var paddingChar = map.charAt(64);
              if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex !== -1) {
                  base64StrLength = paddingIndex;
                }
              }
              return parseLoop(base64Str, base64StrLength, reverseMap);
            },
            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
          };
          function parseLoop(base64Str, base64StrLength, reverseMap) {
            var words = [];
            var nBytes = 0;
            for (var i4 = 0; i4 < base64StrLength; i4++) {
              if (i4 % 4) {
                var bits1 = reverseMap[base64Str.charCodeAt(i4 - 1)] << i4 % 4 * 2;
                var bits2 = reverseMap[base64Str.charCodeAt(i4)] >>> 6 - i4 % 4 * 2;
                var bitsCombined = bits1 | bits2;
                words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                nBytes++;
              }
            }
            return WordArray.create(words, nBytes);
          }
        })();
        return CryptoJS.enc.Base64;
      });
    }
  });

  // node_modules/crypto-js/enc-base64url.js
  var require_enc_base64url = __commonJS({
    "node_modules/crypto-js/enc-base64url.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var WordArray = C_lib.WordArray;
          var C_enc = C3.enc;
          var Base64url = C_enc.Base64url = {
            /**
             * Converts a word array to a Base64url string.
             *
             * @param {WordArray} wordArray The word array.
             *
             * @param {boolean} urlSafe Whether to use url safe
             *
             * @return {string} The Base64url string.
             *
             * @static
             *
             * @example
             *
             *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
             */
            stringify: function(wordArray, urlSafe = true) {
              var words = wordArray.words;
              var sigBytes = wordArray.sigBytes;
              var map = urlSafe ? this._safe_map : this._map;
              wordArray.clamp();
              var base64Chars = [];
              for (var i4 = 0; i4 < sigBytes; i4 += 3) {
                var byte1 = words[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255;
                var byte2 = words[i4 + 1 >>> 2] >>> 24 - (i4 + 1) % 4 * 8 & 255;
                var byte3 = words[i4 + 2 >>> 2] >>> 24 - (i4 + 2) % 4 * 8 & 255;
                var triplet = byte1 << 16 | byte2 << 8 | byte3;
                for (var j2 = 0; j2 < 4 && i4 + j2 * 0.75 < sigBytes; j2++) {
                  base64Chars.push(map.charAt(triplet >>> 6 * (3 - j2) & 63));
                }
              }
              var paddingChar = map.charAt(64);
              if (paddingChar) {
                while (base64Chars.length % 4) {
                  base64Chars.push(paddingChar);
                }
              }
              return base64Chars.join("");
            },
            /**
             * Converts a Base64url string to a word array.
             *
             * @param {string} base64Str The Base64url string.
             *
             * @param {boolean} urlSafe Whether to use url safe
             *
             * @return {WordArray} The word array.
             *
             * @static
             *
             * @example
             *
             *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
             */
            parse: function(base64Str, urlSafe = true) {
              var base64StrLength = base64Str.length;
              var map = urlSafe ? this._safe_map : this._map;
              var reverseMap = this._reverseMap;
              if (!reverseMap) {
                reverseMap = this._reverseMap = [];
                for (var j2 = 0; j2 < map.length; j2++) {
                  reverseMap[map.charCodeAt(j2)] = j2;
                }
              }
              var paddingChar = map.charAt(64);
              if (paddingChar) {
                var paddingIndex = base64Str.indexOf(paddingChar);
                if (paddingIndex !== -1) {
                  base64StrLength = paddingIndex;
                }
              }
              return parseLoop(base64Str, base64StrLength, reverseMap);
            },
            _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
            _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
          };
          function parseLoop(base64Str, base64StrLength, reverseMap) {
            var words = [];
            var nBytes = 0;
            for (var i4 = 0; i4 < base64StrLength; i4++) {
              if (i4 % 4) {
                var bits1 = reverseMap[base64Str.charCodeAt(i4 - 1)] << i4 % 4 * 2;
                var bits2 = reverseMap[base64Str.charCodeAt(i4)] >>> 6 - i4 % 4 * 2;
                var bitsCombined = bits1 | bits2;
                words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
                nBytes++;
              }
            }
            return WordArray.create(words, nBytes);
          }
        })();
        return CryptoJS.enc.Base64url;
      });
    }
  });

  // node_modules/crypto-js/md5.js
  var require_md5 = __commonJS({
    "node_modules/crypto-js/md5.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function(Math2) {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C3.algo;
          var T4 = [];
          (function() {
            for (var i4 = 0; i4 < 64; i4++) {
              T4[i4] = Math2.abs(Math2.sin(i4 + 1)) * 4294967296 | 0;
            }
          })();
          var MD5 = C_algo.MD5 = Hasher.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                1732584193,
                4023233417,
                2562383102,
                271733878
              ]);
            },
            _doProcessBlock: function(M3, offset) {
              for (var i4 = 0; i4 < 16; i4++) {
                var offset_i = offset + i4;
                var M_offset_i = M3[offset_i];
                M3[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
              }
              var H3 = this._hash.words;
              var M_offset_0 = M3[offset + 0];
              var M_offset_1 = M3[offset + 1];
              var M_offset_2 = M3[offset + 2];
              var M_offset_3 = M3[offset + 3];
              var M_offset_4 = M3[offset + 4];
              var M_offset_5 = M3[offset + 5];
              var M_offset_6 = M3[offset + 6];
              var M_offset_7 = M3[offset + 7];
              var M_offset_8 = M3[offset + 8];
              var M_offset_9 = M3[offset + 9];
              var M_offset_10 = M3[offset + 10];
              var M_offset_11 = M3[offset + 11];
              var M_offset_12 = M3[offset + 12];
              var M_offset_13 = M3[offset + 13];
              var M_offset_14 = M3[offset + 14];
              var M_offset_15 = M3[offset + 15];
              var a3 = H3[0];
              var b3 = H3[1];
              var c4 = H3[2];
              var d4 = H3[3];
              a3 = FF(a3, b3, c4, d4, M_offset_0, 7, T4[0]);
              d4 = FF(d4, a3, b3, c4, M_offset_1, 12, T4[1]);
              c4 = FF(c4, d4, a3, b3, M_offset_2, 17, T4[2]);
              b3 = FF(b3, c4, d4, a3, M_offset_3, 22, T4[3]);
              a3 = FF(a3, b3, c4, d4, M_offset_4, 7, T4[4]);
              d4 = FF(d4, a3, b3, c4, M_offset_5, 12, T4[5]);
              c4 = FF(c4, d4, a3, b3, M_offset_6, 17, T4[6]);
              b3 = FF(b3, c4, d4, a3, M_offset_7, 22, T4[7]);
              a3 = FF(a3, b3, c4, d4, M_offset_8, 7, T4[8]);
              d4 = FF(d4, a3, b3, c4, M_offset_9, 12, T4[9]);
              c4 = FF(c4, d4, a3, b3, M_offset_10, 17, T4[10]);
              b3 = FF(b3, c4, d4, a3, M_offset_11, 22, T4[11]);
              a3 = FF(a3, b3, c4, d4, M_offset_12, 7, T4[12]);
              d4 = FF(d4, a3, b3, c4, M_offset_13, 12, T4[13]);
              c4 = FF(c4, d4, a3, b3, M_offset_14, 17, T4[14]);
              b3 = FF(b3, c4, d4, a3, M_offset_15, 22, T4[15]);
              a3 = GG(a3, b3, c4, d4, M_offset_1, 5, T4[16]);
              d4 = GG(d4, a3, b3, c4, M_offset_6, 9, T4[17]);
              c4 = GG(c4, d4, a3, b3, M_offset_11, 14, T4[18]);
              b3 = GG(b3, c4, d4, a3, M_offset_0, 20, T4[19]);
              a3 = GG(a3, b3, c4, d4, M_offset_5, 5, T4[20]);
              d4 = GG(d4, a3, b3, c4, M_offset_10, 9, T4[21]);
              c4 = GG(c4, d4, a3, b3, M_offset_15, 14, T4[22]);
              b3 = GG(b3, c4, d4, a3, M_offset_4, 20, T4[23]);
              a3 = GG(a3, b3, c4, d4, M_offset_9, 5, T4[24]);
              d4 = GG(d4, a3, b3, c4, M_offset_14, 9, T4[25]);
              c4 = GG(c4, d4, a3, b3, M_offset_3, 14, T4[26]);
              b3 = GG(b3, c4, d4, a3, M_offset_8, 20, T4[27]);
              a3 = GG(a3, b3, c4, d4, M_offset_13, 5, T4[28]);
              d4 = GG(d4, a3, b3, c4, M_offset_2, 9, T4[29]);
              c4 = GG(c4, d4, a3, b3, M_offset_7, 14, T4[30]);
              b3 = GG(b3, c4, d4, a3, M_offset_12, 20, T4[31]);
              a3 = HH(a3, b3, c4, d4, M_offset_5, 4, T4[32]);
              d4 = HH(d4, a3, b3, c4, M_offset_8, 11, T4[33]);
              c4 = HH(c4, d4, a3, b3, M_offset_11, 16, T4[34]);
              b3 = HH(b3, c4, d4, a3, M_offset_14, 23, T4[35]);
              a3 = HH(a3, b3, c4, d4, M_offset_1, 4, T4[36]);
              d4 = HH(d4, a3, b3, c4, M_offset_4, 11, T4[37]);
              c4 = HH(c4, d4, a3, b3, M_offset_7, 16, T4[38]);
              b3 = HH(b3, c4, d4, a3, M_offset_10, 23, T4[39]);
              a3 = HH(a3, b3, c4, d4, M_offset_13, 4, T4[40]);
              d4 = HH(d4, a3, b3, c4, M_offset_0, 11, T4[41]);
              c4 = HH(c4, d4, a3, b3, M_offset_3, 16, T4[42]);
              b3 = HH(b3, c4, d4, a3, M_offset_6, 23, T4[43]);
              a3 = HH(a3, b3, c4, d4, M_offset_9, 4, T4[44]);
              d4 = HH(d4, a3, b3, c4, M_offset_12, 11, T4[45]);
              c4 = HH(c4, d4, a3, b3, M_offset_15, 16, T4[46]);
              b3 = HH(b3, c4, d4, a3, M_offset_2, 23, T4[47]);
              a3 = II(a3, b3, c4, d4, M_offset_0, 6, T4[48]);
              d4 = II(d4, a3, b3, c4, M_offset_7, 10, T4[49]);
              c4 = II(c4, d4, a3, b3, M_offset_14, 15, T4[50]);
              b3 = II(b3, c4, d4, a3, M_offset_5, 21, T4[51]);
              a3 = II(a3, b3, c4, d4, M_offset_12, 6, T4[52]);
              d4 = II(d4, a3, b3, c4, M_offset_3, 10, T4[53]);
              c4 = II(c4, d4, a3, b3, M_offset_10, 15, T4[54]);
              b3 = II(b3, c4, d4, a3, M_offset_1, 21, T4[55]);
              a3 = II(a3, b3, c4, d4, M_offset_8, 6, T4[56]);
              d4 = II(d4, a3, b3, c4, M_offset_15, 10, T4[57]);
              c4 = II(c4, d4, a3, b3, M_offset_6, 15, T4[58]);
              b3 = II(b3, c4, d4, a3, M_offset_13, 21, T4[59]);
              a3 = II(a3, b3, c4, d4, M_offset_4, 6, T4[60]);
              d4 = II(d4, a3, b3, c4, M_offset_11, 10, T4[61]);
              c4 = II(c4, d4, a3, b3, M_offset_2, 15, T4[62]);
              b3 = II(b3, c4, d4, a3, M_offset_9, 21, T4[63]);
              H3[0] = H3[0] + a3 | 0;
              H3[1] = H3[1] + b3 | 0;
              H3[2] = H3[2] + c4 | 0;
              H3[3] = H3[3] + d4 | 0;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
              var nBitsTotalL = nBitsTotal;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
              data.sigBytes = (dataWords.length + 1) * 4;
              this._process();
              var hash2 = this._hash;
              var H3 = hash2.words;
              for (var i4 = 0; i4 < 4; i4++) {
                var H_i = H3[i4];
                H3[i4] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
              }
              return hash2;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          function FF(a3, b3, c4, d4, x4, s5, t5) {
            var n7 = a3 + (b3 & c4 | ~b3 & d4) + x4 + t5;
            return (n7 << s5 | n7 >>> 32 - s5) + b3;
          }
          function GG(a3, b3, c4, d4, x4, s5, t5) {
            var n7 = a3 + (b3 & d4 | c4 & ~d4) + x4 + t5;
            return (n7 << s5 | n7 >>> 32 - s5) + b3;
          }
          function HH(a3, b3, c4, d4, x4, s5, t5) {
            var n7 = a3 + (b3 ^ c4 ^ d4) + x4 + t5;
            return (n7 << s5 | n7 >>> 32 - s5) + b3;
          }
          function II(a3, b3, c4, d4, x4, s5, t5) {
            var n7 = a3 + (c4 ^ (b3 | ~d4)) + x4 + t5;
            return (n7 << s5 | n7 >>> 32 - s5) + b3;
          }
          C3.MD5 = Hasher._createHelper(MD5);
          C3.HmacMD5 = Hasher._createHmacHelper(MD5);
        })(Math);
        return CryptoJS.MD5;
      });
    }
  });

  // node_modules/crypto-js/sha1.js
  var require_sha1 = __commonJS({
    "node_modules/crypto-js/sha1.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C3.algo;
          var W2 = [];
          var SHA1 = C_algo.SHA1 = Hasher.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                1732584193,
                4023233417,
                2562383102,
                271733878,
                3285377520
              ]);
            },
            _doProcessBlock: function(M3, offset) {
              var H3 = this._hash.words;
              var a3 = H3[0];
              var b3 = H3[1];
              var c4 = H3[2];
              var d4 = H3[3];
              var e8 = H3[4];
              for (var i4 = 0; i4 < 80; i4++) {
                if (i4 < 16) {
                  W2[i4] = M3[offset + i4] | 0;
                } else {
                  var n7 = W2[i4 - 3] ^ W2[i4 - 8] ^ W2[i4 - 14] ^ W2[i4 - 16];
                  W2[i4] = n7 << 1 | n7 >>> 31;
                }
                var t5 = (a3 << 5 | a3 >>> 27) + e8 + W2[i4];
                if (i4 < 20) {
                  t5 += (b3 & c4 | ~b3 & d4) + 1518500249;
                } else if (i4 < 40) {
                  t5 += (b3 ^ c4 ^ d4) + 1859775393;
                } else if (i4 < 60) {
                  t5 += (b3 & c4 | b3 & d4 | c4 & d4) - 1894007588;
                } else {
                  t5 += (b3 ^ c4 ^ d4) - 899497514;
                }
                e8 = d4;
                d4 = c4;
                c4 = b3 << 30 | b3 >>> 2;
                b3 = a3;
                a3 = t5;
              }
              H3[0] = H3[0] + a3 | 0;
              H3[1] = H3[1] + b3 | 0;
              H3[2] = H3[2] + c4 | 0;
              H3[3] = H3[3] + d4 | 0;
              H3[4] = H3[4] + e8 | 0;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
              data.sigBytes = dataWords.length * 4;
              this._process();
              return this._hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          C3.SHA1 = Hasher._createHelper(SHA1);
          C3.HmacSHA1 = Hasher._createHmacHelper(SHA1);
        })();
        return CryptoJS.SHA1;
      });
    }
  });

  // node_modules/crypto-js/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/crypto-js/sha256.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function(Math2) {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C3.algo;
          var H3 = [];
          var K2 = [];
          (function() {
            function isPrime(n8) {
              var sqrtN = Math2.sqrt(n8);
              for (var factor = 2; factor <= sqrtN; factor++) {
                if (!(n8 % factor)) {
                  return false;
                }
              }
              return true;
            }
            function getFractionalBits(n8) {
              return (n8 - (n8 | 0)) * 4294967296 | 0;
            }
            var n7 = 2;
            var nPrime = 0;
            while (nPrime < 64) {
              if (isPrime(n7)) {
                if (nPrime < 8) {
                  H3[nPrime] = getFractionalBits(Math2.pow(n7, 1 / 2));
                }
                K2[nPrime] = getFractionalBits(Math2.pow(n7, 1 / 3));
                nPrime++;
              }
              n7++;
            }
          })();
          var W2 = [];
          var SHA2562 = C_algo.SHA256 = Hasher.extend({
            _doReset: function() {
              this._hash = new WordArray.init(H3.slice(0));
            },
            _doProcessBlock: function(M3, offset) {
              var H4 = this._hash.words;
              var a3 = H4[0];
              var b3 = H4[1];
              var c4 = H4[2];
              var d4 = H4[3];
              var e8 = H4[4];
              var f5 = H4[5];
              var g4 = H4[6];
              var h5 = H4[7];
              for (var i4 = 0; i4 < 64; i4++) {
                if (i4 < 16) {
                  W2[i4] = M3[offset + i4] | 0;
                } else {
                  var gamma0x = W2[i4 - 15];
                  var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                  var gamma1x = W2[i4 - 2];
                  var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                  W2[i4] = gamma0 + W2[i4 - 7] + gamma1 + W2[i4 - 16];
                }
                var ch = e8 & f5 ^ ~e8 & g4;
                var maj = a3 & b3 ^ a3 & c4 ^ b3 & c4;
                var sigma0 = (a3 << 30 | a3 >>> 2) ^ (a3 << 19 | a3 >>> 13) ^ (a3 << 10 | a3 >>> 22);
                var sigma1 = (e8 << 26 | e8 >>> 6) ^ (e8 << 21 | e8 >>> 11) ^ (e8 << 7 | e8 >>> 25);
                var t1 = h5 + sigma1 + ch + K2[i4] + W2[i4];
                var t22 = sigma0 + maj;
                h5 = g4;
                g4 = f5;
                f5 = e8;
                e8 = d4 + t1 | 0;
                d4 = c4;
                c4 = b3;
                b3 = a3;
                a3 = t1 + t22 | 0;
              }
              H4[0] = H4[0] + a3 | 0;
              H4[1] = H4[1] + b3 | 0;
              H4[2] = H4[2] + c4 | 0;
              H4[3] = H4[3] + d4 | 0;
              H4[4] = H4[4] + e8 | 0;
              H4[5] = H4[5] + f5 | 0;
              H4[6] = H4[6] + g4 | 0;
              H4[7] = H4[7] + h5 | 0;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
              data.sigBytes = dataWords.length * 4;
              this._process();
              return this._hash;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          C3.SHA256 = Hasher._createHelper(SHA2562);
          C3.HmacSHA256 = Hasher._createHmacHelper(SHA2562);
        })(Math);
        return CryptoJS.SHA256;
      });
    }
  });

  // node_modules/crypto-js/sha224.js
  var require_sha224 = __commonJS({
    "node_modules/crypto-js/sha224.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_sha256());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./sha256"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var WordArray = C_lib.WordArray;
          var C_algo = C3.algo;
          var SHA2562 = C_algo.SHA256;
          var SHA2242 = C_algo.SHA224 = SHA2562.extend({
            _doReset: function() {
              this._hash = new WordArray.init([
                3238371032,
                914150663,
                812702999,
                4144912697,
                4290775857,
                1750603025,
                1694076839,
                3204075428
              ]);
            },
            _doFinalize: function() {
              var hash2 = SHA2562._doFinalize.call(this);
              hash2.sigBytes -= 4;
              return hash2;
            }
          });
          C3.SHA224 = SHA2562._createHelper(SHA2242);
          C3.HmacSHA224 = SHA2562._createHmacHelper(SHA2242);
        })();
        return CryptoJS.SHA224;
      });
    }
  });

  // node_modules/crypto-js/sha512.js
  var require_sha512 = __commonJS({
    "node_modules/crypto-js/sha512.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_x64_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./x64-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var Hasher = C_lib.Hasher;
          var C_x64 = C3.x64;
          var X64Word = C_x64.Word;
          var X64WordArray = C_x64.WordArray;
          var C_algo = C3.algo;
          function X64Word_create() {
            return X64Word.create.apply(X64Word, arguments);
          }
          var K2 = [
            X64Word_create(1116352408, 3609767458),
            X64Word_create(1899447441, 602891725),
            X64Word_create(3049323471, 3964484399),
            X64Word_create(3921009573, 2173295548),
            X64Word_create(961987163, 4081628472),
            X64Word_create(1508970993, 3053834265),
            X64Word_create(2453635748, 2937671579),
            X64Word_create(2870763221, 3664609560),
            X64Word_create(3624381080, 2734883394),
            X64Word_create(310598401, 1164996542),
            X64Word_create(607225278, 1323610764),
            X64Word_create(1426881987, 3590304994),
            X64Word_create(1925078388, 4068182383),
            X64Word_create(2162078206, 991336113),
            X64Word_create(2614888103, 633803317),
            X64Word_create(3248222580, 3479774868),
            X64Word_create(3835390401, 2666613458),
            X64Word_create(4022224774, 944711139),
            X64Word_create(264347078, 2341262773),
            X64Word_create(604807628, 2007800933),
            X64Word_create(770255983, 1495990901),
            X64Word_create(1249150122, 1856431235),
            X64Word_create(1555081692, 3175218132),
            X64Word_create(1996064986, 2198950837),
            X64Word_create(2554220882, 3999719339),
            X64Word_create(2821834349, 766784016),
            X64Word_create(2952996808, 2566594879),
            X64Word_create(3210313671, 3203337956),
            X64Word_create(3336571891, 1034457026),
            X64Word_create(3584528711, 2466948901),
            X64Word_create(113926993, 3758326383),
            X64Word_create(338241895, 168717936),
            X64Word_create(666307205, 1188179964),
            X64Word_create(773529912, 1546045734),
            X64Word_create(1294757372, 1522805485),
            X64Word_create(1396182291, 2643833823),
            X64Word_create(1695183700, 2343527390),
            X64Word_create(1986661051, 1014477480),
            X64Word_create(2177026350, 1206759142),
            X64Word_create(2456956037, 344077627),
            X64Word_create(2730485921, 1290863460),
            X64Word_create(2820302411, 3158454273),
            X64Word_create(3259730800, 3505952657),
            X64Word_create(3345764771, 106217008),
            X64Word_create(3516065817, 3606008344),
            X64Word_create(3600352804, 1432725776),
            X64Word_create(4094571909, 1467031594),
            X64Word_create(275423344, 851169720),
            X64Word_create(430227734, 3100823752),
            X64Word_create(506948616, 1363258195),
            X64Word_create(659060556, 3750685593),
            X64Word_create(883997877, 3785050280),
            X64Word_create(958139571, 3318307427),
            X64Word_create(1322822218, 3812723403),
            X64Word_create(1537002063, 2003034995),
            X64Word_create(1747873779, 3602036899),
            X64Word_create(1955562222, 1575990012),
            X64Word_create(2024104815, 1125592928),
            X64Word_create(2227730452, 2716904306),
            X64Word_create(2361852424, 442776044),
            X64Word_create(2428436474, 593698344),
            X64Word_create(2756734187, 3733110249),
            X64Word_create(3204031479, 2999351573),
            X64Word_create(3329325298, 3815920427),
            X64Word_create(3391569614, 3928383900),
            X64Word_create(3515267271, 566280711),
            X64Word_create(3940187606, 3454069534),
            X64Word_create(4118630271, 4000239992),
            X64Word_create(116418474, 1914138554),
            X64Word_create(174292421, 2731055270),
            X64Word_create(289380356, 3203993006),
            X64Word_create(460393269, 320620315),
            X64Word_create(685471733, 587496836),
            X64Word_create(852142971, 1086792851),
            X64Word_create(1017036298, 365543100),
            X64Word_create(1126000580, 2618297676),
            X64Word_create(1288033470, 3409855158),
            X64Word_create(1501505948, 4234509866),
            X64Word_create(1607167915, 987167468),
            X64Word_create(1816402316, 1246189591)
          ];
          var W2 = [];
          (function() {
            for (var i4 = 0; i4 < 80; i4++) {
              W2[i4] = X64Word_create();
            }
          })();
          var SHA5122 = C_algo.SHA512 = Hasher.extend({
            _doReset: function() {
              this._hash = new X64WordArray.init([
                new X64Word.init(1779033703, 4089235720),
                new X64Word.init(3144134277, 2227873595),
                new X64Word.init(1013904242, 4271175723),
                new X64Word.init(2773480762, 1595750129),
                new X64Word.init(1359893119, 2917565137),
                new X64Word.init(2600822924, 725511199),
                new X64Word.init(528734635, 4215389547),
                new X64Word.init(1541459225, 327033209)
              ]);
            },
            _doProcessBlock: function(M3, offset) {
              var H3 = this._hash.words;
              var H0 = H3[0];
              var H1 = H3[1];
              var H22 = H3[2];
              var H32 = H3[3];
              var H4 = H3[4];
              var H5 = H3[5];
              var H6 = H3[6];
              var H7 = H3[7];
              var H0h = H0.high;
              var H0l = H0.low;
              var H1h = H1.high;
              var H1l = H1.low;
              var H2h = H22.high;
              var H2l = H22.low;
              var H3h = H32.high;
              var H3l = H32.low;
              var H4h = H4.high;
              var H4l = H4.low;
              var H5h = H5.high;
              var H5l = H5.low;
              var H6h = H6.high;
              var H6l = H6.low;
              var H7h = H7.high;
              var H7l = H7.low;
              var ah = H0h;
              var al = H0l;
              var bh = H1h;
              var bl = H1l;
              var ch = H2h;
              var cl = H2l;
              var dh = H3h;
              var dl = H3l;
              var eh = H4h;
              var el = H4l;
              var fh = H5h;
              var fl = H5l;
              var gh = H6h;
              var gl = H6l;
              var hh = H7h;
              var hl = H7l;
              for (var i4 = 0; i4 < 80; i4++) {
                var Wil;
                var Wih;
                var Wi = W2[i4];
                if (i4 < 16) {
                  Wih = Wi.high = M3[offset + i4 * 2] | 0;
                  Wil = Wi.low = M3[offset + i4 * 2 + 1] | 0;
                } else {
                  var gamma0x = W2[i4 - 15];
                  var gamma0xh = gamma0x.high;
                  var gamma0xl = gamma0x.low;
                  var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                  var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                  var gamma1x = W2[i4 - 2];
                  var gamma1xh = gamma1x.high;
                  var gamma1xl = gamma1x.low;
                  var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                  var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                  var Wi7 = W2[i4 - 7];
                  var Wi7h = Wi7.high;
                  var Wi7l = Wi7.low;
                  var Wi16 = W2[i4 - 16];
                  var Wi16h = Wi16.high;
                  var Wi16l = Wi16.low;
                  Wil = gamma0l + Wi7l;
                  Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                  Wil = Wil + gamma1l;
                  Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                  Wil = Wil + Wi16l;
                  Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                  Wi.high = Wih;
                  Wi.low = Wil;
                }
                var chh = eh & fh ^ ~eh & gh;
                var chl = el & fl ^ ~el & gl;
                var majh = ah & bh ^ ah & ch ^ bh & ch;
                var majl = al & bl ^ al & cl ^ bl & cl;
                var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
                var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
                var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
                var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
                var Ki = K2[i4];
                var Kih = Ki.high;
                var Kil = Ki.low;
                var t1l = hl + sigma1l;
                var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
                var t1l = t1l + chl;
                var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
                var t1l = t1l + Kil;
                var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
                var t1l = t1l + Wil;
                var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
                var t2l = sigma0l + majl;
                var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
                hh = gh;
                hl = gl;
                gh = fh;
                gl = fl;
                fh = eh;
                fl = el;
                el = dl + t1l | 0;
                eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
                dh = ch;
                dl = cl;
                ch = bh;
                cl = bl;
                bh = ah;
                bl = al;
                al = t1l + t2l | 0;
                ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
              }
              H0l = H0.low = H0l + al;
              H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
              H1l = H1.low = H1l + bl;
              H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
              H2l = H22.low = H2l + cl;
              H22.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
              H3l = H32.low = H3l + dl;
              H32.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
              H4l = H4.low = H4l + el;
              H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
              H5l = H5.low = H5l + fl;
              H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
              H6l = H6.low = H6l + gl;
              H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
              H7l = H7.low = H7l + hl;
              H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
              dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
              data.sigBytes = dataWords.length * 4;
              this._process();
              var hash2 = this._hash.toX32();
              return hash2;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            },
            blockSize: 1024 / 32
          });
          C3.SHA512 = Hasher._createHelper(SHA5122);
          C3.HmacSHA512 = Hasher._createHmacHelper(SHA5122);
        })();
        return CryptoJS.SHA512;
      });
    }
  });

  // node_modules/crypto-js/sha384.js
  var require_sha384 = __commonJS({
    "node_modules/crypto-js/sha384.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_x64_core(), require_sha512());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./x64-core", "./sha512"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_x64 = C3.x64;
          var X64Word = C_x64.Word;
          var X64WordArray = C_x64.WordArray;
          var C_algo = C3.algo;
          var SHA5122 = C_algo.SHA512;
          var SHA3842 = C_algo.SHA384 = SHA5122.extend({
            _doReset: function() {
              this._hash = new X64WordArray.init([
                new X64Word.init(3418070365, 3238371032),
                new X64Word.init(1654270250, 914150663),
                new X64Word.init(2438529370, 812702999),
                new X64Word.init(355462360, 4144912697),
                new X64Word.init(1731405415, 4290775857),
                new X64Word.init(2394180231, 1750603025),
                new X64Word.init(3675008525, 1694076839),
                new X64Word.init(1203062813, 3204075428)
              ]);
            },
            _doFinalize: function() {
              var hash2 = SHA5122._doFinalize.call(this);
              hash2.sigBytes -= 16;
              return hash2;
            }
          });
          C3.SHA384 = SHA5122._createHelper(SHA3842);
          C3.HmacSHA384 = SHA5122._createHmacHelper(SHA3842);
        })();
        return CryptoJS.SHA384;
      });
    }
  });

  // node_modules/crypto-js/sha3.js
  var require_sha3 = __commonJS({
    "node_modules/crypto-js/sha3.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_x64_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./x64-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function(Math2) {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_x64 = C3.x64;
          var X64Word = C_x64.Word;
          var C_algo = C3.algo;
          var RHO_OFFSETS = [];
          var PI_INDEXES = [];
          var ROUND_CONSTANTS = [];
          (function() {
            var x4 = 1, y4 = 0;
            for (var t5 = 0; t5 < 24; t5++) {
              RHO_OFFSETS[x4 + 5 * y4] = (t5 + 1) * (t5 + 2) / 2 % 64;
              var newX = y4 % 5;
              var newY = (2 * x4 + 3 * y4) % 5;
              x4 = newX;
              y4 = newY;
            }
            for (var x4 = 0; x4 < 5; x4++) {
              for (var y4 = 0; y4 < 5; y4++) {
                PI_INDEXES[x4 + 5 * y4] = y4 + (2 * x4 + 3 * y4) % 5 * 5;
              }
            }
            var LFSR = 1;
            for (var i4 = 0; i4 < 24; i4++) {
              var roundConstantMsw = 0;
              var roundConstantLsw = 0;
              for (var j2 = 0; j2 < 7; j2++) {
                if (LFSR & 1) {
                  var bitPosition = (1 << j2) - 1;
                  if (bitPosition < 32) {
                    roundConstantLsw ^= 1 << bitPosition;
                  } else {
                    roundConstantMsw ^= 1 << bitPosition - 32;
                  }
                }
                if (LFSR & 128) {
                  LFSR = LFSR << 1 ^ 113;
                } else {
                  LFSR <<= 1;
                }
              }
              ROUND_CONSTANTS[i4] = X64Word.create(roundConstantMsw, roundConstantLsw);
            }
          })();
          var T4 = [];
          (function() {
            for (var i4 = 0; i4 < 25; i4++) {
              T4[i4] = X64Word.create();
            }
          })();
          var SHA3 = C_algo.SHA3 = Hasher.extend({
            /**
             * Configuration options.
             *
             * @property {number} outputLength
             *   The desired number of bits in the output hash.
             *   Only values permitted are: 224, 256, 384, 512.
             *   Default: 512
             */
            cfg: Hasher.cfg.extend({
              outputLength: 512
            }),
            _doReset: function() {
              var state = this._state = [];
              for (var i4 = 0; i4 < 25; i4++) {
                state[i4] = new X64Word.init();
              }
              this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
            },
            _doProcessBlock: function(M3, offset) {
              var state = this._state;
              var nBlockSizeLanes = this.blockSize / 2;
              for (var i4 = 0; i4 < nBlockSizeLanes; i4++) {
                var M2i = M3[offset + 2 * i4];
                var M2i1 = M3[offset + 2 * i4 + 1];
                M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
                M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
                var lane = state[i4];
                lane.high ^= M2i1;
                lane.low ^= M2i;
              }
              for (var round = 0; round < 24; round++) {
                for (var x4 = 0; x4 < 5; x4++) {
                  var tMsw = 0, tLsw = 0;
                  for (var y4 = 0; y4 < 5; y4++) {
                    var lane = state[x4 + 5 * y4];
                    tMsw ^= lane.high;
                    tLsw ^= lane.low;
                  }
                  var Tx = T4[x4];
                  Tx.high = tMsw;
                  Tx.low = tLsw;
                }
                for (var x4 = 0; x4 < 5; x4++) {
                  var Tx4 = T4[(x4 + 4) % 5];
                  var Tx1 = T4[(x4 + 1) % 5];
                  var Tx1Msw = Tx1.high;
                  var Tx1Lsw = Tx1.low;
                  var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                  var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                  for (var y4 = 0; y4 < 5; y4++) {
                    var lane = state[x4 + 5 * y4];
                    lane.high ^= tMsw;
                    lane.low ^= tLsw;
                  }
                }
                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                  var tMsw;
                  var tLsw;
                  var lane = state[laneIndex];
                  var laneMsw = lane.high;
                  var laneLsw = lane.low;
                  var rhoOffset = RHO_OFFSETS[laneIndex];
                  if (rhoOffset < 32) {
                    tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                    tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                  } else {
                    tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                    tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                  }
                  var TPiLane = T4[PI_INDEXES[laneIndex]];
                  TPiLane.high = tMsw;
                  TPiLane.low = tLsw;
                }
                var T0 = T4[0];
                var state0 = state[0];
                T0.high = state0.high;
                T0.low = state0.low;
                for (var x4 = 0; x4 < 5; x4++) {
                  for (var y4 = 0; y4 < 5; y4++) {
                    var laneIndex = x4 + 5 * y4;
                    var lane = state[laneIndex];
                    var TLane = T4[laneIndex];
                    var Tx1Lane = T4[(x4 + 1) % 5 + 5 * y4];
                    var Tx2Lane = T4[(x4 + 2) % 5 + 5 * y4];
                    lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                    lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                  }
                }
                var lane = state[0];
                var roundConstant = ROUND_CONSTANTS[round];
                lane.high ^= roundConstant.high;
                lane.low ^= roundConstant.low;
              }
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              var blockSizeBits = this.blockSize * 32;
              dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
              dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
              data.sigBytes = dataWords.length * 4;
              this._process();
              var state = this._state;
              var outputLengthBytes = this.cfg.outputLength / 8;
              var outputLengthLanes = outputLengthBytes / 8;
              var hashWords = [];
              for (var i4 = 0; i4 < outputLengthLanes; i4++) {
                var lane = state[i4];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
                laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
                hashWords.push(laneLsw);
                hashWords.push(laneMsw);
              }
              return new WordArray.init(hashWords, outputLengthBytes);
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              var state = clone._state = this._state.slice(0);
              for (var i4 = 0; i4 < 25; i4++) {
                state[i4] = state[i4].clone();
              }
              return clone;
            }
          });
          C3.SHA3 = Hasher._createHelper(SHA3);
          C3.HmacSHA3 = Hasher._createHmacHelper(SHA3);
        })(Math);
        return CryptoJS.SHA3;
      });
    }
  });

  // node_modules/crypto-js/ripemd160.js
  var require_ripemd160 = __commonJS({
    "node_modules/crypto-js/ripemd160.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function(Math2) {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var WordArray = C_lib.WordArray;
          var Hasher = C_lib.Hasher;
          var C_algo = C3.algo;
          var _zl = WordArray.create([
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            7,
            4,
            13,
            1,
            10,
            6,
            15,
            3,
            12,
            0,
            9,
            5,
            2,
            14,
            11,
            8,
            3,
            10,
            14,
            4,
            9,
            15,
            8,
            1,
            2,
            7,
            0,
            6,
            13,
            11,
            5,
            12,
            1,
            9,
            11,
            10,
            0,
            8,
            12,
            4,
            13,
            3,
            7,
            15,
            14,
            5,
            6,
            2,
            4,
            0,
            5,
            9,
            7,
            12,
            2,
            10,
            14,
            1,
            3,
            8,
            11,
            6,
            15,
            13
          ]);
          var _zr = WordArray.create([
            5,
            14,
            7,
            0,
            9,
            2,
            11,
            4,
            13,
            6,
            15,
            8,
            1,
            10,
            3,
            12,
            6,
            11,
            3,
            7,
            0,
            13,
            5,
            10,
            14,
            15,
            8,
            12,
            4,
            9,
            1,
            2,
            15,
            5,
            1,
            3,
            7,
            14,
            6,
            9,
            11,
            8,
            12,
            2,
            10,
            0,
            4,
            13,
            8,
            6,
            4,
            1,
            3,
            11,
            15,
            0,
            5,
            12,
            2,
            13,
            9,
            7,
            10,
            14,
            12,
            15,
            10,
            4,
            1,
            5,
            8,
            7,
            6,
            2,
            13,
            14,
            0,
            3,
            9,
            11
          ]);
          var _sl = WordArray.create([
            11,
            14,
            15,
            12,
            5,
            8,
            7,
            9,
            11,
            13,
            14,
            15,
            6,
            7,
            9,
            8,
            7,
            6,
            8,
            13,
            11,
            9,
            7,
            15,
            7,
            12,
            15,
            9,
            11,
            7,
            13,
            12,
            11,
            13,
            6,
            7,
            14,
            9,
            13,
            15,
            14,
            8,
            13,
            6,
            5,
            12,
            7,
            5,
            11,
            12,
            14,
            15,
            14,
            15,
            9,
            8,
            9,
            14,
            5,
            6,
            8,
            6,
            5,
            12,
            9,
            15,
            5,
            11,
            6,
            8,
            13,
            12,
            5,
            12,
            13,
            14,
            11,
            8,
            5,
            6
          ]);
          var _sr = WordArray.create([
            8,
            9,
            9,
            11,
            13,
            15,
            15,
            5,
            7,
            7,
            8,
            11,
            14,
            14,
            12,
            6,
            9,
            13,
            15,
            7,
            12,
            8,
            9,
            11,
            7,
            7,
            12,
            7,
            6,
            15,
            13,
            11,
            9,
            7,
            15,
            11,
            8,
            6,
            6,
            14,
            12,
            13,
            5,
            14,
            13,
            13,
            7,
            5,
            15,
            5,
            8,
            11,
            14,
            14,
            6,
            14,
            6,
            9,
            12,
            9,
            12,
            5,
            15,
            8,
            8,
            5,
            12,
            9,
            12,
            5,
            14,
            6,
            8,
            13,
            6,
            5,
            15,
            13,
            11,
            11
          ]);
          var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
          var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
          var RIPEMD1602 = C_algo.RIPEMD160 = Hasher.extend({
            _doReset: function() {
              this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
            },
            _doProcessBlock: function(M3, offset) {
              for (var i4 = 0; i4 < 16; i4++) {
                var offset_i = offset + i4;
                var M_offset_i = M3[offset_i];
                M3[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
              }
              var H3 = this._hash.words;
              var hl = _hl.words;
              var hr = _hr.words;
              var zl = _zl.words;
              var zr = _zr.words;
              var sl = _sl.words;
              var sr = _sr.words;
              var al, bl, cl, dl, el;
              var ar, br, cr, dr, er;
              ar = al = H3[0];
              br = bl = H3[1];
              cr = cl = H3[2];
              dr = dl = H3[3];
              er = el = H3[4];
              var t5;
              for (var i4 = 0; i4 < 80; i4 += 1) {
                t5 = al + M3[offset + zl[i4]] | 0;
                if (i4 < 16) {
                  t5 += f1(bl, cl, dl) + hl[0];
                } else if (i4 < 32) {
                  t5 += f22(bl, cl, dl) + hl[1];
                } else if (i4 < 48) {
                  t5 += f32(bl, cl, dl) + hl[2];
                } else if (i4 < 64) {
                  t5 += f42(bl, cl, dl) + hl[3];
                } else {
                  t5 += f5(bl, cl, dl) + hl[4];
                }
                t5 = t5 | 0;
                t5 = rotl2(t5, sl[i4]);
                t5 = t5 + el | 0;
                al = el;
                el = dl;
                dl = rotl2(cl, 10);
                cl = bl;
                bl = t5;
                t5 = ar + M3[offset + zr[i4]] | 0;
                if (i4 < 16) {
                  t5 += f5(br, cr, dr) + hr[0];
                } else if (i4 < 32) {
                  t5 += f42(br, cr, dr) + hr[1];
                } else if (i4 < 48) {
                  t5 += f32(br, cr, dr) + hr[2];
                } else if (i4 < 64) {
                  t5 += f22(br, cr, dr) + hr[3];
                } else {
                  t5 += f1(br, cr, dr) + hr[4];
                }
                t5 = t5 | 0;
                t5 = rotl2(t5, sr[i4]);
                t5 = t5 + er | 0;
                ar = er;
                er = dr;
                dr = rotl2(cr, 10);
                cr = br;
                br = t5;
              }
              t5 = H3[1] + cl + dr | 0;
              H3[1] = H3[2] + dl + er | 0;
              H3[2] = H3[3] + el + ar | 0;
              H3[3] = H3[4] + al + br | 0;
              H3[4] = H3[0] + bl + cr | 0;
              H3[0] = t5;
            },
            _doFinalize: function() {
              var data = this._data;
              var dataWords = data.words;
              var nBitsTotal = this._nDataBytes * 8;
              var nBitsLeft = data.sigBytes * 8;
              dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
              dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
              data.sigBytes = (dataWords.length + 1) * 4;
              this._process();
              var hash2 = this._hash;
              var H3 = hash2.words;
              for (var i4 = 0; i4 < 5; i4++) {
                var H_i = H3[i4];
                H3[i4] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
              }
              return hash2;
            },
            clone: function() {
              var clone = Hasher.clone.call(this);
              clone._hash = this._hash.clone();
              return clone;
            }
          });
          function f1(x4, y4, z3) {
            return x4 ^ y4 ^ z3;
          }
          function f22(x4, y4, z3) {
            return x4 & y4 | ~x4 & z3;
          }
          function f32(x4, y4, z3) {
            return (x4 | ~y4) ^ z3;
          }
          function f42(x4, y4, z3) {
            return x4 & z3 | y4 & ~z3;
          }
          function f5(x4, y4, z3) {
            return x4 ^ (y4 | ~z3);
          }
          function rotl2(x4, n7) {
            return x4 << n7 | x4 >>> 32 - n7;
          }
          C3.RIPEMD160 = Hasher._createHelper(RIPEMD1602);
          C3.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD1602);
        })(Math);
        return CryptoJS.RIPEMD160;
      });
    }
  });

  // node_modules/crypto-js/hmac.js
  var require_hmac = __commonJS({
    "node_modules/crypto-js/hmac.js"(exports, module) {
      (function(root, factory) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var Base = C_lib.Base;
          var C_enc = C3.enc;
          var Utf8 = C_enc.Utf8;
          var C_algo = C3.algo;
          var HMAC2 = C_algo.HMAC = Base.extend({
            /**
             * Initializes a newly created HMAC.
             *
             * @param {Hasher} hasher The hash algorithm to use.
             * @param {WordArray|string} key The secret key.
             *
             * @example
             *
             *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
             */
            init: function(hasher, key) {
              hasher = this._hasher = new hasher.init();
              if (typeof key == "string") {
                key = Utf8.parse(key);
              }
              var hasherBlockSize = hasher.blockSize;
              var hasherBlockSizeBytes = hasherBlockSize * 4;
              if (key.sigBytes > hasherBlockSizeBytes) {
                key = hasher.finalize(key);
              }
              key.clamp();
              var oKey = this._oKey = key.clone();
              var iKey = this._iKey = key.clone();
              var oKeyWords = oKey.words;
              var iKeyWords = iKey.words;
              for (var i4 = 0; i4 < hasherBlockSize; i4++) {
                oKeyWords[i4] ^= 1549556828;
                iKeyWords[i4] ^= 909522486;
              }
              oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
              this.reset();
            },
            /**
             * Resets this HMAC to its initial state.
             *
             * @example
             *
             *     hmacHasher.reset();
             */
            reset: function() {
              var hasher = this._hasher;
              hasher.reset();
              hasher.update(this._iKey);
            },
            /**
             * Updates this HMAC with a message.
             *
             * @param {WordArray|string} messageUpdate The message to append.
             *
             * @return {HMAC} This HMAC instance.
             *
             * @example
             *
             *     hmacHasher.update('message');
             *     hmacHasher.update(wordArray);
             */
            update: function(messageUpdate) {
              this._hasher.update(messageUpdate);
              return this;
            },
            /**
             * Finalizes the HMAC computation.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} messageUpdate (Optional) A final message update.
             *
             * @return {WordArray} The HMAC.
             *
             * @example
             *
             *     var hmac = hmacHasher.finalize();
             *     var hmac = hmacHasher.finalize('message');
             *     var hmac = hmacHasher.finalize(wordArray);
             */
            finalize: function(messageUpdate) {
              var hasher = this._hasher;
              var innerHash = hasher.finalize(messageUpdate);
              hasher.reset();
              var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
              return hmac2;
            }
          });
        })();
      });
    }
  });

  // node_modules/crypto-js/pbkdf2.js
  var require_pbkdf2 = __commonJS({
    "node_modules/crypto-js/pbkdf2.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./sha1", "./hmac"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var C_algo = C3.algo;
          var SHA1 = C_algo.SHA1;
          var HMAC2 = C_algo.HMAC;
          var PBKDF2 = C_algo.PBKDF2 = Base.extend({
            /**
             * Configuration options.
             *
             * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
             * @property {Hasher} hasher The hasher to use. Default: SHA1
             * @property {number} iterations The number of iterations to perform. Default: 1
             */
            cfg: Base.extend({
              keySize: 128 / 32,
              hasher: SHA1,
              iterations: 1
            }),
            /**
             * Initializes a newly created key derivation function.
             *
             * @param {Object} cfg (Optional) The configuration options to use for the derivation.
             *
             * @example
             *
             *     var kdf = CryptoJS.algo.PBKDF2.create();
             *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
             *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
            },
            /**
             * Computes the Password-Based Key Derivation Function 2.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             *
             * @return {WordArray} The derived key.
             *
             * @example
             *
             *     var key = kdf.compute(password, salt);
             */
            compute: function(password, salt2) {
              var cfg = this.cfg;
              var hmac2 = HMAC2.create(cfg.hasher, password);
              var derivedKey = WordArray.create();
              var blockIndex = WordArray.create([1]);
              var derivedKeyWords = derivedKey.words;
              var blockIndexWords = blockIndex.words;
              var keySize = cfg.keySize;
              var iterations = cfg.iterations;
              while (derivedKeyWords.length < keySize) {
                var block = hmac2.update(salt2).finalize(blockIndex);
                hmac2.reset();
                var blockWords = block.words;
                var blockWordsLength = blockWords.length;
                var intermediate = block;
                for (var i4 = 1; i4 < iterations; i4++) {
                  intermediate = hmac2.finalize(intermediate);
                  hmac2.reset();
                  var intermediateWords = intermediate.words;
                  for (var j2 = 0; j2 < blockWordsLength; j2++) {
                    blockWords[j2] ^= intermediateWords[j2];
                  }
                }
                derivedKey.concat(block);
                blockIndexWords[0]++;
              }
              derivedKey.sigBytes = keySize * 4;
              return derivedKey;
            }
          });
          C3.PBKDF2 = function(password, salt2, cfg) {
            return PBKDF2.create(cfg).compute(password, salt2);
          };
        })();
        return CryptoJS.PBKDF2;
      });
    }
  });

  // node_modules/crypto-js/evpkdf.js
  var require_evpkdf = __commonJS({
    "node_modules/crypto-js/evpkdf.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_sha1(), require_hmac());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./sha1", "./hmac"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var C_algo = C3.algo;
          var MD5 = C_algo.MD5;
          var EvpKDF = C_algo.EvpKDF = Base.extend({
            /**
             * Configuration options.
             *
             * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
             * @property {Hasher} hasher The hash algorithm to use. Default: MD5
             * @property {number} iterations The number of iterations to perform. Default: 1
             */
            cfg: Base.extend({
              keySize: 128 / 32,
              hasher: MD5,
              iterations: 1
            }),
            /**
             * Initializes a newly created key derivation function.
             *
             * @param {Object} cfg (Optional) The configuration options to use for the derivation.
             *
             * @example
             *
             *     var kdf = CryptoJS.algo.EvpKDF.create();
             *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
             *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
             */
            init: function(cfg) {
              this.cfg = this.cfg.extend(cfg);
            },
            /**
             * Derives a key from a password.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             *
             * @return {WordArray} The derived key.
             *
             * @example
             *
             *     var key = kdf.compute(password, salt);
             */
            compute: function(password, salt2) {
              var block;
              var cfg = this.cfg;
              var hasher = cfg.hasher.create();
              var derivedKey = WordArray.create();
              var derivedKeyWords = derivedKey.words;
              var keySize = cfg.keySize;
              var iterations = cfg.iterations;
              while (derivedKeyWords.length < keySize) {
                if (block) {
                  hasher.update(block);
                }
                block = hasher.update(password).finalize(salt2);
                hasher.reset();
                for (var i4 = 1; i4 < iterations; i4++) {
                  block = hasher.finalize(block);
                  hasher.reset();
                }
                derivedKey.concat(block);
              }
              derivedKey.sigBytes = keySize * 4;
              return derivedKey;
            }
          });
          C3.EvpKDF = function(password, salt2, cfg) {
            return EvpKDF.create(cfg).compute(password, salt2);
          };
        })();
        return CryptoJS.EvpKDF;
      });
    }
  });

  // node_modules/crypto-js/cipher-core.js
  var require_cipher_core = __commonJS({
    "node_modules/crypto-js/cipher-core.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_evpkdf());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./evpkdf"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.lib.Cipher || function(undefined2) {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var Base = C_lib.Base;
          var WordArray = C_lib.WordArray;
          var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
          var C_enc = C3.enc;
          var Utf8 = C_enc.Utf8;
          var Base64 = C_enc.Base64;
          var C_algo = C3.algo;
          var EvpKDF = C_algo.EvpKDF;
          var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
            /**
             * Configuration options.
             *
             * @property {WordArray} iv The IV to use for this operation.
             */
            cfg: Base.extend(),
            /**
             * Creates this cipher in encryption mode.
             *
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {Cipher} A cipher instance.
             *
             * @static
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
             */
            createEncryptor: function(key, cfg) {
              return this.create(this._ENC_XFORM_MODE, key, cfg);
            },
            /**
             * Creates this cipher in decryption mode.
             *
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {Cipher} A cipher instance.
             *
             * @static
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
             */
            createDecryptor: function(key, cfg) {
              return this.create(this._DEC_XFORM_MODE, key, cfg);
            },
            /**
             * Initializes a newly created cipher.
             *
             * @param {number} xformMode Either the encryption or decryption transormation mode constant.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @example
             *
             *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
             */
            init: function(xformMode, key, cfg) {
              this.cfg = this.cfg.extend(cfg);
              this._xformMode = xformMode;
              this._key = key;
              this.reset();
            },
            /**
             * Resets this cipher to its initial state.
             *
             * @example
             *
             *     cipher.reset();
             */
            reset: function() {
              BufferedBlockAlgorithm.reset.call(this);
              this._doReset();
            },
            /**
             * Adds data to be encrypted or decrypted.
             *
             * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
             *
             * @return {WordArray} The data after processing.
             *
             * @example
             *
             *     var encrypted = cipher.process('data');
             *     var encrypted = cipher.process(wordArray);
             */
            process: function(dataUpdate) {
              this._append(dataUpdate);
              return this._process();
            },
            /**
             * Finalizes the encryption or decryption process.
             * Note that the finalize operation is effectively a destructive, read-once operation.
             *
             * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
             *
             * @return {WordArray} The data after final processing.
             *
             * @example
             *
             *     var encrypted = cipher.finalize();
             *     var encrypted = cipher.finalize('data');
             *     var encrypted = cipher.finalize(wordArray);
             */
            finalize: function(dataUpdate) {
              if (dataUpdate) {
                this._append(dataUpdate);
              }
              var finalProcessedData = this._doFinalize();
              return finalProcessedData;
            },
            keySize: 128 / 32,
            ivSize: 128 / 32,
            _ENC_XFORM_MODE: 1,
            _DEC_XFORM_MODE: 2,
            /**
             * Creates shortcut functions to a cipher's object interface.
             *
             * @param {Cipher} cipher The cipher to create a helper for.
             *
             * @return {Object} An object with encrypt and decrypt shortcut functions.
             *
             * @static
             *
             * @example
             *
             *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
             */
            _createHelper: function() {
              function selectCipherStrategy(key) {
                if (typeof key == "string") {
                  return PasswordBasedCipher;
                } else {
                  return SerializableCipher;
                }
              }
              return function(cipher) {
                return {
                  encrypt: function(message, key, cfg) {
                    return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                  },
                  decrypt: function(ciphertext, key, cfg) {
                    return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                  }
                };
              };
            }()
          });
          var StreamCipher = C_lib.StreamCipher = Cipher.extend({
            _doFinalize: function() {
              var finalProcessedBlocks = this._process(true);
              return finalProcessedBlocks;
            },
            blockSize: 1
          });
          var C_mode = C3.mode = {};
          var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
            /**
             * Creates this mode for encryption.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @static
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
             */
            createEncryptor: function(cipher, iv) {
              return this.Encryptor.create(cipher, iv);
            },
            /**
             * Creates this mode for decryption.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @static
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
             */
            createDecryptor: function(cipher, iv) {
              return this.Decryptor.create(cipher, iv);
            },
            /**
             * Initializes a newly created mode.
             *
             * @param {Cipher} cipher A block cipher instance.
             * @param {Array} iv The IV words.
             *
             * @example
             *
             *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
             */
            init: function(cipher, iv) {
              this._cipher = cipher;
              this._iv = iv;
            }
          });
          var CBC = C_mode.CBC = function() {
            var CBC2 = BlockCipherMode.extend();
            CBC2.Encryptor = CBC2.extend({
              /**
               * Processes the data block at offset.
               *
               * @param {Array} words The data words to operate on.
               * @param {number} offset The offset where the block starts.
               *
               * @example
               *
               *     mode.processBlock(data.words, offset);
               */
              processBlock: function(words, offset) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                xorBlock.call(this, words, offset, blockSize);
                cipher.encryptBlock(words, offset);
                this._prevBlock = words.slice(offset, offset + blockSize);
              }
            });
            CBC2.Decryptor = CBC2.extend({
              /**
               * Processes the data block at offset.
               *
               * @param {Array} words The data words to operate on.
               * @param {number} offset The offset where the block starts.
               *
               * @example
               *
               *     mode.processBlock(data.words, offset);
               */
              processBlock: function(words, offset) {
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                var thisBlock = words.slice(offset, offset + blockSize);
                cipher.decryptBlock(words, offset);
                xorBlock.call(this, words, offset, blockSize);
                this._prevBlock = thisBlock;
              }
            });
            function xorBlock(words, offset, blockSize) {
              var block;
              var iv = this._iv;
              if (iv) {
                block = iv;
                this._iv = undefined2;
              } else {
                block = this._prevBlock;
              }
              for (var i4 = 0; i4 < blockSize; i4++) {
                words[offset + i4] ^= block[i4];
              }
            }
            return CBC2;
          }();
          var C_pad = C3.pad = {};
          var Pkcs7 = C_pad.Pkcs7 = {
            /**
             * Pads data using the algorithm defined in PKCS #5/7.
             *
             * @param {WordArray} data The data to pad.
             * @param {number} blockSize The multiple that the data should be padded to.
             *
             * @static
             *
             * @example
             *
             *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
             */
            pad: function(data, blockSize) {
              var blockSizeBytes = blockSize * 4;
              var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
              var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
              var paddingWords = [];
              for (var i4 = 0; i4 < nPaddingBytes; i4 += 4) {
                paddingWords.push(paddingWord);
              }
              var padding2 = WordArray.create(paddingWords, nPaddingBytes);
              data.concat(padding2);
            },
            /**
             * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
             *
             * @param {WordArray} data The data to unpad.
             *
             * @static
             *
             * @example
             *
             *     CryptoJS.pad.Pkcs7.unpad(wordArray);
             */
            unpad: function(data) {
              var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
              data.sigBytes -= nPaddingBytes;
            }
          };
          var BlockCipher = C_lib.BlockCipher = Cipher.extend({
            /**
             * Configuration options.
             *
             * @property {Mode} mode The block mode to use. Default: CBC
             * @property {Padding} padding The padding strategy to use. Default: Pkcs7
             */
            cfg: Cipher.cfg.extend({
              mode: CBC,
              padding: Pkcs7
            }),
            reset: function() {
              var modeCreator;
              Cipher.reset.call(this);
              var cfg = this.cfg;
              var iv = cfg.iv;
              var mode = cfg.mode;
              if (this._xformMode == this._ENC_XFORM_MODE) {
                modeCreator = mode.createEncryptor;
              } else {
                modeCreator = mode.createDecryptor;
                this._minBufferSize = 1;
              }
              if (this._mode && this._mode.__creator == modeCreator) {
                this._mode.init(this, iv && iv.words);
              } else {
                this._mode = modeCreator.call(mode, this, iv && iv.words);
                this._mode.__creator = modeCreator;
              }
            },
            _doProcessBlock: function(words, offset) {
              this._mode.processBlock(words, offset);
            },
            _doFinalize: function() {
              var finalProcessedBlocks;
              var padding2 = this.cfg.padding;
              if (this._xformMode == this._ENC_XFORM_MODE) {
                padding2.pad(this._data, this.blockSize);
                finalProcessedBlocks = this._process(true);
              } else {
                finalProcessedBlocks = this._process(true);
                padding2.unpad(finalProcessedBlocks);
              }
              return finalProcessedBlocks;
            },
            blockSize: 128 / 32
          });
          var CipherParams = C_lib.CipherParams = Base.extend({
            /**
             * Initializes a newly created cipher params object.
             *
             * @param {Object} cipherParams An object with any of the possible cipher parameters.
             *
             * @example
             *
             *     var cipherParams = CryptoJS.lib.CipherParams.create({
             *         ciphertext: ciphertextWordArray,
             *         key: keyWordArray,
             *         iv: ivWordArray,
             *         salt: saltWordArray,
             *         algorithm: CryptoJS.algo.AES,
             *         mode: CryptoJS.mode.CBC,
             *         padding: CryptoJS.pad.PKCS7,
             *         blockSize: 4,
             *         formatter: CryptoJS.format.OpenSSL
             *     });
             */
            init: function(cipherParams) {
              this.mixIn(cipherParams);
            },
            /**
             * Converts this cipher params object to a string.
             *
             * @param {Format} formatter (Optional) The formatting strategy to use.
             *
             * @return {string} The stringified cipher params.
             *
             * @throws Error If neither the formatter nor the default formatter is set.
             *
             * @example
             *
             *     var string = cipherParams + '';
             *     var string = cipherParams.toString();
             *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
             */
            toString: function(formatter) {
              return (formatter || this.formatter).stringify(this);
            }
          });
          var C_format = C3.format = {};
          var OpenSSLFormatter = C_format.OpenSSL = {
            /**
             * Converts a cipher params object to an OpenSSL-compatible string.
             *
             * @param {CipherParams} cipherParams The cipher params object.
             *
             * @return {string} The OpenSSL-compatible string.
             *
             * @static
             *
             * @example
             *
             *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
             */
            stringify: function(cipherParams) {
              var wordArray;
              var ciphertext = cipherParams.ciphertext;
              var salt2 = cipherParams.salt;
              if (salt2) {
                wordArray = WordArray.create([1398893684, 1701076831]).concat(salt2).concat(ciphertext);
              } else {
                wordArray = ciphertext;
              }
              return wordArray.toString(Base64);
            },
            /**
             * Converts an OpenSSL-compatible string to a cipher params object.
             *
             * @param {string} openSSLStr The OpenSSL-compatible string.
             *
             * @return {CipherParams} The cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
             */
            parse: function(openSSLStr) {
              var salt2;
              var ciphertext = Base64.parse(openSSLStr);
              var ciphertextWords = ciphertext.words;
              if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
                salt2 = WordArray.create(ciphertextWords.slice(2, 4));
                ciphertextWords.splice(0, 4);
                ciphertext.sigBytes -= 16;
              }
              return CipherParams.create({ ciphertext, salt: salt2 });
            }
          };
          var SerializableCipher = C_lib.SerializableCipher = Base.extend({
            /**
             * Configuration options.
             *
             * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
             */
            cfg: Base.extend({
              format: OpenSSLFormatter
            }),
            /**
             * Encrypts a message.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {WordArray|string} message The message to encrypt.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {CipherParams} A cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             */
            encrypt: function(cipher, message, key, cfg) {
              cfg = this.cfg.extend(cfg);
              var encryptor = cipher.createEncryptor(key, cfg);
              var ciphertext = encryptor.finalize(message);
              var cipherCfg = encryptor.cfg;
              return CipherParams.create({
                ciphertext,
                key,
                iv: cipherCfg.iv,
                algorithm: cipher,
                mode: cipherCfg.mode,
                padding: cipherCfg.padding,
                blockSize: cipher.blockSize,
                formatter: cfg.format
              });
            },
            /**
             * Decrypts serialized ciphertext.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
             * @param {WordArray} key The key.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {WordArray} The plaintext.
             *
             * @static
             *
             * @example
             *
             *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
             */
            decrypt: function(cipher, ciphertext, key, cfg) {
              cfg = this.cfg.extend(cfg);
              ciphertext = this._parse(ciphertext, cfg.format);
              var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
              return plaintext;
            },
            /**
             * Converts serialized ciphertext to CipherParams,
             * else assumed CipherParams already and returns ciphertext unchanged.
             *
             * @param {CipherParams|string} ciphertext The ciphertext.
             * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
             *
             * @return {CipherParams} The unserialized ciphertext.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
             */
            _parse: function(ciphertext, format) {
              if (typeof ciphertext == "string") {
                return format.parse(ciphertext, this);
              } else {
                return ciphertext;
              }
            }
          });
          var C_kdf = C3.kdf = {};
          var OpenSSLKdf = C_kdf.OpenSSL = {
            /**
             * Derives a key and IV from a password.
             *
             * @param {string} password The password to derive from.
             * @param {number} keySize The size in words of the key to generate.
             * @param {number} ivSize The size in words of the IV to generate.
             * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
             *
             * @return {CipherParams} A cipher params object with the key, IV, and salt.
             *
             * @static
             *
             * @example
             *
             *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
             *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
             */
            execute: function(password, keySize, ivSize, salt2) {
              if (!salt2) {
                salt2 = WordArray.random(64 / 8);
              }
              var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt2);
              var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
              key.sigBytes = keySize * 4;
              return CipherParams.create({ key, iv, salt: salt2 });
            }
          };
          var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
            /**
             * Configuration options.
             *
             * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
             */
            cfg: SerializableCipher.cfg.extend({
              kdf: OpenSSLKdf
            }),
            /**
             * Encrypts a message using a password.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {WordArray|string} message The message to encrypt.
             * @param {string} password The password.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {CipherParams} A cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
             *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
             */
            encrypt: function(cipher, message, password, cfg) {
              cfg = this.cfg.extend(cfg);
              var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
              cfg.iv = derivedParams.iv;
              var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
              ciphertext.mixIn(derivedParams);
              return ciphertext;
            },
            /**
             * Decrypts serialized ciphertext using a password.
             *
             * @param {Cipher} cipher The cipher algorithm to use.
             * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
             * @param {string} password The password.
             * @param {Object} cfg (Optional) The configuration options to use for this operation.
             *
             * @return {WordArray} The plaintext.
             *
             * @static
             *
             * @example
             *
             *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
             *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
             */
            decrypt: function(cipher, ciphertext, password, cfg) {
              cfg = this.cfg.extend(cfg);
              ciphertext = this._parse(ciphertext, cfg.format);
              var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
              cfg.iv = derivedParams.iv;
              var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
              return plaintext;
            }
          });
        }();
      });
    }
  });

  // node_modules/crypto-js/mode-cfb.js
  var require_mode_cfb = __commonJS({
    "node_modules/crypto-js/mode-cfb.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.mode.CFB = function() {
          var CFB = CryptoJS.lib.BlockCipherMode.extend();
          CFB.Encryptor = CFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CFB.Decryptor = CFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
              this._prevBlock = thisBlock;
            }
          });
          function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
            var keystream;
            var iv = this._iv;
            if (iv) {
              keystream = iv.slice(0);
              this._iv = void 0;
            } else {
              keystream = this._prevBlock;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i4 = 0; i4 < blockSize; i4++) {
              words[offset + i4] ^= keystream[i4];
            }
          }
          return CFB;
        }();
        return CryptoJS.mode.CFB;
      });
    }
  });

  // node_modules/crypto-js/mode-ctr.js
  var require_mode_ctr = __commonJS({
    "node_modules/crypto-js/mode-ctr.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.mode.CTR = function() {
          var CTR = CryptoJS.lib.BlockCipherMode.extend();
          var Encryptor = CTR.Encryptor = CTR.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var counter = this._counter;
              if (iv) {
                counter = this._counter = iv.slice(0);
                this._iv = void 0;
              }
              var keystream = counter.slice(0);
              cipher.encryptBlock(keystream, 0);
              counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
              for (var i4 = 0; i4 < blockSize; i4++) {
                words[offset + i4] ^= keystream[i4];
              }
            }
          });
          CTR.Decryptor = Encryptor;
          return CTR;
        }();
        return CryptoJS.mode.CTR;
      });
    }
  });

  // node_modules/crypto-js/mode-ctr-gladman.js
  var require_mode_ctr_gladman = __commonJS({
    "node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.mode.CTRGladman = function() {
          var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
          function incWord(word) {
            if ((word >> 24 & 255) === 255) {
              var b1 = word >> 16 & 255;
              var b22 = word >> 8 & 255;
              var b3 = word & 255;
              if (b1 === 255) {
                b1 = 0;
                if (b22 === 255) {
                  b22 = 0;
                  if (b3 === 255) {
                    b3 = 0;
                  } else {
                    ++b3;
                  }
                } else {
                  ++b22;
                }
              } else {
                ++b1;
              }
              word = 0;
              word += b1 << 16;
              word += b22 << 8;
              word += b3;
            } else {
              word += 1 << 24;
            }
            return word;
          }
          function incCounter(counter) {
            if ((counter[0] = incWord(counter[0])) === 0) {
              counter[1] = incWord(counter[1]);
            }
            return counter;
          }
          var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var counter = this._counter;
              if (iv) {
                counter = this._counter = iv.slice(0);
                this._iv = void 0;
              }
              incCounter(counter);
              var keystream = counter.slice(0);
              cipher.encryptBlock(keystream, 0);
              for (var i4 = 0; i4 < blockSize; i4++) {
                words[offset + i4] ^= keystream[i4];
              }
            }
          });
          CTRGladman.Decryptor = Encryptor;
          return CTRGladman;
        }();
        return CryptoJS.mode.CTRGladman;
      });
    }
  });

  // node_modules/crypto-js/mode-ofb.js
  var require_mode_ofb = __commonJS({
    "node_modules/crypto-js/mode-ofb.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.mode.OFB = function() {
          var OFB = CryptoJS.lib.BlockCipherMode.extend();
          var Encryptor = OFB.Encryptor = OFB.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var iv = this._iv;
              var keystream = this._keystream;
              if (iv) {
                keystream = this._keystream = iv.slice(0);
                this._iv = void 0;
              }
              cipher.encryptBlock(keystream, 0);
              for (var i4 = 0; i4 < blockSize; i4++) {
                words[offset + i4] ^= keystream[i4];
              }
            }
          });
          OFB.Decryptor = Encryptor;
          return OFB;
        }();
        return CryptoJS.mode.OFB;
      });
    }
  });

  // node_modules/crypto-js/mode-ecb.js
  var require_mode_ecb = __commonJS({
    "node_modules/crypto-js/mode-ecb.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.mode.ECB = function() {
          var ECB = CryptoJS.lib.BlockCipherMode.extend();
          ECB.Encryptor = ECB.extend({
            processBlock: function(words, offset) {
              this._cipher.encryptBlock(words, offset);
            }
          });
          ECB.Decryptor = ECB.extend({
            processBlock: function(words, offset) {
              this._cipher.decryptBlock(words, offset);
            }
          });
          return ECB;
        }();
        return CryptoJS.mode.ECB;
      });
    }
  });

  // node_modules/crypto-js/pad-ansix923.js
  var require_pad_ansix923 = __commonJS({
    "node_modules/crypto-js/pad-ansix923.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.pad.AnsiX923 = {
          pad: function(data, blockSize) {
            var dataSigBytes = data.sigBytes;
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
            var lastBytePos = dataSigBytes + nPaddingBytes - 1;
            data.clamp();
            data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
            data.sigBytes += nPaddingBytes;
          },
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        return CryptoJS.pad.Ansix923;
      });
    }
  });

  // node_modules/crypto-js/pad-iso10126.js
  var require_pad_iso10126 = __commonJS({
    "node_modules/crypto-js/pad-iso10126.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.pad.Iso10126 = {
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
          },
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        return CryptoJS.pad.Iso10126;
      });
    }
  });

  // node_modules/crypto-js/pad-iso97971.js
  var require_pad_iso97971 = __commonJS({
    "node_modules/crypto-js/pad-iso97971.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.pad.Iso97971 = {
          pad: function(data, blockSize) {
            data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
            CryptoJS.pad.ZeroPadding.pad(data, blockSize);
          },
          unpad: function(data) {
            CryptoJS.pad.ZeroPadding.unpad(data);
            data.sigBytes--;
          }
        };
        return CryptoJS.pad.Iso97971;
      });
    }
  });

  // node_modules/crypto-js/pad-zeropadding.js
  var require_pad_zeropadding = __commonJS({
    "node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.pad.ZeroPadding = {
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            data.clamp();
            data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
          },
          unpad: function(data) {
            var dataWords = data.words;
            var i4 = data.sigBytes - 1;
            for (var i4 = data.sigBytes - 1; i4 >= 0; i4--) {
              if (dataWords[i4 >>> 2] >>> 24 - i4 % 4 * 8 & 255) {
                data.sigBytes = i4 + 1;
                break;
              }
            }
          }
        };
        return CryptoJS.pad.ZeroPadding;
      });
    }
  });

  // node_modules/crypto-js/pad-nopadding.js
  var require_pad_nopadding = __commonJS({
    "node_modules/crypto-js/pad-nopadding.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        CryptoJS.pad.NoPadding = {
          pad: function() {
          },
          unpad: function() {
          }
        };
        return CryptoJS.pad.NoPadding;
      });
    }
  });

  // node_modules/crypto-js/format-hex.js
  var require_format_hex = __commonJS({
    "node_modules/crypto-js/format-hex.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function(undefined2) {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var CipherParams = C_lib.CipherParams;
          var C_enc = C3.enc;
          var Hex = C_enc.Hex;
          var C_format = C3.format;
          var HexFormatter = C_format.Hex = {
            /**
             * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
             *
             * @param {CipherParams} cipherParams The cipher params object.
             *
             * @return {string} The hexadecimally encoded string.
             *
             * @static
             *
             * @example
             *
             *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
             */
            stringify: function(cipherParams) {
              return cipherParams.ciphertext.toString(Hex);
            },
            /**
             * Converts a hexadecimally encoded ciphertext string to a cipher params object.
             *
             * @param {string} input The hexadecimally encoded string.
             *
             * @return {CipherParams} The cipher params object.
             *
             * @static
             *
             * @example
             *
             *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
             */
            parse: function(input) {
              var ciphertext = Hex.parse(input);
              return CipherParams.create({ ciphertext });
            }
          };
        })();
        return CryptoJS.format.Hex;
      });
    }
  });

  // node_modules/crypto-js/aes.js
  var require_aes = __commonJS({
    "node_modules/crypto-js/aes.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var BlockCipher = C_lib.BlockCipher;
          var C_algo = C3.algo;
          var SBOX = [];
          var INV_SBOX = [];
          var SUB_MIX_0 = [];
          var SUB_MIX_1 = [];
          var SUB_MIX_2 = [];
          var SUB_MIX_3 = [];
          var INV_SUB_MIX_0 = [];
          var INV_SUB_MIX_1 = [];
          var INV_SUB_MIX_2 = [];
          var INV_SUB_MIX_3 = [];
          (function() {
            var d4 = [];
            for (var i4 = 0; i4 < 256; i4++) {
              if (i4 < 128) {
                d4[i4] = i4 << 1;
              } else {
                d4[i4] = i4 << 1 ^ 283;
              }
            }
            var x4 = 0;
            var xi = 0;
            for (var i4 = 0; i4 < 256; i4++) {
              var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
              sx = sx >>> 8 ^ sx & 255 ^ 99;
              SBOX[x4] = sx;
              INV_SBOX[sx] = x4;
              var x22 = d4[x4];
              var x42 = d4[x22];
              var x8 = d4[x42];
              var t5 = d4[sx] * 257 ^ sx * 16843008;
              SUB_MIX_0[x4] = t5 << 24 | t5 >>> 8;
              SUB_MIX_1[x4] = t5 << 16 | t5 >>> 16;
              SUB_MIX_2[x4] = t5 << 8 | t5 >>> 24;
              SUB_MIX_3[x4] = t5;
              var t5 = x8 * 16843009 ^ x42 * 65537 ^ x22 * 257 ^ x4 * 16843008;
              INV_SUB_MIX_0[sx] = t5 << 24 | t5 >>> 8;
              INV_SUB_MIX_1[sx] = t5 << 16 | t5 >>> 16;
              INV_SUB_MIX_2[sx] = t5 << 8 | t5 >>> 24;
              INV_SUB_MIX_3[sx] = t5;
              if (!x4) {
                x4 = xi = 1;
              } else {
                x4 = x22 ^ d4[d4[d4[x8 ^ x22]]];
                xi ^= d4[d4[xi]];
              }
            }
          })();
          var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
          var AES = C_algo.AES = BlockCipher.extend({
            _doReset: function() {
              var t5;
              if (this._nRounds && this._keyPriorReset === this._key) {
                return;
              }
              var key = this._keyPriorReset = this._key;
              var keyWords = key.words;
              var keySize = key.sigBytes / 4;
              var nRounds = this._nRounds = keySize + 6;
              var ksRows = (nRounds + 1) * 4;
              var keySchedule = this._keySchedule = [];
              for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                if (ksRow < keySize) {
                  keySchedule[ksRow] = keyWords[ksRow];
                } else {
                  t5 = keySchedule[ksRow - 1];
                  if (!(ksRow % keySize)) {
                    t5 = t5 << 8 | t5 >>> 24;
                    t5 = SBOX[t5 >>> 24] << 24 | SBOX[t5 >>> 16 & 255] << 16 | SBOX[t5 >>> 8 & 255] << 8 | SBOX[t5 & 255];
                    t5 ^= RCON[ksRow / keySize | 0] << 24;
                  } else if (keySize > 6 && ksRow % keySize == 4) {
                    t5 = SBOX[t5 >>> 24] << 24 | SBOX[t5 >>> 16 & 255] << 16 | SBOX[t5 >>> 8 & 255] << 8 | SBOX[t5 & 255];
                  }
                  keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t5;
                }
              }
              var invKeySchedule = this._invKeySchedule = [];
              for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                var ksRow = ksRows - invKsRow;
                if (invKsRow % 4) {
                  var t5 = keySchedule[ksRow];
                } else {
                  var t5 = keySchedule[ksRow - 4];
                }
                if (invKsRow < 4 || ksRow <= 4) {
                  invKeySchedule[invKsRow] = t5;
                } else {
                  invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t5 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t5 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t5 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t5 & 255]];
                }
              }
            },
            encryptBlock: function(M3, offset) {
              this._doCryptBlock(M3, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
            },
            decryptBlock: function(M3, offset) {
              var t5 = M3[offset + 1];
              M3[offset + 1] = M3[offset + 3];
              M3[offset + 3] = t5;
              this._doCryptBlock(M3, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
              var t5 = M3[offset + 1];
              M3[offset + 1] = M3[offset + 3];
              M3[offset + 3] = t5;
            },
            _doCryptBlock: function(M3, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
              var nRounds = this._nRounds;
              var s0 = M3[offset] ^ keySchedule[0];
              var s1 = M3[offset + 1] ^ keySchedule[1];
              var s22 = M3[offset + 2] ^ keySchedule[2];
              var s32 = M3[offset + 3] ^ keySchedule[3];
              var ksRow = 4;
              for (var round = 1; round < nRounds; round++) {
                var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s22 >>> 8 & 255] ^ SUB_MIX_32[s32 & 255] ^ keySchedule[ksRow++];
                var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s22 >>> 16 & 255] ^ SUB_MIX_22[s32 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
                var t22 = SUB_MIX_02[s22 >>> 24] ^ SUB_MIX_12[s32 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
                var t32 = SUB_MIX_02[s32 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s22 & 255] ^ keySchedule[ksRow++];
                s0 = t0;
                s1 = t1;
                s22 = t22;
                s32 = t32;
              }
              var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s22 >>> 8 & 255] << 8 | SBOX2[s32 & 255]) ^ keySchedule[ksRow++];
              var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s22 >>> 16 & 255] << 16 | SBOX2[s32 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
              var t22 = (SBOX2[s22 >>> 24] << 24 | SBOX2[s32 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
              var t32 = (SBOX2[s32 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s22 & 255]) ^ keySchedule[ksRow++];
              M3[offset] = t0;
              M3[offset + 1] = t1;
              M3[offset + 2] = t22;
              M3[offset + 3] = t32;
            },
            keySize: 256 / 32
          });
          C3.AES = BlockCipher._createHelper(AES);
        })();
        return CryptoJS.AES;
      });
    }
  });

  // node_modules/crypto-js/tripledes.js
  var require_tripledes = __commonJS({
    "node_modules/crypto-js/tripledes.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var WordArray = C_lib.WordArray;
          var BlockCipher = C_lib.BlockCipher;
          var C_algo = C3.algo;
          var PC1 = [
            57,
            49,
            41,
            33,
            25,
            17,
            9,
            1,
            58,
            50,
            42,
            34,
            26,
            18,
            10,
            2,
            59,
            51,
            43,
            35,
            27,
            19,
            11,
            3,
            60,
            52,
            44,
            36,
            63,
            55,
            47,
            39,
            31,
            23,
            15,
            7,
            62,
            54,
            46,
            38,
            30,
            22,
            14,
            6,
            61,
            53,
            45,
            37,
            29,
            21,
            13,
            5,
            28,
            20,
            12,
            4
          ];
          var PC2 = [
            14,
            17,
            11,
            24,
            1,
            5,
            3,
            28,
            15,
            6,
            21,
            10,
            23,
            19,
            12,
            4,
            26,
            8,
            16,
            7,
            27,
            20,
            13,
            2,
            41,
            52,
            31,
            37,
            47,
            55,
            30,
            40,
            51,
            45,
            33,
            48,
            44,
            49,
            39,
            56,
            34,
            53,
            46,
            42,
            50,
            36,
            29,
            32
          ];
          var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
          var SBOX_P = [
            {
              0: 8421888,
              268435456: 32768,
              536870912: 8421378,
              805306368: 2,
              1073741824: 512,
              1342177280: 8421890,
              1610612736: 8389122,
              1879048192: 8388608,
              2147483648: 514,
              2415919104: 8389120,
              2684354560: 33280,
              2952790016: 8421376,
              3221225472: 32770,
              3489660928: 8388610,
              3758096384: 0,
              4026531840: 33282,
              134217728: 0,
              402653184: 8421890,
              671088640: 33282,
              939524096: 32768,
              1207959552: 8421888,
              1476395008: 512,
              1744830464: 8421378,
              2013265920: 2,
              2281701376: 8389120,
              2550136832: 33280,
              2818572288: 8421376,
              3087007744: 8389122,
              3355443200: 8388610,
              3623878656: 32770,
              3892314112: 514,
              4160749568: 8388608,
              1: 32768,
              268435457: 2,
              536870913: 8421888,
              805306369: 8388608,
              1073741825: 8421378,
              1342177281: 33280,
              1610612737: 512,
              1879048193: 8389122,
              2147483649: 8421890,
              2415919105: 8421376,
              2684354561: 8388610,
              2952790017: 33282,
              3221225473: 514,
              3489660929: 8389120,
              3758096385: 32770,
              4026531841: 0,
              134217729: 8421890,
              402653185: 8421376,
              671088641: 8388608,
              939524097: 512,
              1207959553: 32768,
              1476395009: 8388610,
              1744830465: 2,
              2013265921: 33282,
              2281701377: 32770,
              2550136833: 8389122,
              2818572289: 514,
              3087007745: 8421888,
              3355443201: 8389120,
              3623878657: 0,
              3892314113: 33280,
              4160749569: 8421378
            },
            {
              0: 1074282512,
              16777216: 16384,
              33554432: 524288,
              50331648: 1074266128,
              67108864: 1073741840,
              83886080: 1074282496,
              100663296: 1073758208,
              117440512: 16,
              134217728: 540672,
              150994944: 1073758224,
              167772160: 1073741824,
              184549376: 540688,
              201326592: 524304,
              218103808: 0,
              234881024: 16400,
              251658240: 1074266112,
              8388608: 1073758208,
              25165824: 540688,
              41943040: 16,
              58720256: 1073758224,
              75497472: 1074282512,
              92274688: 1073741824,
              109051904: 524288,
              125829120: 1074266128,
              142606336: 524304,
              159383552: 0,
              176160768: 16384,
              192937984: 1074266112,
              209715200: 1073741840,
              226492416: 540672,
              243269632: 1074282496,
              260046848: 16400,
              268435456: 0,
              285212672: 1074266128,
              301989888: 1073758224,
              318767104: 1074282496,
              335544320: 1074266112,
              352321536: 16,
              369098752: 540688,
              385875968: 16384,
              402653184: 16400,
              419430400: 524288,
              436207616: 524304,
              452984832: 1073741840,
              469762048: 540672,
              486539264: 1073758208,
              503316480: 1073741824,
              520093696: 1074282512,
              276824064: 540688,
              293601280: 524288,
              310378496: 1074266112,
              327155712: 16384,
              343932928: 1073758208,
              360710144: 1074282512,
              377487360: 16,
              394264576: 1073741824,
              411041792: 1074282496,
              427819008: 1073741840,
              444596224: 1073758224,
              461373440: 524304,
              478150656: 0,
              494927872: 16400,
              511705088: 1074266128,
              528482304: 540672
            },
            {
              0: 260,
              1048576: 0,
              2097152: 67109120,
              3145728: 65796,
              4194304: 65540,
              5242880: 67108868,
              6291456: 67174660,
              7340032: 67174400,
              8388608: 67108864,
              9437184: 67174656,
              10485760: 65792,
              11534336: 67174404,
              12582912: 67109124,
              13631488: 65536,
              14680064: 4,
              15728640: 256,
              524288: 67174656,
              1572864: 67174404,
              2621440: 0,
              3670016: 67109120,
              4718592: 67108868,
              5767168: 65536,
              6815744: 65540,
              7864320: 260,
              8912896: 4,
              9961472: 256,
              11010048: 67174400,
              12058624: 65796,
              13107200: 65792,
              14155776: 67109124,
              15204352: 67174660,
              16252928: 67108864,
              16777216: 67174656,
              17825792: 65540,
              18874368: 65536,
              19922944: 67109120,
              20971520: 256,
              22020096: 67174660,
              23068672: 67108868,
              24117248: 0,
              25165824: 67109124,
              26214400: 67108864,
              27262976: 4,
              28311552: 65792,
              29360128: 67174400,
              30408704: 260,
              31457280: 65796,
              32505856: 67174404,
              17301504: 67108864,
              18350080: 260,
              19398656: 67174656,
              20447232: 0,
              21495808: 65540,
              22544384: 67109120,
              23592960: 256,
              24641536: 67174404,
              25690112: 65536,
              26738688: 67174660,
              27787264: 65796,
              28835840: 67108868,
              29884416: 67109124,
              30932992: 67174400,
              31981568: 4,
              33030144: 65792
            },
            {
              0: 2151682048,
              65536: 2147487808,
              131072: 4198464,
              196608: 2151677952,
              262144: 0,
              327680: 4198400,
              393216: 2147483712,
              458752: 4194368,
              524288: 2147483648,
              589824: 4194304,
              655360: 64,
              720896: 2147487744,
              786432: 2151678016,
              851968: 4160,
              917504: 4096,
              983040: 2151682112,
              32768: 2147487808,
              98304: 64,
              163840: 2151678016,
              229376: 2147487744,
              294912: 4198400,
              360448: 2151682112,
              425984: 0,
              491520: 2151677952,
              557056: 4096,
              622592: 2151682048,
              688128: 4194304,
              753664: 4160,
              819200: 2147483648,
              884736: 4194368,
              950272: 4198464,
              1015808: 2147483712,
              1048576: 4194368,
              1114112: 4198400,
              1179648: 2147483712,
              1245184: 0,
              1310720: 4160,
              1376256: 2151678016,
              1441792: 2151682048,
              1507328: 2147487808,
              1572864: 2151682112,
              1638400: 2147483648,
              1703936: 2151677952,
              1769472: 4198464,
              1835008: 2147487744,
              1900544: 4194304,
              1966080: 64,
              2031616: 4096,
              1081344: 2151677952,
              1146880: 2151682112,
              1212416: 0,
              1277952: 4198400,
              1343488: 4194368,
              1409024: 2147483648,
              1474560: 2147487808,
              1540096: 64,
              1605632: 2147483712,
              1671168: 4096,
              1736704: 2147487744,
              1802240: 2151678016,
              1867776: 4160,
              1933312: 2151682048,
              1998848: 4194304,
              2064384: 4198464
            },
            {
              0: 128,
              4096: 17039360,
              8192: 262144,
              12288: 536870912,
              16384: 537133184,
              20480: 16777344,
              24576: 553648256,
              28672: 262272,
              32768: 16777216,
              36864: 537133056,
              40960: 536871040,
              45056: 553910400,
              49152: 553910272,
              53248: 0,
              57344: 17039488,
              61440: 553648128,
              2048: 17039488,
              6144: 553648256,
              10240: 128,
              14336: 17039360,
              18432: 262144,
              22528: 537133184,
              26624: 553910272,
              30720: 536870912,
              34816: 537133056,
              38912: 0,
              43008: 553910400,
              47104: 16777344,
              51200: 536871040,
              55296: 553648128,
              59392: 16777216,
              63488: 262272,
              65536: 262144,
              69632: 128,
              73728: 536870912,
              77824: 553648256,
              81920: 16777344,
              86016: 553910272,
              90112: 537133184,
              94208: 16777216,
              98304: 553910400,
              102400: 553648128,
              106496: 17039360,
              110592: 537133056,
              114688: 262272,
              118784: 536871040,
              122880: 0,
              126976: 17039488,
              67584: 553648256,
              71680: 16777216,
              75776: 17039360,
              79872: 537133184,
              83968: 536870912,
              88064: 17039488,
              92160: 128,
              96256: 553910272,
              100352: 262272,
              104448: 553910400,
              108544: 0,
              112640: 553648128,
              116736: 16777344,
              120832: 262144,
              124928: 537133056,
              129024: 536871040
            },
            {
              0: 268435464,
              256: 8192,
              512: 270532608,
              768: 270540808,
              1024: 268443648,
              1280: 2097152,
              1536: 2097160,
              1792: 268435456,
              2048: 0,
              2304: 268443656,
              2560: 2105344,
              2816: 8,
              3072: 270532616,
              3328: 2105352,
              3584: 8200,
              3840: 270540800,
              128: 270532608,
              384: 270540808,
              640: 8,
              896: 2097152,
              1152: 2105352,
              1408: 268435464,
              1664: 268443648,
              1920: 8200,
              2176: 2097160,
              2432: 8192,
              2688: 268443656,
              2944: 270532616,
              3200: 0,
              3456: 270540800,
              3712: 2105344,
              3968: 268435456,
              4096: 268443648,
              4352: 270532616,
              4608: 270540808,
              4864: 8200,
              5120: 2097152,
              5376: 268435456,
              5632: 268435464,
              5888: 2105344,
              6144: 2105352,
              6400: 0,
              6656: 8,
              6912: 270532608,
              7168: 8192,
              7424: 268443656,
              7680: 270540800,
              7936: 2097160,
              4224: 8,
              4480: 2105344,
              4736: 2097152,
              4992: 268435464,
              5248: 268443648,
              5504: 8200,
              5760: 270540808,
              6016: 270532608,
              6272: 270540800,
              6528: 270532616,
              6784: 8192,
              7040: 2105352,
              7296: 2097160,
              7552: 0,
              7808: 268435456,
              8064: 268443656
            },
            {
              0: 1048576,
              16: 33555457,
              32: 1024,
              48: 1049601,
              64: 34604033,
              80: 0,
              96: 1,
              112: 34603009,
              128: 33555456,
              144: 1048577,
              160: 33554433,
              176: 34604032,
              192: 34603008,
              208: 1025,
              224: 1049600,
              240: 33554432,
              8: 34603009,
              24: 0,
              40: 33555457,
              56: 34604032,
              72: 1048576,
              88: 33554433,
              104: 33554432,
              120: 1025,
              136: 1049601,
              152: 33555456,
              168: 34603008,
              184: 1048577,
              200: 1024,
              216: 34604033,
              232: 1,
              248: 1049600,
              256: 33554432,
              272: 1048576,
              288: 33555457,
              304: 34603009,
              320: 1048577,
              336: 33555456,
              352: 34604032,
              368: 1049601,
              384: 1025,
              400: 34604033,
              416: 1049600,
              432: 1,
              448: 0,
              464: 34603008,
              480: 33554433,
              496: 1024,
              264: 1049600,
              280: 33555457,
              296: 34603009,
              312: 1,
              328: 33554432,
              344: 1048576,
              360: 1025,
              376: 34604032,
              392: 33554433,
              408: 34603008,
              424: 0,
              440: 34604033,
              456: 1049601,
              472: 1024,
              488: 33555456,
              504: 1048577
            },
            {
              0: 134219808,
              1: 131072,
              2: 134217728,
              3: 32,
              4: 131104,
              5: 134350880,
              6: 134350848,
              7: 2048,
              8: 134348800,
              9: 134219776,
              10: 133120,
              11: 134348832,
              12: 2080,
              13: 0,
              14: 134217760,
              15: 133152,
              2147483648: 2048,
              2147483649: 134350880,
              2147483650: 134219808,
              2147483651: 134217728,
              2147483652: 134348800,
              2147483653: 133120,
              2147483654: 133152,
              2147483655: 32,
              2147483656: 134217760,
              2147483657: 2080,
              2147483658: 131104,
              2147483659: 134350848,
              2147483660: 0,
              2147483661: 134348832,
              2147483662: 134219776,
              2147483663: 131072,
              16: 133152,
              17: 134350848,
              18: 32,
              19: 2048,
              20: 134219776,
              21: 134217760,
              22: 134348832,
              23: 131072,
              24: 0,
              25: 131104,
              26: 134348800,
              27: 134219808,
              28: 134350880,
              29: 133120,
              30: 2080,
              31: 134217728,
              2147483664: 131072,
              2147483665: 2048,
              2147483666: 134348832,
              2147483667: 133152,
              2147483668: 32,
              2147483669: 134348800,
              2147483670: 134217728,
              2147483671: 134219808,
              2147483672: 134350880,
              2147483673: 134217760,
              2147483674: 134219776,
              2147483675: 0,
              2147483676: 133120,
              2147483677: 2080,
              2147483678: 131104,
              2147483679: 134350848
            }
          ];
          var SBOX_MASK = [
            4160749569,
            528482304,
            33030144,
            2064384,
            129024,
            8064,
            504,
            2147483679
          ];
          var DES = C_algo.DES = BlockCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              var keyBits = [];
              for (var i4 = 0; i4 < 56; i4++) {
                var keyBitPos = PC1[i4] - 1;
                keyBits[i4] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
              }
              var subKeys = this._subKeys = [];
              for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                var subKey = subKeys[nSubKey] = [];
                var bitShift = BIT_SHIFTS[nSubKey];
                for (var i4 = 0; i4 < 24; i4++) {
                  subKey[i4 / 6 | 0] |= keyBits[(PC2[i4] - 1 + bitShift) % 28] << 31 - i4 % 6;
                  subKey[4 + (i4 / 6 | 0)] |= keyBits[28 + (PC2[i4 + 24] - 1 + bitShift) % 28] << 31 - i4 % 6;
                }
                subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
                for (var i4 = 1; i4 < 7; i4++) {
                  subKey[i4] = subKey[i4] >>> (i4 - 1) * 4 + 3;
                }
                subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
              }
              var invSubKeys = this._invSubKeys = [];
              for (var i4 = 0; i4 < 16; i4++) {
                invSubKeys[i4] = subKeys[15 - i4];
              }
            },
            encryptBlock: function(M3, offset) {
              this._doCryptBlock(M3, offset, this._subKeys);
            },
            decryptBlock: function(M3, offset) {
              this._doCryptBlock(M3, offset, this._invSubKeys);
            },
            _doCryptBlock: function(M3, offset, subKeys) {
              this._lBlock = M3[offset];
              this._rBlock = M3[offset + 1];
              exchangeLR.call(this, 4, 252645135);
              exchangeLR.call(this, 16, 65535);
              exchangeRL.call(this, 2, 858993459);
              exchangeRL.call(this, 8, 16711935);
              exchangeLR.call(this, 1, 1431655765);
              for (var round = 0; round < 16; round++) {
                var subKey = subKeys[round];
                var lBlock = this._lBlock;
                var rBlock = this._rBlock;
                var f5 = 0;
                for (var i4 = 0; i4 < 8; i4++) {
                  f5 |= SBOX_P[i4][((rBlock ^ subKey[i4]) & SBOX_MASK[i4]) >>> 0];
                }
                this._lBlock = rBlock;
                this._rBlock = lBlock ^ f5;
              }
              var t5 = this._lBlock;
              this._lBlock = this._rBlock;
              this._rBlock = t5;
              exchangeLR.call(this, 1, 1431655765);
              exchangeRL.call(this, 8, 16711935);
              exchangeRL.call(this, 2, 858993459);
              exchangeLR.call(this, 16, 65535);
              exchangeLR.call(this, 4, 252645135);
              M3[offset] = this._lBlock;
              M3[offset + 1] = this._rBlock;
            },
            keySize: 64 / 32,
            ivSize: 64 / 32,
            blockSize: 64 / 32
          });
          function exchangeLR(offset, mask) {
            var t5 = (this._lBlock >>> offset ^ this._rBlock) & mask;
            this._rBlock ^= t5;
            this._lBlock ^= t5 << offset;
          }
          function exchangeRL(offset, mask) {
            var t5 = (this._rBlock >>> offset ^ this._lBlock) & mask;
            this._lBlock ^= t5;
            this._rBlock ^= t5 << offset;
          }
          C3.DES = BlockCipher._createHelper(DES);
          var TripleDES = C_algo.TripleDES = BlockCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
                throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
              }
              var key1 = keyWords.slice(0, 2);
              var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
              var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
              this._des1 = DES.createEncryptor(WordArray.create(key1));
              this._des2 = DES.createEncryptor(WordArray.create(key2));
              this._des3 = DES.createEncryptor(WordArray.create(key3));
            },
            encryptBlock: function(M3, offset) {
              this._des1.encryptBlock(M3, offset);
              this._des2.decryptBlock(M3, offset);
              this._des3.encryptBlock(M3, offset);
            },
            decryptBlock: function(M3, offset) {
              this._des3.decryptBlock(M3, offset);
              this._des2.encryptBlock(M3, offset);
              this._des1.decryptBlock(M3, offset);
            },
            keySize: 192 / 32,
            ivSize: 64 / 32,
            blockSize: 64 / 32
          });
          C3.TripleDES = BlockCipher._createHelper(TripleDES);
        })();
        return CryptoJS.TripleDES;
      });
    }
  });

  // node_modules/crypto-js/rc4.js
  var require_rc4 = __commonJS({
    "node_modules/crypto-js/rc4.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C3.algo;
          var RC4 = C_algo.RC4 = StreamCipher.extend({
            _doReset: function() {
              var key = this._key;
              var keyWords = key.words;
              var keySigBytes = key.sigBytes;
              var S5 = this._S = [];
              for (var i4 = 0; i4 < 256; i4++) {
                S5[i4] = i4;
              }
              for (var i4 = 0, j2 = 0; i4 < 256; i4++) {
                var keyByteIndex = i4 % keySigBytes;
                var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
                j2 = (j2 + S5[i4] + keyByte) % 256;
                var t5 = S5[i4];
                S5[i4] = S5[j2];
                S5[j2] = t5;
              }
              this._i = this._j = 0;
            },
            _doProcessBlock: function(M3, offset) {
              M3[offset] ^= generateKeystreamWord.call(this);
            },
            keySize: 256 / 32,
            ivSize: 0
          });
          function generateKeystreamWord() {
            var S5 = this._S;
            var i4 = this._i;
            var j2 = this._j;
            var keystreamWord = 0;
            for (var n7 = 0; n7 < 4; n7++) {
              i4 = (i4 + 1) % 256;
              j2 = (j2 + S5[i4]) % 256;
              var t5 = S5[i4];
              S5[i4] = S5[j2];
              S5[j2] = t5;
              keystreamWord |= S5[(S5[i4] + S5[j2]) % 256] << 24 - n7 * 8;
            }
            this._i = i4;
            this._j = j2;
            return keystreamWord;
          }
          C3.RC4 = StreamCipher._createHelper(RC4);
          var RC4Drop = C_algo.RC4Drop = RC4.extend({
            /**
             * Configuration options.
             *
             * @property {number} drop The number of keystream words to drop. Default 192
             */
            cfg: RC4.cfg.extend({
              drop: 192
            }),
            _doReset: function() {
              RC4._doReset.call(this);
              for (var i4 = this.cfg.drop; i4 > 0; i4--) {
                generateKeystreamWord.call(this);
              }
            }
          });
          C3.RC4Drop = StreamCipher._createHelper(RC4Drop);
        })();
        return CryptoJS.RC4;
      });
    }
  });

  // node_modules/crypto-js/rabbit.js
  var require_rabbit = __commonJS({
    "node_modules/crypto-js/rabbit.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C3.algo;
          var S5 = [];
          var C_ = [];
          var G2 = [];
          var Rabbit = C_algo.Rabbit = StreamCipher.extend({
            _doReset: function() {
              var K2 = this._key.words;
              var iv = this.cfg.iv;
              for (var i4 = 0; i4 < 4; i4++) {
                K2[i4] = (K2[i4] << 8 | K2[i4] >>> 24) & 16711935 | (K2[i4] << 24 | K2[i4] >>> 8) & 4278255360;
              }
              var X2 = this._X = [
                K2[0],
                K2[3] << 16 | K2[2] >>> 16,
                K2[1],
                K2[0] << 16 | K2[3] >>> 16,
                K2[2],
                K2[1] << 16 | K2[0] >>> 16,
                K2[3],
                K2[2] << 16 | K2[1] >>> 16
              ];
              var C4 = this._C = [
                K2[2] << 16 | K2[2] >>> 16,
                K2[0] & 4294901760 | K2[1] & 65535,
                K2[3] << 16 | K2[3] >>> 16,
                K2[1] & 4294901760 | K2[2] & 65535,
                K2[0] << 16 | K2[0] >>> 16,
                K2[2] & 4294901760 | K2[3] & 65535,
                K2[1] << 16 | K2[1] >>> 16,
                K2[3] & 4294901760 | K2[0] & 65535
              ];
              this._b = 0;
              for (var i4 = 0; i4 < 4; i4++) {
                nextState.call(this);
              }
              for (var i4 = 0; i4 < 8; i4++) {
                C4[i4] ^= X2[i4 + 4 & 7];
              }
              if (iv) {
                var IV2 = iv.words;
                var IV_0 = IV2[0];
                var IV_1 = IV2[1];
                var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                var i1 = i0 >>> 16 | i22 & 4294901760;
                var i32 = i22 << 16 | i0 & 65535;
                C4[0] ^= i0;
                C4[1] ^= i1;
                C4[2] ^= i22;
                C4[3] ^= i32;
                C4[4] ^= i0;
                C4[5] ^= i1;
                C4[6] ^= i22;
                C4[7] ^= i32;
                for (var i4 = 0; i4 < 4; i4++) {
                  nextState.call(this);
                }
              }
            },
            _doProcessBlock: function(M3, offset) {
              var X2 = this._X;
              nextState.call(this);
              S5[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
              S5[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
              S5[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
              S5[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
              for (var i4 = 0; i4 < 4; i4++) {
                S5[i4] = (S5[i4] << 8 | S5[i4] >>> 24) & 16711935 | (S5[i4] << 24 | S5[i4] >>> 8) & 4278255360;
                M3[offset + i4] ^= S5[i4];
              }
            },
            blockSize: 128 / 32,
            ivSize: 64 / 32
          });
          function nextState() {
            var X2 = this._X;
            var C4 = this._C;
            for (var i4 = 0; i4 < 8; i4++) {
              C_[i4] = C4[i4];
            }
            C4[0] = C4[0] + 1295307597 + this._b | 0;
            C4[1] = C4[1] + 3545052371 + (C4[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
            C4[2] = C4[2] + 886263092 + (C4[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
            C4[3] = C4[3] + 1295307597 + (C4[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
            C4[4] = C4[4] + 3545052371 + (C4[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
            C4[5] = C4[5] + 886263092 + (C4[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
            C4[6] = C4[6] + 1295307597 + (C4[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
            C4[7] = C4[7] + 3545052371 + (C4[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
            this._b = C4[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
            for (var i4 = 0; i4 < 8; i4++) {
              var gx = X2[i4] + C4[i4];
              var ga = gx & 65535;
              var gb = gx >>> 16;
              var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
              var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
              G2[i4] = gh ^ gl;
            }
            X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
            X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
            X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
            X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
            X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
            X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
            X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
            X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
          }
          C3.Rabbit = StreamCipher._createHelper(Rabbit);
        })();
        return CryptoJS.Rabbit;
      });
    }
  });

  // node_modules/crypto-js/rabbit-legacy.js
  var require_rabbit_legacy = __commonJS({
    "node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_enc_base64(), require_md5(), require_evpkdf(), require_cipher_core());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
        } else {
          factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        (function() {
          var C3 = CryptoJS;
          var C_lib = C3.lib;
          var StreamCipher = C_lib.StreamCipher;
          var C_algo = C3.algo;
          var S5 = [];
          var C_ = [];
          var G2 = [];
          var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
            _doReset: function() {
              var K2 = this._key.words;
              var iv = this.cfg.iv;
              var X2 = this._X = [
                K2[0],
                K2[3] << 16 | K2[2] >>> 16,
                K2[1],
                K2[0] << 16 | K2[3] >>> 16,
                K2[2],
                K2[1] << 16 | K2[0] >>> 16,
                K2[3],
                K2[2] << 16 | K2[1] >>> 16
              ];
              var C4 = this._C = [
                K2[2] << 16 | K2[2] >>> 16,
                K2[0] & 4294901760 | K2[1] & 65535,
                K2[3] << 16 | K2[3] >>> 16,
                K2[1] & 4294901760 | K2[2] & 65535,
                K2[0] << 16 | K2[0] >>> 16,
                K2[2] & 4294901760 | K2[3] & 65535,
                K2[1] << 16 | K2[1] >>> 16,
                K2[3] & 4294901760 | K2[0] & 65535
              ];
              this._b = 0;
              for (var i4 = 0; i4 < 4; i4++) {
                nextState.call(this);
              }
              for (var i4 = 0; i4 < 8; i4++) {
                C4[i4] ^= X2[i4 + 4 & 7];
              }
              if (iv) {
                var IV2 = iv.words;
                var IV_0 = IV2[0];
                var IV_1 = IV2[1];
                var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
                var i22 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
                var i1 = i0 >>> 16 | i22 & 4294901760;
                var i32 = i22 << 16 | i0 & 65535;
                C4[0] ^= i0;
                C4[1] ^= i1;
                C4[2] ^= i22;
                C4[3] ^= i32;
                C4[4] ^= i0;
                C4[5] ^= i1;
                C4[6] ^= i22;
                C4[7] ^= i32;
                for (var i4 = 0; i4 < 4; i4++) {
                  nextState.call(this);
                }
              }
            },
            _doProcessBlock: function(M3, offset) {
              var X2 = this._X;
              nextState.call(this);
              S5[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
              S5[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
              S5[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
              S5[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
              for (var i4 = 0; i4 < 4; i4++) {
                S5[i4] = (S5[i4] << 8 | S5[i4] >>> 24) & 16711935 | (S5[i4] << 24 | S5[i4] >>> 8) & 4278255360;
                M3[offset + i4] ^= S5[i4];
              }
            },
            blockSize: 128 / 32,
            ivSize: 64 / 32
          });
          function nextState() {
            var X2 = this._X;
            var C4 = this._C;
            for (var i4 = 0; i4 < 8; i4++) {
              C_[i4] = C4[i4];
            }
            C4[0] = C4[0] + 1295307597 + this._b | 0;
            C4[1] = C4[1] + 3545052371 + (C4[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
            C4[2] = C4[2] + 886263092 + (C4[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
            C4[3] = C4[3] + 1295307597 + (C4[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
            C4[4] = C4[4] + 3545052371 + (C4[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
            C4[5] = C4[5] + 886263092 + (C4[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
            C4[6] = C4[6] + 1295307597 + (C4[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
            C4[7] = C4[7] + 3545052371 + (C4[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
            this._b = C4[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
            for (var i4 = 0; i4 < 8; i4++) {
              var gx = X2[i4] + C4[i4];
              var ga = gx & 65535;
              var gb = gx >>> 16;
              var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
              var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
              G2[i4] = gh ^ gl;
            }
            X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
            X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
            X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
            X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
            X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
            X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
            X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
            X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
          }
          C3.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
        })();
        return CryptoJS.RabbitLegacy;
      });
    }
  });

  // node_modules/crypto-js/index.js
  var require_crypto_js = __commonJS({
    "node_modules/crypto-js/index.js"(exports, module) {
      (function(root, factory, undef) {
        if (typeof exports === "object") {
          module.exports = exports = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_enc_base64url(), require_md5(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha3(), require_ripemd160(), require_hmac(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy());
        } else if (typeof define === "function" && define.amd) {
          define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy"], factory);
        } else {
          root.CryptoJS = factory(root.CryptoJS);
        }
      })(exports, function(CryptoJS) {
        return CryptoJS;
      });
    }
  });

  // node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/events/events.js"(exports, module) {
      "use strict";
      var R4 = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R4 && typeof R4.apply === "function" ? R4.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R4 && typeof R4.ownKeys === "function") {
        ReflectOwnKeys = R4.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn)
          console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module.exports = EventEmitter;
      module.exports.once = once;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n7) {
        if (typeof n7 !== "number" || n7 < 0 || NumberIsNaN(n7)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n7 + ".");
        }
        this._maxListeners = n7;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type) {
        var args = [];
        for (var i4 = 1; i4 < arguments.length; i4++)
          args.push(arguments[i4]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i4 = 0; i4 < len; ++i4)
            ReflectApply(listeners[i4], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m3;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m3 = _getMaxListeners(target);
          if (m3 > 0 && existing.length > m3 && !existing.warned) {
            existing.warned = true;
            var w4 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w4.name = "MaxListenersExceededWarning";
            w4.emitter = target;
            w4.type = type;
            w4.count = existing.length;
            ProcessEmitWarning(w4);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i4, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i4 = list.length - 1; i4 >= 0; i4--) {
            if (list[i4] === listener || list[i4].listener === listener) {
              originalListener = list[i4].listener;
              position = i4;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i4;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i4 = 0; i4 < keys.length; ++i4) {
            key = keys[i4];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i4 = listeners.length - 1; i4 >= 0; i4--) {
            this.removeListener(type, listeners[i4]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n7) {
        var copy = new Array(n7);
        for (var i4 = 0; i4 < n7; ++i4)
          copy[i4] = arr[i4];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i4 = 0; i4 < ret.length; ++i4) {
          ret[i4] = arr[i4].listener || arr[i4];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // node_modules/@lit/reactive-element/css-tag.js
  var t = window;
  var e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
  var s = Symbol();
  var n = /* @__PURE__ */ new WeakMap();
  var o = class {
    constructor(t5, e8, n7) {
      if (this._$cssResult$ = true, n7 !== s)
        throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = t5, this.t = e8;
    }
    get styleSheet() {
      let t5 = this.o;
      const s5 = this.t;
      if (e && void 0 === t5) {
        const e8 = void 0 !== s5 && 1 === s5.length;
        e8 && (t5 = n.get(s5)), void 0 === t5 && ((this.o = t5 = new CSSStyleSheet()).replaceSync(this.cssText), e8 && n.set(s5, t5));
      }
      return t5;
    }
    toString() {
      return this.cssText;
    }
  };
  var r = (t5) => new o("string" == typeof t5 ? t5 : t5 + "", void 0, s);
  var i = (t5, ...e8) => {
    const n7 = 1 === t5.length ? t5[0] : e8.reduce((e9, s5, n8) => e9 + ((t6) => {
      if (true === t6._$cssResult$)
        return t6.cssText;
      if ("number" == typeof t6)
        return t6;
      throw Error("Value passed to 'css' function must be a 'css' function result: " + t6 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
    })(s5) + t5[n8 + 1], t5[0]);
    return new o(n7, t5, s);
  };
  var S = (s5, n7) => {
    e ? s5.adoptedStyleSheets = n7.map((t5) => t5 instanceof CSSStyleSheet ? t5 : t5.styleSheet) : n7.forEach((e8) => {
      const n8 = document.createElement("style"), o6 = t.litNonce;
      void 0 !== o6 && n8.setAttribute("nonce", o6), n8.textContent = e8.cssText, s5.appendChild(n8);
    });
  };
  var c = e ? (t5) => t5 : (t5) => t5 instanceof CSSStyleSheet ? ((t6) => {
    let e8 = "";
    for (const s5 of t6.cssRules)
      e8 += s5.cssText;
    return r(e8);
  })(t5) : t5;

  // node_modules/@lit/reactive-element/reactive-element.js
  var s2;
  var e2 = window;
  var r2 = e2.trustedTypes;
  var h = r2 ? r2.emptyScript : "";
  var o2 = e2.reactiveElementPolyfillSupport;
  var n2 = { toAttribute(t5, i4) {
    switch (i4) {
      case Boolean:
        t5 = t5 ? h : null;
        break;
      case Object:
      case Array:
        t5 = null == t5 ? t5 : JSON.stringify(t5);
    }
    return t5;
  }, fromAttribute(t5, i4) {
    let s5 = t5;
    switch (i4) {
      case Boolean:
        s5 = null !== t5;
        break;
      case Number:
        s5 = null === t5 ? null : Number(t5);
        break;
      case Object:
      case Array:
        try {
          s5 = JSON.parse(t5);
        } catch (t6) {
          s5 = null;
        }
    }
    return s5;
  } };
  var a = (t5, i4) => i4 !== t5 && (i4 == i4 || t5 == t5);
  var l = { attribute: true, type: String, converter: n2, reflect: false, hasChanged: a };
  var d = "finalized";
  var u = class extends HTMLElement {
    constructor() {
      super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$El = null, this.u();
    }
    static addInitializer(t5) {
      var i4;
      this.finalize(), (null !== (i4 = this.h) && void 0 !== i4 ? i4 : this.h = []).push(t5);
    }
    static get observedAttributes() {
      this.finalize();
      const t5 = [];
      return this.elementProperties.forEach((i4, s5) => {
        const e8 = this._$Ep(s5, i4);
        void 0 !== e8 && (this._$Ev.set(e8, s5), t5.push(e8));
      }), t5;
    }
    static createProperty(t5, i4 = l) {
      if (i4.state && (i4.attribute = false), this.finalize(), this.elementProperties.set(t5, i4), !i4.noAccessor && !this.prototype.hasOwnProperty(t5)) {
        const s5 = "symbol" == typeof t5 ? Symbol() : "__" + t5, e8 = this.getPropertyDescriptor(t5, s5, i4);
        void 0 !== e8 && Object.defineProperty(this.prototype, t5, e8);
      }
    }
    static getPropertyDescriptor(t5, i4, s5) {
      return { get() {
        return this[i4];
      }, set(e8) {
        const r4 = this[t5];
        this[i4] = e8, this.requestUpdate(t5, r4, s5);
      }, configurable: true, enumerable: true };
    }
    static getPropertyOptions(t5) {
      return this.elementProperties.get(t5) || l;
    }
    static finalize() {
      if (this.hasOwnProperty(d))
        return false;
      this[d] = true;
      const t5 = Object.getPrototypeOf(this);
      if (t5.finalize(), void 0 !== t5.h && (this.h = [...t5.h]), this.elementProperties = new Map(t5.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
        const t6 = this.properties, i4 = [...Object.getOwnPropertyNames(t6), ...Object.getOwnPropertySymbols(t6)];
        for (const s5 of i4)
          this.createProperty(s5, t6[s5]);
      }
      return this.elementStyles = this.finalizeStyles(this.styles), true;
    }
    static finalizeStyles(i4) {
      const s5 = [];
      if (Array.isArray(i4)) {
        const e8 = new Set(i4.flat(1 / 0).reverse());
        for (const i5 of e8)
          s5.unshift(c(i5));
      } else
        void 0 !== i4 && s5.push(c(i4));
      return s5;
    }
    static _$Ep(t5, i4) {
      const s5 = i4.attribute;
      return false === s5 ? void 0 : "string" == typeof s5 ? s5 : "string" == typeof t5 ? t5.toLowerCase() : void 0;
    }
    u() {
      var t5;
      this._$E_ = new Promise((t6) => this.enableUpdating = t6), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), null === (t5 = this.constructor.h) || void 0 === t5 || t5.forEach((t6) => t6(this));
    }
    addController(t5) {
      var i4, s5;
      (null !== (i4 = this._$ES) && void 0 !== i4 ? i4 : this._$ES = []).push(t5), void 0 !== this.renderRoot && this.isConnected && (null === (s5 = t5.hostConnected) || void 0 === s5 || s5.call(t5));
    }
    removeController(t5) {
      var i4;
      null === (i4 = this._$ES) || void 0 === i4 || i4.splice(this._$ES.indexOf(t5) >>> 0, 1);
    }
    _$Eg() {
      this.constructor.elementProperties.forEach((t5, i4) => {
        this.hasOwnProperty(i4) && (this._$Ei.set(i4, this[i4]), delete this[i4]);
      });
    }
    createRenderRoot() {
      var t5;
      const s5 = null !== (t5 = this.shadowRoot) && void 0 !== t5 ? t5 : this.attachShadow(this.constructor.shadowRootOptions);
      return S(s5, this.constructor.elementStyles), s5;
    }
    connectedCallback() {
      var t5;
      void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), null === (t5 = this._$ES) || void 0 === t5 || t5.forEach((t6) => {
        var i4;
        return null === (i4 = t6.hostConnected) || void 0 === i4 ? void 0 : i4.call(t6);
      });
    }
    enableUpdating(t5) {
    }
    disconnectedCallback() {
      var t5;
      null === (t5 = this._$ES) || void 0 === t5 || t5.forEach((t6) => {
        var i4;
        return null === (i4 = t6.hostDisconnected) || void 0 === i4 ? void 0 : i4.call(t6);
      });
    }
    attributeChangedCallback(t5, i4, s5) {
      this._$AK(t5, s5);
    }
    _$EO(t5, i4, s5 = l) {
      var e8;
      const r4 = this.constructor._$Ep(t5, s5);
      if (void 0 !== r4 && true === s5.reflect) {
        const h5 = (void 0 !== (null === (e8 = s5.converter) || void 0 === e8 ? void 0 : e8.toAttribute) ? s5.converter : n2).toAttribute(i4, s5.type);
        this._$El = t5, null == h5 ? this.removeAttribute(r4) : this.setAttribute(r4, h5), this._$El = null;
      }
    }
    _$AK(t5, i4) {
      var s5;
      const e8 = this.constructor, r4 = e8._$Ev.get(t5);
      if (void 0 !== r4 && this._$El !== r4) {
        const t6 = e8.getPropertyOptions(r4), h5 = "function" == typeof t6.converter ? { fromAttribute: t6.converter } : void 0 !== (null === (s5 = t6.converter) || void 0 === s5 ? void 0 : s5.fromAttribute) ? t6.converter : n2;
        this._$El = r4, this[r4] = h5.fromAttribute(i4, t6.type), this._$El = null;
      }
    }
    requestUpdate(t5, i4, s5) {
      let e8 = true;
      void 0 !== t5 && (((s5 = s5 || this.constructor.getPropertyOptions(t5)).hasChanged || a)(this[t5], i4) ? (this._$AL.has(t5) || this._$AL.set(t5, i4), true === s5.reflect && this._$El !== t5 && (void 0 === this._$EC && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t5, s5))) : e8 = false), !this.isUpdatePending && e8 && (this._$E_ = this._$Ej());
    }
    async _$Ej() {
      this.isUpdatePending = true;
      try {
        await this._$E_;
      } catch (t6) {
        Promise.reject(t6);
      }
      const t5 = this.scheduleUpdate();
      return null != t5 && await t5, !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      var t5;
      if (!this.isUpdatePending)
        return;
      this.hasUpdated, this._$Ei && (this._$Ei.forEach((t6, i5) => this[i5] = t6), this._$Ei = void 0);
      let i4 = false;
      const s5 = this._$AL;
      try {
        i4 = this.shouldUpdate(s5), i4 ? (this.willUpdate(s5), null === (t5 = this._$ES) || void 0 === t5 || t5.forEach((t6) => {
          var i5;
          return null === (i5 = t6.hostUpdate) || void 0 === i5 ? void 0 : i5.call(t6);
        }), this.update(s5)) : this._$Ek();
      } catch (t6) {
        throw i4 = false, this._$Ek(), t6;
      }
      i4 && this._$AE(s5);
    }
    willUpdate(t5) {
    }
    _$AE(t5) {
      var i4;
      null === (i4 = this._$ES) || void 0 === i4 || i4.forEach((t6) => {
        var i5;
        return null === (i5 = t6.hostUpdated) || void 0 === i5 ? void 0 : i5.call(t6);
      }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t5)), this.updated(t5);
    }
    _$Ek() {
      this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$E_;
    }
    shouldUpdate(t5) {
      return true;
    }
    update(t5) {
      void 0 !== this._$EC && (this._$EC.forEach((t6, i4) => this._$EO(i4, this[i4], t6)), this._$EC = void 0), this._$Ek();
    }
    updated(t5) {
    }
    firstUpdated(t5) {
    }
  };
  u[d] = true, u.elementProperties = /* @__PURE__ */ new Map(), u.elementStyles = [], u.shadowRootOptions = { mode: "open" }, null == o2 || o2({ ReactiveElement: u }), (null !== (s2 = e2.reactiveElementVersions) && void 0 !== s2 ? s2 : e2.reactiveElementVersions = []).push("1.6.2");

  // node_modules/lit-html/lit-html.js
  var t2;
  var i2 = window;
  var s3 = i2.trustedTypes;
  var e3 = s3 ? s3.createPolicy("lit-html", { createHTML: (t5) => t5 }) : void 0;
  var o3 = "$lit$";
  var n3 = `lit$${(Math.random() + "").slice(9)}$`;
  var l2 = "?" + n3;
  var h2 = `<${l2}>`;
  var r3 = document;
  var u2 = () => r3.createComment("");
  var d2 = (t5) => null === t5 || "object" != typeof t5 && "function" != typeof t5;
  var c2 = Array.isArray;
  var v = (t5) => c2(t5) || "function" == typeof (null == t5 ? void 0 : t5[Symbol.iterator]);
  var a2 = "[ 	\n\f\r]";
  var f = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  var _ = /-->/g;
  var m = />/g;
  var p = RegExp(`>|${a2}(?:([^\\s"'>=/]+)(${a2}*=${a2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
  var g = /'/g;
  var $ = /"/g;
  var y = /^(?:script|style|textarea|title)$/i;
  var w = (t5) => (i4, ...s5) => ({ _$litType$: t5, strings: i4, values: s5 });
  var x = w(1);
  var b = w(2);
  var T = Symbol.for("lit-noChange");
  var A = Symbol.for("lit-nothing");
  var E = /* @__PURE__ */ new WeakMap();
  var C = r3.createTreeWalker(r3, 129, null, false);
  function P(t5, i4) {
    if (!Array.isArray(t5) || !t5.hasOwnProperty("raw"))
      throw Error("invalid template strings array");
    return void 0 !== e3 ? e3.createHTML(i4) : i4;
  }
  var V = (t5, i4) => {
    const s5 = t5.length - 1, e8 = [];
    let l6, r4 = 2 === i4 ? "<svg>" : "", u5 = f;
    for (let i5 = 0; i5 < s5; i5++) {
      const s6 = t5[i5];
      let d4, c4, v4 = -1, a3 = 0;
      for (; a3 < s6.length && (u5.lastIndex = a3, c4 = u5.exec(s6), null !== c4); )
        a3 = u5.lastIndex, u5 === f ? "!--" === c4[1] ? u5 = _ : void 0 !== c4[1] ? u5 = m : void 0 !== c4[2] ? (y.test(c4[2]) && (l6 = RegExp("</" + c4[2], "g")), u5 = p) : void 0 !== c4[3] && (u5 = p) : u5 === p ? ">" === c4[0] ? (u5 = null != l6 ? l6 : f, v4 = -1) : void 0 === c4[1] ? v4 = -2 : (v4 = u5.lastIndex - c4[2].length, d4 = c4[1], u5 = void 0 === c4[3] ? p : '"' === c4[3] ? $ : g) : u5 === $ || u5 === g ? u5 = p : u5 === _ || u5 === m ? u5 = f : (u5 = p, l6 = void 0);
      const w4 = u5 === p && t5[i5 + 1].startsWith("/>") ? " " : "";
      r4 += u5 === f ? s6 + h2 : v4 >= 0 ? (e8.push(d4), s6.slice(0, v4) + o3 + s6.slice(v4) + n3 + w4) : s6 + n3 + (-2 === v4 ? (e8.push(void 0), i5) : w4);
    }
    return [P(t5, r4 + (t5[s5] || "<?>") + (2 === i4 ? "</svg>" : "")), e8];
  };
  var N = class _N {
    constructor({ strings: t5, _$litType$: i4 }, e8) {
      let h5;
      this.parts = [];
      let r4 = 0, d4 = 0;
      const c4 = t5.length - 1, v4 = this.parts, [a3, f5] = V(t5, i4);
      if (this.el = _N.createElement(a3, e8), C.currentNode = this.el.content, 2 === i4) {
        const t6 = this.el.content, i5 = t6.firstChild;
        i5.remove(), t6.append(...i5.childNodes);
      }
      for (; null !== (h5 = C.nextNode()) && v4.length < c4; ) {
        if (1 === h5.nodeType) {
          if (h5.hasAttributes()) {
            const t6 = [];
            for (const i5 of h5.getAttributeNames())
              if (i5.endsWith(o3) || i5.startsWith(n3)) {
                const s5 = f5[d4++];
                if (t6.push(i5), void 0 !== s5) {
                  const t7 = h5.getAttribute(s5.toLowerCase() + o3).split(n3), i6 = /([.?@])?(.*)/.exec(s5);
                  v4.push({ type: 1, index: r4, name: i6[2], strings: t7, ctor: "." === i6[1] ? H : "?" === i6[1] ? L : "@" === i6[1] ? z : k });
                } else
                  v4.push({ type: 6, index: r4 });
              }
            for (const i5 of t6)
              h5.removeAttribute(i5);
          }
          if (y.test(h5.tagName)) {
            const t6 = h5.textContent.split(n3), i5 = t6.length - 1;
            if (i5 > 0) {
              h5.textContent = s3 ? s3.emptyScript : "";
              for (let s5 = 0; s5 < i5; s5++)
                h5.append(t6[s5], u2()), C.nextNode(), v4.push({ type: 2, index: ++r4 });
              h5.append(t6[i5], u2());
            }
          }
        } else if (8 === h5.nodeType)
          if (h5.data === l2)
            v4.push({ type: 2, index: r4 });
          else {
            let t6 = -1;
            for (; -1 !== (t6 = h5.data.indexOf(n3, t6 + 1)); )
              v4.push({ type: 7, index: r4 }), t6 += n3.length - 1;
          }
        r4++;
      }
    }
    static createElement(t5, i4) {
      const s5 = r3.createElement("template");
      return s5.innerHTML = t5, s5;
    }
  };
  function S2(t5, i4, s5 = t5, e8) {
    var o6, n7, l6, h5;
    if (i4 === T)
      return i4;
    let r4 = void 0 !== e8 ? null === (o6 = s5._$Co) || void 0 === o6 ? void 0 : o6[e8] : s5._$Cl;
    const u5 = d2(i4) ? void 0 : i4._$litDirective$;
    return (null == r4 ? void 0 : r4.constructor) !== u5 && (null === (n7 = null == r4 ? void 0 : r4._$AO) || void 0 === n7 || n7.call(r4, false), void 0 === u5 ? r4 = void 0 : (r4 = new u5(t5), r4._$AT(t5, s5, e8)), void 0 !== e8 ? (null !== (l6 = (h5 = s5)._$Co) && void 0 !== l6 ? l6 : h5._$Co = [])[e8] = r4 : s5._$Cl = r4), void 0 !== r4 && (i4 = S2(t5, r4._$AS(t5, i4.values), r4, e8)), i4;
  }
  var M = class {
    constructor(t5, i4) {
      this._$AV = [], this._$AN = void 0, this._$AD = t5, this._$AM = i4;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    u(t5) {
      var i4;
      const { el: { content: s5 }, parts: e8 } = this._$AD, o6 = (null !== (i4 = null == t5 ? void 0 : t5.creationScope) && void 0 !== i4 ? i4 : r3).importNode(s5, true);
      C.currentNode = o6;
      let n7 = C.nextNode(), l6 = 0, h5 = 0, u5 = e8[0];
      for (; void 0 !== u5; ) {
        if (l6 === u5.index) {
          let i5;
          2 === u5.type ? i5 = new R(n7, n7.nextSibling, this, t5) : 1 === u5.type ? i5 = new u5.ctor(n7, u5.name, u5.strings, this, t5) : 6 === u5.type && (i5 = new Z(n7, this, t5)), this._$AV.push(i5), u5 = e8[++h5];
        }
        l6 !== (null == u5 ? void 0 : u5.index) && (n7 = C.nextNode(), l6++);
      }
      return C.currentNode = r3, o6;
    }
    v(t5) {
      let i4 = 0;
      for (const s5 of this._$AV)
        void 0 !== s5 && (void 0 !== s5.strings ? (s5._$AI(t5, s5, i4), i4 += s5.strings.length - 2) : s5._$AI(t5[i4])), i4++;
    }
  };
  var R = class _R {
    constructor(t5, i4, s5, e8) {
      var o6;
      this.type = 2, this._$AH = A, this._$AN = void 0, this._$AA = t5, this._$AB = i4, this._$AM = s5, this.options = e8, this._$Cp = null === (o6 = null == e8 ? void 0 : e8.isConnected) || void 0 === o6 || o6;
    }
    get _$AU() {
      var t5, i4;
      return null !== (i4 = null === (t5 = this._$AM) || void 0 === t5 ? void 0 : t5._$AU) && void 0 !== i4 ? i4 : this._$Cp;
    }
    get parentNode() {
      let t5 = this._$AA.parentNode;
      const i4 = this._$AM;
      return void 0 !== i4 && 11 === (null == t5 ? void 0 : t5.nodeType) && (t5 = i4.parentNode), t5;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(t5, i4 = this) {
      t5 = S2(this, t5, i4), d2(t5) ? t5 === A || null == t5 || "" === t5 ? (this._$AH !== A && this._$AR(), this._$AH = A) : t5 !== this._$AH && t5 !== T && this._(t5) : void 0 !== t5._$litType$ ? this.g(t5) : void 0 !== t5.nodeType ? this.$(t5) : v(t5) ? this.T(t5) : this._(t5);
    }
    k(t5) {
      return this._$AA.parentNode.insertBefore(t5, this._$AB);
    }
    $(t5) {
      this._$AH !== t5 && (this._$AR(), this._$AH = this.k(t5));
    }
    _(t5) {
      this._$AH !== A && d2(this._$AH) ? this._$AA.nextSibling.data = t5 : this.$(r3.createTextNode(t5)), this._$AH = t5;
    }
    g(t5) {
      var i4;
      const { values: s5, _$litType$: e8 } = t5, o6 = "number" == typeof e8 ? this._$AC(t5) : (void 0 === e8.el && (e8.el = N.createElement(P(e8.h, e8.h[0]), this.options)), e8);
      if ((null === (i4 = this._$AH) || void 0 === i4 ? void 0 : i4._$AD) === o6)
        this._$AH.v(s5);
      else {
        const t6 = new M(o6, this), i5 = t6.u(this.options);
        t6.v(s5), this.$(i5), this._$AH = t6;
      }
    }
    _$AC(t5) {
      let i4 = E.get(t5.strings);
      return void 0 === i4 && E.set(t5.strings, i4 = new N(t5)), i4;
    }
    T(t5) {
      c2(this._$AH) || (this._$AH = [], this._$AR());
      const i4 = this._$AH;
      let s5, e8 = 0;
      for (const o6 of t5)
        e8 === i4.length ? i4.push(s5 = new _R(this.k(u2()), this.k(u2()), this, this.options)) : s5 = i4[e8], s5._$AI(o6), e8++;
      e8 < i4.length && (this._$AR(s5 && s5._$AB.nextSibling, e8), i4.length = e8);
    }
    _$AR(t5 = this._$AA.nextSibling, i4) {
      var s5;
      for (null === (s5 = this._$AP) || void 0 === s5 || s5.call(this, false, true, i4); t5 && t5 !== this._$AB; ) {
        const i5 = t5.nextSibling;
        t5.remove(), t5 = i5;
      }
    }
    setConnected(t5) {
      var i4;
      void 0 === this._$AM && (this._$Cp = t5, null === (i4 = this._$AP) || void 0 === i4 || i4.call(this, t5));
    }
  };
  var k = class {
    constructor(t5, i4, s5, e8, o6) {
      this.type = 1, this._$AH = A, this._$AN = void 0, this.element = t5, this.name = i4, this._$AM = e8, this.options = o6, s5.length > 2 || "" !== s5[0] || "" !== s5[1] ? (this._$AH = Array(s5.length - 1).fill(new String()), this.strings = s5) : this._$AH = A;
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t5, i4 = this, s5, e8) {
      const o6 = this.strings;
      let n7 = false;
      if (void 0 === o6)
        t5 = S2(this, t5, i4, 0), n7 = !d2(t5) || t5 !== this._$AH && t5 !== T, n7 && (this._$AH = t5);
      else {
        const e9 = t5;
        let l6, h5;
        for (t5 = o6[0], l6 = 0; l6 < o6.length - 1; l6++)
          h5 = S2(this, e9[s5 + l6], i4, l6), h5 === T && (h5 = this._$AH[l6]), n7 || (n7 = !d2(h5) || h5 !== this._$AH[l6]), h5 === A ? t5 = A : t5 !== A && (t5 += (null != h5 ? h5 : "") + o6[l6 + 1]), this._$AH[l6] = h5;
      }
      n7 && !e8 && this.j(t5);
    }
    j(t5) {
      t5 === A ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t5 ? t5 : "");
    }
  };
  var H = class extends k {
    constructor() {
      super(...arguments), this.type = 3;
    }
    j(t5) {
      this.element[this.name] = t5 === A ? void 0 : t5;
    }
  };
  var I = s3 ? s3.emptyScript : "";
  var L = class extends k {
    constructor() {
      super(...arguments), this.type = 4;
    }
    j(t5) {
      t5 && t5 !== A ? this.element.setAttribute(this.name, I) : this.element.removeAttribute(this.name);
    }
  };
  var z = class extends k {
    constructor(t5, i4, s5, e8, o6) {
      super(t5, i4, s5, e8, o6), this.type = 5;
    }
    _$AI(t5, i4 = this) {
      var s5;
      if ((t5 = null !== (s5 = S2(this, t5, i4, 0)) && void 0 !== s5 ? s5 : A) === T)
        return;
      const e8 = this._$AH, o6 = t5 === A && e8 !== A || t5.capture !== e8.capture || t5.once !== e8.once || t5.passive !== e8.passive, n7 = t5 !== A && (e8 === A || o6);
      o6 && this.element.removeEventListener(this.name, this, e8), n7 && this.element.addEventListener(this.name, this, t5), this._$AH = t5;
    }
    handleEvent(t5) {
      var i4, s5;
      "function" == typeof this._$AH ? this._$AH.call(null !== (s5 = null === (i4 = this.options) || void 0 === i4 ? void 0 : i4.host) && void 0 !== s5 ? s5 : this.element, t5) : this._$AH.handleEvent(t5);
    }
  };
  var Z = class {
    constructor(t5, i4, s5) {
      this.element = t5, this.type = 6, this._$AN = void 0, this._$AM = i4, this.options = s5;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t5) {
      S2(this, t5);
    }
  };
  var B = i2.litHtmlPolyfillSupport;
  null == B || B(N, R), (null !== (t2 = i2.litHtmlVersions) && void 0 !== t2 ? t2 : i2.litHtmlVersions = []).push("2.7.5");
  var D = (t5, i4, s5) => {
    var e8, o6;
    const n7 = null !== (e8 = null == s5 ? void 0 : s5.renderBefore) && void 0 !== e8 ? e8 : i4;
    let l6 = n7._$litPart$;
    if (void 0 === l6) {
      const t6 = null !== (o6 = null == s5 ? void 0 : s5.renderBefore) && void 0 !== o6 ? o6 : null;
      n7._$litPart$ = l6 = new R(i4.insertBefore(u2(), t6), t6, void 0, null != s5 ? s5 : {});
    }
    return l6._$AI(t5), l6;
  };

  // node_modules/lit-element/lit-element.js
  var l3;
  var o4;
  var s4 = class extends u {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
    }
    createRenderRoot() {
      var t5, e8;
      const i4 = super.createRenderRoot();
      return null !== (t5 = (e8 = this.renderOptions).renderBefore) && void 0 !== t5 || (e8.renderBefore = i4.firstChild), i4;
    }
    update(t5) {
      const i4 = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t5), this._$Do = D(i4, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      var t5;
      super.connectedCallback(), null === (t5 = this._$Do) || void 0 === t5 || t5.setConnected(true);
    }
    disconnectedCallback() {
      var t5;
      super.disconnectedCallback(), null === (t5 = this._$Do) || void 0 === t5 || t5.setConnected(false);
    }
    render() {
      return T;
    }
  };
  s4.finalized = true, s4._$litElement$ = true, null === (l3 = globalThis.litElementHydrateSupport) || void 0 === l3 || l3.call(globalThis, { LitElement: s4 });
  var n4 = globalThis.litElementPolyfillSupport;
  null == n4 || n4({ LitElement: s4 });
  (null !== (o4 = globalThis.litElementVersions) && void 0 !== o4 ? o4 : globalThis.litElementVersions = []).push("3.3.2");

  // node_modules/@lit/reactive-element/decorators/custom-element.js
  var e4 = (e8) => (n7) => "function" == typeof n7 ? ((e9, n8) => (customElements.define(e9, n8), n8))(e8, n7) : ((e9, n8) => {
    const { kind: t5, elements: s5 } = n8;
    return { kind: t5, elements: s5, finisher(n9) {
      customElements.define(e9, n9);
    } };
  })(e8, n7);

  // node_modules/@lit/reactive-element/decorators/property.js
  var i3 = (i4, e8) => "method" === e8.kind && e8.descriptor && !("value" in e8.descriptor) ? { ...e8, finisher(n7) {
    n7.createProperty(e8.key, i4);
  } } : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e8.key, initializer() {
    "function" == typeof e8.initializer && (this[e8.key] = e8.initializer.call(this));
  }, finisher(n7) {
    n7.createProperty(e8.key, i4);
  } };
  var e5 = (i4, e8, n7) => {
    e8.constructor.createProperty(n7, i4);
  };
  function n5(n7) {
    return (t5, o6) => void 0 !== o6 ? e5(n7, t5, o6) : i3(n7, t5);
  }

  // node_modules/@lit/reactive-element/decorators/state.js
  function t3(t5) {
    return n5({ ...t5, state: true });
  }

  // node_modules/@lit/reactive-element/decorators/query-assigned-elements.js
  var n6;
  var e6 = null != (null === (n6 = window.HTMLSlotElement) || void 0 === n6 ? void 0 : n6.prototype.assignedElements) ? (o6, n7) => o6.assignedElements(n7) : (o6, n7) => o6.assignedNodes(n7).filter((o7) => o7.nodeType === Node.ELEMENT_NODE);

  // node_modules/zustand/esm/vanilla.mjs
  var import_meta = {};
  var createStoreImpl = (createState) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const destroy = () => {
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
        );
      }
      listeners.clear();
    };
    const api = { setState, getState, subscribe, destroy };
    state = createState(setState, getState, api);
    return api;
  };
  var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

  // node_modules/@getalby/sdk/dist/index.modern.js
  var import_crypto_js = __toESM(require_crypto_js(), 1);
  var import_events = __toESM(require_events(), 1);

  // node_modules/@noble/hashes/esm/_assert.js
  function number(n7) {
    if (!Number.isSafeInteger(n7) || n7 < 0)
      throw new Error(`Wrong positive integer: ${n7}`);
  }
  function bool(b3) {
    if (typeof b3 !== "boolean")
      throw new Error(`Expected boolean, not ${b3}`);
  }
  function bytes(b3, ...lengths) {
    if (!(b3 instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b3.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b3.length}`);
  }
  function hash(hash2) {
    if (typeof hash2 !== "function" || typeof hash2.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash2.outputLen);
    number(hash2.blockLen);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  var assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output
  };
  var assert_default = assert;

  // node_modules/@noble/hashes/esm/crypto.js
  var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

  // node_modules/@noble/hashes/esm/utils.js
  var u8a = (a3) => a3 instanceof Uint8Array;
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
  var hexes = Array.from({ length: 256 }, (v4, i4) => i4.toString(16).padStart(2, "0"));
  function bytesToHex(bytes2) {
    if (!u8a(bytes2))
      throw new Error("Uint8Array expected");
    let hex2 = "";
    for (let i4 = 0; i4 < bytes2.length; i4++) {
      hex2 += hexes[bytes2[i4]];
    }
    return hex2;
  }
  function hexToBytes(hex2) {
    if (typeof hex2 !== "string")
      throw new Error("hex string expected, got " + typeof hex2);
    const len = hex2.length;
    if (len % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + len);
    const array = new Uint8Array(len / 2);
    for (let i4 = 0; i4 < array.length; i4++) {
      const j2 = i4 * 2;
      const hexByte = hex2.slice(j2, j2 + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i4] = byte;
    }
    return array;
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    if (!u8a(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  }
  function concatBytes(...arrays) {
    const r4 = new Uint8Array(arrays.reduce((sum, a3) => sum + a3.length, 0));
    let pad = 0;
    arrays.forEach((a3) => {
      if (!u8a(a3))
        throw new Error("Uint8Array expected");
      r4.set(a3, pad);
      pad += a3.length;
    });
    return r4;
  }
  var Hash = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
  function checkOpts(defaults, opts) {
    if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function randomBytes(bytesLength = 32) {
    if (crypto2 && typeof crypto2.getRandomValues === "function") {
      return crypto2.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  }

  // node_modules/@noble/hashes/esm/_sha2.js
  function setBigUint64(view, byteOffset, value, isLE2) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE2);
    const _32n2 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n2 & _u32_max);
    const wl = Number(value & _u32_max);
    const h5 = isLE2 ? 4 : 0;
    const l6 = isLE2 ? 0 : 4;
    view.setUint32(byteOffset + h5, wh, isLE2);
    view.setUint32(byteOffset + l6, wl, isLE2);
  }
  var SHA2 = class extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE2) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      assert_default.exists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      assert_default.exists(this);
      assert_default.output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i4 = pos; i4 < blockLen; i4++)
        buffer[i4] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i4 = 0; i4 < outLen; i4++)
        oview.setUint32(4 * i4, state[i4], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to2) {
      to2 || (to2 = new this.constructor());
      to2.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to2.length = length;
      to2.pos = pos;
      to2.finished = finished;
      to2.destroyed = destroyed;
      if (length % blockLen)
        to2.buffer.set(buffer);
      return to2;
    }
  };

  // node_modules/@noble/hashes/esm/sha256.js
  var Chi = (a3, b3, c4) => a3 & b3 ^ ~a3 & c4;
  var Maj = (a3, b3, c4) => a3 & b3 ^ a3 & c4 ^ b3 & c4;
  var SHA256_K = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var IV = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W = new Uint32Array(64);
  var SHA256 = class extends SHA2 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV[0] | 0;
      this.B = IV[1] | 0;
      this.C = IV[2] | 0;
      this.D = IV[3] | 0;
      this.E = IV[4] | 0;
      this.F = IV[5] | 0;
      this.G = IV[6] | 0;
      this.H = IV[7] | 0;
    }
    get() {
      const { A: A4, B: B3, C: C3, D: D3, E: E4, F: F2, G: G2, H: H3 } = this;
      return [A4, B3, C3, D3, E4, F2, G2, H3];
    }
    // prettier-ignore
    set(A4, B3, C3, D3, E4, F2, G2, H3) {
      this.A = A4 | 0;
      this.B = B3 | 0;
      this.C = C3 | 0;
      this.D = D3 | 0;
      this.E = E4 | 0;
      this.F = F2 | 0;
      this.G = G2 | 0;
      this.H = H3 | 0;
    }
    process(view, offset) {
      for (let i4 = 0; i4 < 16; i4++, offset += 4)
        SHA256_W[i4] = view.getUint32(offset, false);
      for (let i4 = 16; i4 < 64; i4++) {
        const W15 = SHA256_W[i4 - 15];
        const W2 = SHA256_W[i4 - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i4] = s1 + SHA256_W[i4 - 7] + s0 + SHA256_W[i4 - 16] | 0;
      }
      let { A: A4, B: B3, C: C3, D: D3, E: E4, F: F2, G: G2, H: H3 } = this;
      for (let i4 = 0; i4 < 64; i4++) {
        const sigma1 = rotr(E4, 6) ^ rotr(E4, 11) ^ rotr(E4, 25);
        const T1 = H3 + sigma1 + Chi(E4, F2, G2) + SHA256_K[i4] + SHA256_W[i4] | 0;
        const sigma0 = rotr(A4, 2) ^ rotr(A4, 13) ^ rotr(A4, 22);
        const T22 = sigma0 + Maj(A4, B3, C3) | 0;
        H3 = G2;
        G2 = F2;
        F2 = E4;
        E4 = D3 + T1 | 0;
        D3 = C3;
        C3 = B3;
        B3 = A4;
        A4 = T1 + T22 | 0;
      }
      A4 = A4 + this.A | 0;
      B3 = B3 + this.B | 0;
      C3 = C3 + this.C | 0;
      D3 = D3 + this.D | 0;
      E4 = E4 + this.E | 0;
      F2 = F2 + this.F | 0;
      G2 = G2 + this.G | 0;
      H3 = H3 + this.H | 0;
      this.set(A4, B3, C3, D3, E4, F2, G2, H3);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  var SHA224 = class extends SHA256 {
    constructor() {
      super();
      this.A = 3238371032 | 0;
      this.B = 914150663 | 0;
      this.C = 812702999 | 0;
      this.D = 4144912697 | 0;
      this.E = 4290775857 | 0;
      this.F = 1750603025 | 0;
      this.G = 1694076839 | 0;
      this.H = 3204075428 | 0;
      this.outputLen = 28;
    }
  };
  var sha256 = wrapConstructor(() => new SHA256());
  var sha224 = wrapConstructor(() => new SHA224());

  // node_modules/@noble/curves/esm/abstract/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    bitGet: () => bitGet,
    bitLen: () => bitLen,
    bitMask: () => bitMask,
    bitSet: () => bitSet,
    bytesToHex: () => bytesToHex2,
    bytesToNumberBE: () => bytesToNumberBE,
    bytesToNumberLE: () => bytesToNumberLE,
    concatBytes: () => concatBytes2,
    createHmacDrbg: () => createHmacDrbg,
    ensureBytes: () => ensureBytes,
    equalBytes: () => equalBytes,
    hexToBytes: () => hexToBytes2,
    hexToNumber: () => hexToNumber,
    numberToBytesBE: () => numberToBytesBE,
    numberToBytesLE: () => numberToBytesLE,
    numberToHexUnpadded: () => numberToHexUnpadded,
    numberToVarBytesBE: () => numberToVarBytesBE,
    utf8ToBytes: () => utf8ToBytes2,
    validateObject: () => validateObject
  });
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var u8a2 = (a3) => a3 instanceof Uint8Array;
  var hexes2 = Array.from({ length: 256 }, (v4, i4) => i4.toString(16).padStart(2, "0"));
  function bytesToHex2(bytes2) {
    if (!u8a2(bytes2))
      throw new Error("Uint8Array expected");
    let hex2 = "";
    for (let i4 = 0; i4 < bytes2.length; i4++) {
      hex2 += hexes2[bytes2[i4]];
    }
    return hex2;
  }
  function numberToHexUnpadded(num) {
    const hex2 = num.toString(16);
    return hex2.length & 1 ? `0${hex2}` : hex2;
  }
  function hexToNumber(hex2) {
    if (typeof hex2 !== "string")
      throw new Error("hex string expected, got " + typeof hex2);
    return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
  }
  function hexToBytes2(hex2) {
    if (typeof hex2 !== "string")
      throw new Error("hex string expected, got " + typeof hex2);
    const len = hex2.length;
    if (len % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + len);
    const array = new Uint8Array(len / 2);
    for (let i4 = 0; i4 < array.length; i4++) {
      const j2 = i4 * 2;
      const hexByte = hex2.slice(j2, j2 + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new Error("Invalid byte sequence");
      array[i4] = byte;
    }
    return array;
  }
  function bytesToNumberBE(bytes2) {
    return hexToNumber(bytesToHex2(bytes2));
  }
  function bytesToNumberLE(bytes2) {
    if (!u8a2(bytes2))
      throw new Error("Uint8Array expected");
    return hexToNumber(bytesToHex2(Uint8Array.from(bytes2).reverse()));
  }
  function numberToBytesBE(n7, len) {
    return hexToBytes2(n7.toString(16).padStart(len * 2, "0"));
  }
  function numberToBytesLE(n7, len) {
    return numberToBytesBE(n7, len).reverse();
  }
  function numberToVarBytesBE(n7) {
    return hexToBytes2(numberToHexUnpadded(n7));
  }
  function ensureBytes(title, hex2, expectedLength) {
    let res;
    if (typeof hex2 === "string") {
      try {
        res = hexToBytes2(hex2);
      } catch (e8) {
        throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e8}`);
      }
    } else if (u8a2(hex2)) {
      res = Uint8Array.from(hex2);
    } else {
      throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === "number" && len !== expectedLength)
      throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
  }
  function concatBytes2(...arrays) {
    const r4 = new Uint8Array(arrays.reduce((sum, a3) => sum + a3.length, 0));
    let pad = 0;
    arrays.forEach((a3) => {
      if (!u8a2(a3))
        throw new Error("Uint8Array expected");
      r4.set(a3, pad);
      pad += a3.length;
    });
    return r4;
  }
  function equalBytes(b1, b22) {
    if (b1.length !== b22.length)
      return false;
    for (let i4 = 0; i4 < b1.length; i4++)
      if (b1[i4] !== b22[i4])
        return false;
    return true;
  }
  function utf8ToBytes2(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function bitLen(n7) {
    let len;
    for (len = 0; n7 > _0n; n7 >>= _1n, len += 1)
      ;
    return len;
  }
  function bitGet(n7, pos) {
    return n7 >> BigInt(pos) & _1n;
  }
  var bitSet = (n7, pos, value) => {
    return n7 | (value ? _1n : _0n) << BigInt(pos);
  };
  var bitMask = (n7) => (_2n << BigInt(n7 - 1)) - _1n;
  var u8n = (data) => new Uint8Array(data);
  var u8fr = (arr) => Uint8Array.from(arr);
  function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== "number" || hashLen < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    if (typeof hmacFn !== "function")
      throw new Error("hmacFn must be a function");
    let v4 = u8n(hashLen);
    let k3 = u8n(hashLen);
    let i4 = 0;
    const reset = () => {
      v4.fill(1);
      k3.fill(0);
      i4 = 0;
    };
    const h5 = (...b3) => hmacFn(k3, v4, ...b3);
    const reseed = (seed = u8n()) => {
      k3 = h5(u8fr([0]), seed);
      v4 = h5();
      if (seed.length === 0)
        return;
      k3 = h5(u8fr([1]), seed);
      v4 = h5();
    };
    const gen = () => {
      if (i4++ >= 1e3)
        throw new Error("drbg: tried 1000 values");
      let len = 0;
      const out = [];
      while (len < qByteLen) {
        v4 = h5();
        const sl = v4.slice();
        out.push(sl);
        len += v4.length;
      }
      return concatBytes2(...out);
    };
    const genUntil = (seed, pred) => {
      reset();
      reseed(seed);
      let res = void 0;
      while (!(res = pred(gen())))
        reseed();
      reset();
      return res;
    };
    return genUntil;
  }
  var validatorFns = {
    bigint: (val) => typeof val === "bigint",
    function: (val) => typeof val === "function",
    boolean: (val) => typeof val === "boolean",
    string: (val) => typeof val === "string",
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
  };
  function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
      const checkVal = validatorFns[type];
      if (typeof checkVal !== "function")
        throw new Error(`Invalid validator "${type}", expected function`);
      const val = object[fieldName];
      if (isOptional && val === void 0)
        return;
      if (!checkVal(val, object)) {
        throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
      }
    };
    for (const [fieldName, type] of Object.entries(validators))
      checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
      checkField(fieldName, type, true);
    return object;
  }

  // node_modules/@noble/curves/esm/abstract/modular.js
  var _0n2 = BigInt(0);
  var _1n2 = BigInt(1);
  var _2n2 = BigInt(2);
  var _3n = BigInt(3);
  var _4n = BigInt(4);
  var _5n = BigInt(5);
  var _8n = BigInt(8);
  var _9n = BigInt(9);
  var _16n = BigInt(16);
  function mod(a3, b3) {
    const result = a3 % b3;
    return result >= _0n2 ? result : b3 + result;
  }
  function pow(num, power, modulo) {
    if (modulo <= _0n2 || power < _0n2)
      throw new Error("Expected power/modulo > 0");
    if (modulo === _1n2)
      return _0n2;
    let res = _1n2;
    while (power > _0n2) {
      if (power & _1n2)
        res = res * num % modulo;
      num = num * num % modulo;
      power >>= _1n2;
    }
    return res;
  }
  function pow2(x4, power, modulo) {
    let res = x4;
    while (power-- > _0n2) {
      res *= res;
      res %= modulo;
    }
    return res;
  }
  function invert(number2, modulo) {
    if (number2 === _0n2 || modulo <= _0n2) {
      throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
    }
    let a3 = mod(number2, modulo);
    let b3 = modulo;
    let x4 = _0n2, y4 = _1n2, u5 = _1n2, v4 = _0n2;
    while (a3 !== _0n2) {
      const q3 = b3 / a3;
      const r4 = b3 % a3;
      const m3 = x4 - u5 * q3;
      const n7 = y4 - v4 * q3;
      b3 = a3, a3 = r4, x4 = u5, y4 = v4, u5 = m3, v4 = n7;
    }
    const gcd2 = b3;
    if (gcd2 !== _1n2)
      throw new Error("invert: does not exist");
    return mod(x4, modulo);
  }
  function tonelliShanks(P3) {
    const legendreC = (P3 - _1n2) / _2n2;
    let Q2, S5, Z3;
    for (Q2 = P3 - _1n2, S5 = 0; Q2 % _2n2 === _0n2; Q2 /= _2n2, S5++)
      ;
    for (Z3 = _2n2; Z3 < P3 && pow(Z3, legendreC, P3) !== P3 - _1n2; Z3++)
      ;
    if (S5 === 1) {
      const p1div4 = (P3 + _1n2) / _4n;
      return function tonelliFast(Fp2, n7) {
        const root = Fp2.pow(n7, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n7))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    const Q1div2 = (Q2 + _1n2) / _2n2;
    return function tonelliSlow(Fp2, n7) {
      if (Fp2.pow(n7, legendreC) === Fp2.neg(Fp2.ONE))
        throw new Error("Cannot find square root");
      let r4 = S5;
      let g4 = Fp2.pow(Fp2.mul(Fp2.ONE, Z3), Q2);
      let x4 = Fp2.pow(n7, Q1div2);
      let b3 = Fp2.pow(n7, Q2);
      while (!Fp2.eql(b3, Fp2.ONE)) {
        if (Fp2.eql(b3, Fp2.ZERO))
          return Fp2.ZERO;
        let m3 = 1;
        for (let t22 = Fp2.sqr(b3); m3 < r4; m3++) {
          if (Fp2.eql(t22, Fp2.ONE))
            break;
          t22 = Fp2.sqr(t22);
        }
        const ge3 = Fp2.pow(g4, _1n2 << BigInt(r4 - m3 - 1));
        g4 = Fp2.sqr(ge3);
        x4 = Fp2.mul(x4, ge3);
        b3 = Fp2.mul(b3, g4);
        r4 = m3;
      }
      return x4;
    };
  }
  function FpSqrt(P3) {
    if (P3 % _4n === _3n) {
      const p1div4 = (P3 + _1n2) / _4n;
      return function sqrt3mod4(Fp2, n7) {
        const root = Fp2.pow(n7, p1div4);
        if (!Fp2.eql(Fp2.sqr(root), n7))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P3 % _8n === _5n) {
      const c1 = (P3 - _5n) / _8n;
      return function sqrt5mod8(Fp2, n7) {
        const n22 = Fp2.mul(n7, _2n2);
        const v4 = Fp2.pow(n22, c1);
        const nv = Fp2.mul(n7, v4);
        const i4 = Fp2.mul(Fp2.mul(nv, _2n2), v4);
        const root = Fp2.mul(nv, Fp2.sub(i4, Fp2.ONE));
        if (!Fp2.eql(Fp2.sqr(root), n7))
          throw new Error("Cannot find square root");
        return root;
      };
    }
    if (P3 % _16n === _9n) {
    }
    return tonelliShanks(P3);
  }
  var FIELD_FIELDS = [
    "create",
    "isValid",
    "is0",
    "neg",
    "inv",
    "sqrt",
    "sqr",
    "eql",
    "add",
    "sub",
    "mul",
    "pow",
    "div",
    "addN",
    "subN",
    "mulN",
    "sqrN"
  ];
  function validateField(field) {
    const initial = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger"
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
      map[val] = "function";
      return map;
    }, initial);
    return validateObject(field, opts);
  }
  function FpPow(f5, num, power) {
    if (power < _0n2)
      throw new Error("Expected power > 0");
    if (power === _0n2)
      return f5.ONE;
    if (power === _1n2)
      return num;
    let p4 = f5.ONE;
    let d4 = num;
    while (power > _0n2) {
      if (power & _1n2)
        p4 = f5.mul(p4, d4);
      d4 = f5.sqr(d4);
      power >>= _1n2;
    }
    return p4;
  }
  function FpInvertBatch(f5, nums) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i4) => {
      if (f5.is0(num))
        return acc;
      tmp[i4] = acc;
      return f5.mul(acc, num);
    }, f5.ONE);
    const inverted = f5.inv(lastMultiplied);
    nums.reduceRight((acc, num, i4) => {
      if (f5.is0(num))
        return acc;
      tmp[i4] = f5.mul(acc, tmp[i4]);
      return f5.mul(acc, num);
    }, inverted);
    return tmp;
  }
  function nLength(n7, nBitLength) {
    const _nBitLength = nBitLength !== void 0 ? nBitLength : n7.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
  }
  function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
    if (ORDER <= _0n2)
      throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
    if (BYTES > 2048)
      throw new Error("Field lengths over 2048 bytes are not supported");
    const sqrtP = FpSqrt(ORDER);
    const f5 = Object.freeze({
      ORDER,
      BITS,
      BYTES,
      MASK: bitMask(BITS),
      ZERO: _0n2,
      ONE: _1n2,
      create: (num) => mod(num, ORDER),
      isValid: (num) => {
        if (typeof num !== "bigint")
          throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
        return _0n2 <= num && num < ORDER;
      },
      is0: (num) => num === _0n2,
      isOdd: (num) => (num & _1n2) === _1n2,
      neg: (num) => mod(-num, ORDER),
      eql: (lhs, rhs) => lhs === rhs,
      sqr: (num) => mod(num * num, ORDER),
      add: (lhs, rhs) => mod(lhs + rhs, ORDER),
      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
      pow: (num, power) => FpPow(f5, num, power),
      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
      // Same as above, but doesn't normalize
      sqrN: (num) => num * num,
      addN: (lhs, rhs) => lhs + rhs,
      subN: (lhs, rhs) => lhs - rhs,
      mulN: (lhs, rhs) => lhs * rhs,
      inv: (num) => invert(num, ORDER),
      sqrt: redef.sqrt || ((n7) => sqrtP(f5, n7)),
      invertBatch: (lst) => FpInvertBatch(f5, lst),
      // TODO: do we really need constant cmov?
      // We don't have const-time bigints anyway, so probably will be not very useful
      cmov: (a3, b3, c4) => c4 ? b3 : a3,
      toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
      fromBytes: (bytes2) => {
        if (bytes2.length !== BYTES)
          throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
        return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
      }
    });
    return Object.freeze(f5);
  }
  function hashToPrivateScalar(hash2, groupOrder, isLE2 = false) {
    hash2 = ensureBytes("privateHash", hash2);
    const hashLen = hash2.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
      throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE2 ? bytesToNumberLE(hash2) : bytesToNumberBE(hash2);
    return mod(num, groupOrder - _1n2) + _1n2;
  }

  // node_modules/@noble/curves/esm/abstract/curve.js
  var _0n3 = BigInt(0);
  var _1n3 = BigInt(1);
  function wNAF(c4, bits) {
    const constTimeNegate = (condition, item) => {
      const neg = item.negate();
      return condition ? neg : item;
    };
    const opts = (W2) => {
      const windows = Math.ceil(bits / W2) + 1;
      const windowSize = 2 ** (W2 - 1);
      return { windows, windowSize };
    };
    return {
      constTimeNegate,
      // non-const time multiplication ladder
      unsafeLadder(elm, n7) {
        let p4 = c4.ZERO;
        let d4 = elm;
        while (n7 > _0n3) {
          if (n7 & _1n3)
            p4 = p4.add(d4);
          d4 = d4.double();
          n7 >>= _1n3;
        }
        return p4;
      },
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
       * - 𝑊 is the window size
       * - 𝑛 is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(elm, W2) {
        const { windows, windowSize } = opts(W2);
        const points = [];
        let p4 = elm;
        let base = p4;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p4;
          points.push(base);
          for (let i4 = 1; i4 < windowSize; i4++) {
            base = base.add(p4);
            points.push(base);
          }
          p4 = base.double();
        }
        return points;
      },
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * @param W window size
       * @param precomputes precomputed tables
       * @param n scalar (we don't check here, but should be less than curve order)
       * @returns real and fake (for const-time) points
       */
      wNAF(W2, precomputes, n7) {
        const { windows, windowSize } = opts(W2);
        let p4 = c4.ZERO;
        let f5 = c4.BASE;
        const mask = BigInt(2 ** W2 - 1);
        const maxNumber = 2 ** W2;
        const shiftBy = BigInt(W2);
        for (let window2 = 0; window2 < windows; window2++) {
          const offset = window2 * windowSize;
          let wbits = Number(n7 & mask);
          n7 >>= shiftBy;
          if (wbits > windowSize) {
            wbits -= maxNumber;
            n7 += _1n3;
          }
          const offset1 = offset;
          const offset2 = offset + Math.abs(wbits) - 1;
          const cond1 = window2 % 2 !== 0;
          const cond2 = wbits < 0;
          if (wbits === 0) {
            f5 = f5.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p4 = p4.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }
        return { p: p4, f: f5 };
      },
      wNAFCached(P3, precomputesMap, n7, transform) {
        const W2 = P3._WINDOW_SIZE || 1;
        let comp = precomputesMap.get(P3);
        if (!comp) {
          comp = this.precomputeWindow(P3, W2);
          if (W2 !== 1) {
            precomputesMap.set(P3, transform(comp));
          }
        }
        return this.wNAF(W2, comp, n7);
      }
    };
  }
  function validateBasic(curve) {
    validateField(curve.Fp);
    validateObject(curve, {
      n: "bigint",
      h: "bigint",
      Gx: "field",
      Gy: "field"
    }, {
      nBitLength: "isSafeInteger",
      nByteLength: "isSafeInteger"
    });
    return Object.freeze({
      ...nLength(curve.n, curve.nBitLength),
      ...curve,
      ...{ p: curve.Fp.ORDER }
    });
  }

  // node_modules/@noble/curves/esm/abstract/weierstrass.js
  function validatePointOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      a: "field",
      b: "field"
    }, {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function"
    });
    const { endo, Fp: Fp2, a: a3 } = opts;
    if (endo) {
      if (!Fp2.eql(a3, Fp2.ZERO)) {
        throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
      }
      if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
        throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
      }
    }
    return Object.freeze({ ...opts });
  }
  var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
  var DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
      constructor(m3 = "") {
        super(m3);
      }
    },
    _parseInt(data) {
      const { Err: E4 } = DER;
      if (data.length < 2 || data[0] !== 2)
        throw new E4("Invalid signature integer tag");
      const len = data[1];
      const res = data.subarray(2, len + 2);
      if (!len || res.length !== len)
        throw new E4("Invalid signature integer: wrong length");
      if (res[0] & 128)
        throw new E4("Invalid signature integer: negative");
      if (res[0] === 0 && !(res[1] & 128))
        throw new E4("Invalid signature integer: unnecessary leading zero");
      return { d: b2n(res), l: data.subarray(len + 2) };
    },
    toSig(hex2) {
      const { Err: E4 } = DER;
      const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
      if (!(data instanceof Uint8Array))
        throw new Error("ui8a expected");
      let l6 = data.length;
      if (l6 < 2 || data[0] != 48)
        throw new E4("Invalid signature tag");
      if (data[1] !== l6 - 2)
        throw new E4("Invalid signature: incorrect length");
      const { d: r4, l: sBytes } = DER._parseInt(data.subarray(2));
      const { d: s5, l: rBytesLeft } = DER._parseInt(sBytes);
      if (rBytesLeft.length)
        throw new E4("Invalid signature: left bytes after parsing");
      return { r: r4, s: s5 };
    },
    hexFromSig(sig) {
      const slice = (s6) => Number.parseInt(s6[0], 16) & 8 ? "00" + s6 : s6;
      const h5 = (num) => {
        const hex2 = num.toString(16);
        return hex2.length & 1 ? `0${hex2}` : hex2;
      };
      const s5 = slice(h5(sig.s));
      const r4 = slice(h5(sig.r));
      const shl = s5.length / 2;
      const rhl = r4.length / 2;
      const sl = h5(shl);
      const rl = h5(rhl);
      return `30${h5(rhl + shl + 4)}02${rl}${r4}02${sl}${s5}`;
    }
  };
  var _0n4 = BigInt(0);
  var _1n4 = BigInt(1);
  var _2n3 = BigInt(2);
  var _3n2 = BigInt(3);
  var _4n2 = BigInt(4);
  function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp: Fp2 } = CURVE;
    const toBytes2 = CURVE.toBytes || ((c4, point, isCompressed) => {
      const a3 = point.toAffine();
      return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a3.x), Fp2.toBytes(a3.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes2) => {
      const tail = bytes2.subarray(1);
      const x4 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
      const y4 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
      return { x: x4, y: y4 };
    });
    function weierstrassEquation(x4) {
      const { a: a3, b: b3 } = CURVE;
      const x22 = Fp2.sqr(x4);
      const x32 = Fp2.mul(x22, x4);
      return Fp2.add(Fp2.add(x32, Fp2.mul(x4, a3)), b3);
    }
    if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
      throw new Error("bad generator point: equation left != right");
    function isWithinCurveOrder(num) {
      return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
    }
    function assertGE(num) {
      if (!isWithinCurveOrder(num))
        throw new Error("Expected valid bigint: 0 < bigint < curve.n");
    }
    function normPrivateKeyToScalar(key) {
      const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n7 } = CURVE;
      if (lengths && typeof key !== "bigint") {
        if (key instanceof Uint8Array)
          key = bytesToHex2(key);
        if (typeof key !== "string" || !lengths.includes(key.length))
          throw new Error("Invalid key");
        key = key.padStart(nByteLength * 2, "0");
      }
      let num;
      try {
        num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
      } catch (error) {
        throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
      }
      if (wrapPrivateKey)
        num = mod(num, n7);
      assertGE(num);
      return num;
    }
    const pointPrecomputes = /* @__PURE__ */ new Map();
    function assertPrjPoint(other) {
      if (!(other instanceof Point3))
        throw new Error("ProjectivePoint expected");
    }
    class Point3 {
      constructor(px, py, pz) {
        this.px = px;
        this.py = py;
        this.pz = pz;
        if (px == null || !Fp2.isValid(px))
          throw new Error("x required");
        if (py == null || !Fp2.isValid(py))
          throw new Error("y required");
        if (pz == null || !Fp2.isValid(pz))
          throw new Error("z required");
      }
      // Does not validate if the point is on-curve.
      // Use fromHex instead, or call assertValidity() later.
      static fromAffine(p4) {
        const { x: x4, y: y4 } = p4 || {};
        if (!p4 || !Fp2.isValid(x4) || !Fp2.isValid(y4))
          throw new Error("invalid affine point");
        if (p4 instanceof Point3)
          throw new Error("projective point not allowed");
        const is0 = (i4) => Fp2.eql(i4, Fp2.ZERO);
        if (is0(x4) && is0(y4))
          return Point3.ZERO;
        return new Point3(x4, y4, Fp2.ONE);
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
      static normalizeZ(points) {
        const toInv = Fp2.invertBatch(points.map((p4) => p4.pz));
        return points.map((p4, i4) => p4.toAffine(toInv[i4])).map(Point3.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
      static fromHex(hex2) {
        const P3 = Point3.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
        P3.assertValidity();
        return P3;
      }
      // Multiplies generator point by privateKey.
      static fromPrivateKey(privateKey) {
        return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
      // "Private method", don't use it directly
      _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
      }
      // A point on curve is valid if it conforms to equation.
      assertValidity() {
        if (this.is0()) {
          if (CURVE.allowInfinityPoint)
            return;
          throw new Error("bad point: ZERO");
        }
        const { x: x4, y: y4 } = this.toAffine();
        if (!Fp2.isValid(x4) || !Fp2.isValid(y4))
          throw new Error("bad point: x or y not FE");
        const left = Fp2.sqr(y4);
        const right = weierstrassEquation(x4);
        if (!Fp2.eql(left, right))
          throw new Error("bad point: equation left != right");
        if (!this.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
      }
      hasEvenY() {
        const { y: y4 } = this.toAffine();
        if (Fp2.isOdd)
          return !Fp2.isOdd(y4);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
      equals(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z22 } = other;
        const U1 = Fp2.eql(Fp2.mul(X1, Z22), Fp2.mul(X2, Z1));
        const U2 = Fp2.eql(Fp2.mul(Y1, Z22), Fp2.mul(Y2, Z1));
        return U1 && U2;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
      negate() {
        return new Point3(this.px, Fp2.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
      double() {
        const { a: a3, b: b3 } = CURVE;
        const b32 = Fp2.mul(b3, _3n2);
        const { px: X1, py: Y1, pz: Z1 } = this;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        let t0 = Fp2.mul(X1, X1);
        let t1 = Fp2.mul(Y1, Y1);
        let t22 = Fp2.mul(Z1, Z1);
        let t32 = Fp2.mul(X1, Y1);
        t32 = Fp2.add(t32, t32);
        Z3 = Fp2.mul(X1, Z1);
        Z3 = Fp2.add(Z3, Z3);
        X3 = Fp2.mul(a3, Z3);
        Y3 = Fp2.mul(b32, t22);
        Y3 = Fp2.add(X3, Y3);
        X3 = Fp2.sub(t1, Y3);
        Y3 = Fp2.add(t1, Y3);
        Y3 = Fp2.mul(X3, Y3);
        X3 = Fp2.mul(t32, X3);
        Z3 = Fp2.mul(b32, Z3);
        t22 = Fp2.mul(a3, t22);
        t32 = Fp2.sub(t0, t22);
        t32 = Fp2.mul(a3, t32);
        t32 = Fp2.add(t32, Z3);
        Z3 = Fp2.add(t0, t0);
        t0 = Fp2.add(Z3, t0);
        t0 = Fp2.add(t0, t22);
        t0 = Fp2.mul(t0, t32);
        Y3 = Fp2.add(Y3, t0);
        t22 = Fp2.mul(Y1, Z1);
        t22 = Fp2.add(t22, t22);
        t0 = Fp2.mul(t22, t32);
        X3 = Fp2.sub(X3, t0);
        Z3 = Fp2.mul(t22, t1);
        Z3 = Fp2.add(Z3, Z3);
        Z3 = Fp2.add(Z3, Z3);
        return new Point3(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
      add(other) {
        assertPrjPoint(other);
        const { px: X1, py: Y1, pz: Z1 } = this;
        const { px: X2, py: Y2, pz: Z22 } = other;
        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
        const a3 = CURVE.a;
        const b3 = Fp2.mul(CURVE.b, _3n2);
        let t0 = Fp2.mul(X1, X2);
        let t1 = Fp2.mul(Y1, Y2);
        let t22 = Fp2.mul(Z1, Z22);
        let t32 = Fp2.add(X1, Y1);
        let t42 = Fp2.add(X2, Y2);
        t32 = Fp2.mul(t32, t42);
        t42 = Fp2.add(t0, t1);
        t32 = Fp2.sub(t32, t42);
        t42 = Fp2.add(X1, Z1);
        let t5 = Fp2.add(X2, Z22);
        t42 = Fp2.mul(t42, t5);
        t5 = Fp2.add(t0, t22);
        t42 = Fp2.sub(t42, t5);
        t5 = Fp2.add(Y1, Z1);
        X3 = Fp2.add(Y2, Z22);
        t5 = Fp2.mul(t5, X3);
        X3 = Fp2.add(t1, t22);
        t5 = Fp2.sub(t5, X3);
        Z3 = Fp2.mul(a3, t42);
        X3 = Fp2.mul(b3, t22);
        Z3 = Fp2.add(X3, Z3);
        X3 = Fp2.sub(t1, Z3);
        Z3 = Fp2.add(t1, Z3);
        Y3 = Fp2.mul(X3, Z3);
        t1 = Fp2.add(t0, t0);
        t1 = Fp2.add(t1, t0);
        t22 = Fp2.mul(a3, t22);
        t42 = Fp2.mul(b3, t42);
        t1 = Fp2.add(t1, t22);
        t22 = Fp2.sub(t0, t22);
        t22 = Fp2.mul(a3, t22);
        t42 = Fp2.add(t42, t22);
        t0 = Fp2.mul(t1, t42);
        Y3 = Fp2.add(Y3, t0);
        t0 = Fp2.mul(t5, t42);
        X3 = Fp2.mul(t32, X3);
        X3 = Fp2.sub(X3, t0);
        t0 = Fp2.mul(t32, t1);
        Z3 = Fp2.mul(t5, Z3);
        Z3 = Fp2.add(Z3, t0);
        return new Point3(X3, Y3, Z3);
      }
      subtract(other) {
        return this.add(other.negate());
      }
      is0() {
        return this.equals(Point3.ZERO);
      }
      wNAF(n7) {
        return wnaf.wNAFCached(this, pointPrecomputes, n7, (comp) => {
          const toInv = Fp2.invertBatch(comp.map((p4) => p4.pz));
          return comp.map((p4, i4) => p4.toAffine(toInv[i4])).map(Point3.fromAffine);
        });
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
      multiplyUnsafe(n7) {
        const I3 = Point3.ZERO;
        if (n7 === _0n4)
          return I3;
        assertGE(n7);
        if (n7 === _1n4)
          return this;
        const { endo } = CURVE;
        if (!endo)
          return wnaf.unsafeLadder(this, n7);
        let { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n7);
        let k1p = I3;
        let k2p = I3;
        let d4 = this;
        while (k1 > _0n4 || k22 > _0n4) {
          if (k1 & _1n4)
            k1p = k1p.add(d4);
          if (k22 & _1n4)
            k2p = k2p.add(d4);
          d4 = d4.double();
          k1 >>= _1n4;
          k22 >>= _1n4;
        }
        if (k1neg)
          k1p = k1p.negate();
        if (k2neg)
          k2p = k2p.negate();
        k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
      multiply(scalar) {
        assertGE(scalar);
        let n7 = scalar;
        let point, fake;
        const { endo } = CURVE;
        if (endo) {
          const { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n7);
          let { p: k1p, f: f1p } = this.wNAF(k1);
          let { p: k2p, f: f2p } = this.wNAF(k22);
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          const { p: p4, f: f5 } = this.wNAF(n7);
          point = p4;
          fake = f5;
        }
        return Point3.normalizeZ([point, fake])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
      multiplyAndAddUnsafe(Q2, a3, b3) {
        const G2 = Point3.BASE;
        const mul = (P3, a4) => a4 === _0n4 || a4 === _1n4 || !P3.equals(G2) ? P3.multiplyUnsafe(a4) : P3.multiply(a4);
        const sum = mul(this, a3).add(mul(Q2, b3));
        return sum.is0() ? void 0 : sum;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z) ∋ (x=x/z, y=y/z)
      toAffine(iz) {
        const { px: x4, py: y4, pz: z3 } = this;
        const is0 = this.is0();
        if (iz == null)
          iz = is0 ? Fp2.ONE : Fp2.inv(z3);
        const ax = Fp2.mul(x4, iz);
        const ay = Fp2.mul(y4, iz);
        const zz = Fp2.mul(z3, iz);
        if (is0)
          return { x: Fp2.ZERO, y: Fp2.ZERO };
        if (!Fp2.eql(zz, Fp2.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      }
      isTorsionFree() {
        const { h: cofactor, isTorsionFree } = CURVE;
        if (cofactor === _1n4)
          return true;
        if (isTorsionFree)
          return isTorsionFree(Point3, this);
        throw new Error("isTorsionFree() has not been declared for the elliptic curve");
      }
      clearCofactor() {
        const { h: cofactor, clearCofactor } = CURVE;
        if (cofactor === _1n4)
          return this;
        if (clearCofactor)
          return clearCofactor(Point3, this);
        return this.multiplyUnsafe(CURVE.h);
      }
      toRawBytes(isCompressed = true) {
        this.assertValidity();
        return toBytes2(Point3, this, isCompressed);
      }
      toHex(isCompressed = true) {
        return bytesToHex2(this.toRawBytes(isCompressed));
      }
    }
    Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp2.ONE);
    Point3.ZERO = new Point3(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = wNAF(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    return {
      CURVE,
      ProjectivePoint: Point3,
      normPrivateKeyToScalar,
      weierstrassEquation,
      isWithinCurveOrder
    };
  }
  function validateOpts(curve) {
    const opts = validateBasic(curve);
    validateObject(opts, {
      hash: "hash",
      hmac: "function",
      randomBytes: "function"
    }, {
      bits2int: "function",
      bits2int_modN: "function",
      lowS: "boolean"
    });
    return Object.freeze({ lowS: true, ...opts });
  }
  function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp2.BYTES + 1;
    const uncompressedLen = 2 * Fp2.BYTES + 1;
    function isValidFieldElement(num) {
      return _0n4 < num && num < Fp2.ORDER;
    }
    function modN2(a3) {
      return mod(a3, CURVE_ORDER);
    }
    function invN(a3) {
      return invert(a3, CURVE_ORDER);
    }
    const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
      ...CURVE,
      toBytes(c4, point, isCompressed) {
        const a3 = point.toAffine();
        const x4 = Fp2.toBytes(a3.x);
        const cat = concatBytes2;
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x4);
        } else {
          return cat(Uint8Array.from([4]), x4, Fp2.toBytes(a3.y));
        }
      },
      fromBytes(bytes2) {
        const len = bytes2.length;
        const head = bytes2[0];
        const tail = bytes2.subarray(1);
        if (len === compressedLen && (head === 2 || head === 3)) {
          const x4 = bytesToNumberBE(tail);
          if (!isValidFieldElement(x4))
            throw new Error("Point is not on curve");
          const y22 = weierstrassEquation(x4);
          let y4 = Fp2.sqrt(y22);
          const isYOdd = (y4 & _1n4) === _1n4;
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y4 = Fp2.neg(y4);
          return { x: x4, y: y4 };
        } else if (len === uncompressedLen && head === 4) {
          const x4 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
          const y4 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
          return { x: x4, y: y4 };
        } else {
          throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
        }
      }
    });
    const numToNByteStr = (num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number2) {
      const HALF = CURVE_ORDER >> _1n4;
      return number2 > HALF;
    }
    function normalizeS(s5) {
      return isBiggerThanHalfOrder(s5) ? modN2(-s5) : s5;
    }
    const slcNum = (b3, from, to2) => bytesToNumberBE(b3.slice(from, to2));
    class Signature {
      constructor(r4, s5, recovery) {
        this.r = r4;
        this.s = s5;
        this.recovery = recovery;
        this.assertValidity();
      }
      // pair (bytes of r, bytes of s)
      static fromCompact(hex2) {
        const l6 = CURVE.nByteLength;
        hex2 = ensureBytes("compactSignature", hex2, l6 * 2);
        return new Signature(slcNum(hex2, 0, l6), slcNum(hex2, l6, 2 * l6));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
      static fromDER(hex2) {
        const { r: r4, s: s5 } = DER.toSig(ensureBytes("DER", hex2));
        return new Signature(r4, s5);
      }
      assertValidity() {
        if (!isWithinCurveOrder(this.r))
          throw new Error("r must be 0 < r < CURVE.n");
        if (!isWithinCurveOrder(this.s))
          throw new Error("s must be 0 < s < CURVE.n");
      }
      addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
      recoverPublicKey(msgHash) {
        const { r: r4, s: s5, recovery: rec } = this;
        const h5 = bits2int_modN(ensureBytes("msgHash", msgHash));
        if (rec == null || ![0, 1, 2, 3].includes(rec))
          throw new Error("recovery id invalid");
        const radj = rec === 2 || rec === 3 ? r4 + CURVE.n : r4;
        if (radj >= Fp2.ORDER)
          throw new Error("recovery id 2 or 3 invalid");
        const prefix = (rec & 1) === 0 ? "02" : "03";
        const R4 = Point3.fromHex(prefix + numToNByteStr(radj));
        const ir = invN(radj);
        const u1 = modN2(-h5 * ir);
        const u22 = modN2(s5 * ir);
        const Q2 = Point3.BASE.multiplyAndAddUnsafe(R4, u1, u22);
        if (!Q2)
          throw new Error("point at infinify");
        Q2.assertValidity();
        return Q2;
      }
      // Signatures should be low-s, to prevent malleability.
      hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
      normalizeS() {
        return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
      }
      // DER-encoded
      toDERRawBytes() {
        return hexToBytes2(this.toDERHex());
      }
      toDERHex() {
        return DER.hexFromSig({ r: this.r, s: this.s });
      }
      // padded bytes of r, then padded bytes of s
      toCompactRawBytes() {
        return hexToBytes2(this.toCompactHex());
      }
      toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }
    const utils2 = {
      isValidPrivateKey(privateKey) {
        try {
          normPrivateKeyToScalar(privateKey);
          return true;
        } catch (error) {
          return false;
        }
      },
      normPrivateKeyToScalar,
      /**
       * Produces cryptographically secure private key from random of size (nBitLength+64)
       * as per FIPS 186 B.4.1 with modulo bias being neglible.
       */
      randomPrivateKey: () => {
        const rand = CURVE.randomBytes(Fp2.BYTES + 8);
        const num = hashToPrivateScalar(rand, CURVE_ORDER);
        return numberToBytesBE(num, CURVE.nByteLength);
      },
      /**
       * Creates precompute table for an arbitrary EC point. Makes point "cached".
       * Allows to massively speed-up `point.multiply(scalar)`.
       * @returns cached point
       * @example
       * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
       * fast.multiply(privKey); // much faster ECDH now
       */
      precompute(windowSize = 8, point = Point3.BASE) {
        point._setWindowSize(windowSize);
        point.multiply(BigInt(3));
        return point;
      }
    };
    function getPublicKey2(privateKey, isCompressed = true) {
      return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    function isProbPub(item) {
      const arr = item instanceof Uint8Array;
      const str = typeof item === "string";
      const len = (arr || str) && item.length;
      if (arr)
        return len === compressedLen || len === uncompressedLen;
      if (str)
        return len === 2 * compressedLen || len === 2 * uncompressedLen;
      if (item instanceof Point3)
        return true;
      return false;
    }
    function getSharedSecret(privateA, publicB, isCompressed = true) {
      if (isProbPub(privateA))
        throw new Error("first arg must be private key");
      if (!isProbPub(publicB))
        throw new Error("second arg must be public key");
      const b3 = Point3.fromHex(publicB);
      return b3.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    const bits2int = CURVE.bits2int || function(bytes2) {
      const num = bytesToNumberBE(bytes2);
      const delta = bytes2.length * 8 - CURVE.nBitLength;
      return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
      return modN2(bits2int(bytes2));
    };
    const ORDER_MASK = bitMask(CURVE.nBitLength);
    function int2octets(num) {
      if (typeof num !== "bigint")
        throw new Error("bigint expected");
      if (!(_0n4 <= num && num < ORDER_MASK))
        throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
      return numberToBytesBE(num, CURVE.nByteLength);
    }
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
      if (["recovered", "canonical"].some((k3) => k3 in opts))
        throw new Error("sign() legacy options not supported");
      const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
      let { lowS, prehash, extraEntropy: ent } = opts;
      if (lowS == null)
        lowS = true;
      msgHash = ensureBytes("msgHash", msgHash);
      if (prehash)
        msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
      const h1int = bits2int_modN(msgHash);
      const d4 = normPrivateKeyToScalar(privateKey);
      const seedArgs = [int2octets(d4), int2octets(h1int)];
      if (ent != null) {
        const e8 = ent === true ? randomBytes2(Fp2.BYTES) : ent;
        seedArgs.push(ensureBytes("extraEntropy", e8, Fp2.BYTES));
      }
      const seed = concatBytes2(...seedArgs);
      const m3 = h1int;
      function k2sig(kBytes) {
        const k3 = bits2int(kBytes);
        if (!isWithinCurveOrder(k3))
          return;
        const ik = invN(k3);
        const q3 = Point3.BASE.multiply(k3).toAffine();
        const r4 = modN2(q3.x);
        if (r4 === _0n4)
          return;
        const s5 = modN2(ik * modN2(m3 + r4 * d4));
        if (s5 === _0n4)
          return;
        let recovery = (q3.x === r4 ? 0 : 2) | Number(q3.y & _1n4);
        let normS = s5;
        if (lowS && isBiggerThanHalfOrder(s5)) {
          normS = normalizeS(s5);
          recovery ^= 1;
        }
        return new Signature(r4, normS, recovery);
      }
      return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    function sign(msgHash, privKey, opts = defaultSigOpts) {
      const { seed, k2sig } = prepSig(msgHash, privKey, opts);
      const C3 = CURVE;
      const drbg = createHmacDrbg(C3.hash.outputLen, C3.nByteLength, C3.hmac);
      return drbg(seed, k2sig);
    }
    Point3.BASE._setWindowSize(8);
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
      const sg = signature;
      msgHash = ensureBytes("msgHash", msgHash);
      publicKey = ensureBytes("publicKey", publicKey);
      if ("strict" in opts)
        throw new Error("options.strict was renamed to lowS");
      const { lowS, prehash } = opts;
      let _sig = void 0;
      let P3;
      try {
        if (typeof sg === "string" || sg instanceof Uint8Array) {
          try {
            _sig = Signature.fromDER(sg);
          } catch (derError) {
            if (!(derError instanceof DER.Err))
              throw derError;
            _sig = Signature.fromCompact(sg);
          }
        } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
          const { r: r5, s: s6 } = sg;
          _sig = new Signature(r5, s6);
        } else {
          throw new Error("PARSE");
        }
        P3 = Point3.fromHex(publicKey);
      } catch (error) {
        if (error.message === "PARSE")
          throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
        return false;
      }
      if (lowS && _sig.hasHighS())
        return false;
      if (prehash)
        msgHash = CURVE.hash(msgHash);
      const { r: r4, s: s5 } = _sig;
      const h5 = bits2int_modN(msgHash);
      const is = invN(s5);
      const u1 = modN2(h5 * is);
      const u22 = modN2(r4 * is);
      const R4 = Point3.BASE.multiplyAndAddUnsafe(P3, u1, u22)?.toAffine();
      if (!R4)
        return false;
      const v4 = modN2(R4.x);
      return v4 === r4;
    }
    return {
      CURVE,
      getPublicKey: getPublicKey2,
      getSharedSecret,
      sign,
      verify,
      ProjectivePoint: Point3,
      Signature,
      utils: utils2
    };
  }

  // node_modules/@noble/hashes/esm/hmac.js
  var HMAC = class extends Hash {
    constructor(hash2, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      assert_default.hash(hash2);
      const key = toBytes(_key);
      this.iHash = hash2.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
      for (let i4 = 0; i4 < pad.length; i4++)
        pad[i4] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash2.create();
      for (let i4 = 0; i4 < pad.length; i4++)
        pad[i4] ^= 54 ^ 92;
      this.oHash.update(pad);
      pad.fill(0);
    }
    update(buf) {
      assert_default.exists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      assert_default.exists(this);
      assert_default.bytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to2) {
      to2 || (to2 = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to2 = to2;
      to2.finished = finished;
      to2.destroyed = destroyed;
      to2.blockLen = blockLen;
      to2.outputLen = outputLen;
      to2.oHash = oHash._cloneInto(to2.oHash);
      to2.iHash = iHash._cloneInto(to2.iHash);
      return to2;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
  hmac.create = (hash2, key) => new HMAC(hash2, key);

  // node_modules/@noble/curves/esm/_shortw_utils.js
  function getHash(hash2) {
    return {
      hash: hash2,
      hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
      randomBytes
    };
  }
  function createCurve(curveDef, defHash) {
    const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
    return Object.freeze({ ...create(defHash), create });
  }

  // node_modules/@noble/curves/esm/secp256k1.js
  var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
  var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  var _1n5 = BigInt(1);
  var _2n4 = BigInt(2);
  var divNearest = (a3, b3) => (a3 + b3 / _2n4) / b3;
  function sqrtMod(y4) {
    const P3 = secp256k1P;
    const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b22 = y4 * y4 * y4 % P3;
    const b3 = b22 * b22 * y4 % P3;
    const b6 = pow2(b3, _3n3, P3) * b3 % P3;
    const b9 = pow2(b6, _3n3, P3) * b3 % P3;
    const b11 = pow2(b9, _2n4, P3) * b22 % P3;
    const b222 = pow2(b11, _11n, P3) * b11 % P3;
    const b44 = pow2(b222, _22n, P3) * b222 % P3;
    const b88 = pow2(b44, _44n, P3) * b44 % P3;
    const b176 = pow2(b88, _88n, P3) * b88 % P3;
    const b220 = pow2(b176, _44n, P3) * b44 % P3;
    const b223 = pow2(b220, _3n3, P3) * b3 % P3;
    const t1 = pow2(b223, _23n, P3) * b222 % P3;
    const t22 = pow2(t1, _6n, P3) * b22 % P3;
    const root = pow2(t22, _2n4, P3);
    if (!Fp.eql(Fp.sqr(root), y4))
      throw new Error("Cannot find square root");
    return root;
  }
  var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
  var secp256k1 = createCurve({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    // Base point (x, y) aka generator point
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: true,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      splitScalar: (k3) => {
        const n7 = secp256k1N;
        const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
        const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
        const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
        const b22 = a1;
        const POW_2_128 = BigInt("0x100000000000000000000000000000000");
        const c1 = divNearest(b22 * k3, n7);
        const c22 = divNearest(-b1 * k3, n7);
        let k1 = mod(k3 - c1 * a1 - c22 * a22, n7);
        let k22 = mod(-c1 * b1 - c22 * b22, n7);
        const k1neg = k1 > POW_2_128;
        const k2neg = k22 > POW_2_128;
        if (k1neg)
          k1 = n7 - k1;
        if (k2neg)
          k22 = n7 - k22;
        if (k1 > POW_2_128 || k22 > POW_2_128) {
          throw new Error("splitScalar: Endomorphism failed, k=" + k3);
        }
        return { k1neg, k1, k2neg, k2: k22 };
      }
    }
  }, sha256);
  var _0n5 = BigInt(0);
  var fe = (x4) => typeof x4 === "bigint" && _0n5 < x4 && x4 < secp256k1P;
  var ge = (x4) => typeof x4 === "bigint" && _0n5 < x4 && x4 < secp256k1N;
  var TAGGED_HASH_PREFIXES = {};
  function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = sha256(Uint8Array.from(tag, (c4) => c4.charCodeAt(0)));
      tagP = concatBytes2(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return sha256(concatBytes2(tagP, ...messages));
  }
  var pointToBytes = (point) => point.toRawBytes(true).slice(1);
  var numTo32b = (n7) => numberToBytesBE(n7, 32);
  var modP = (x4) => mod(x4, secp256k1P);
  var modN = (x4) => mod(x4, secp256k1N);
  var Point = secp256k1.ProjectivePoint;
  var GmulAdd = (Q2, a3, b3) => Point.BASE.multiplyAndAddUnsafe(Q2, a3, b3);
  function schnorrGetExtPubKey(priv) {
    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
    let p4 = Point.fromPrivateKey(d_);
    const scalar = p4.hasEvenY() ? d_ : modN(-d_);
    return { scalar, bytes: pointToBytes(p4) };
  }
  function lift_x(x4) {
    if (!fe(x4))
      throw new Error("bad x: need 0 < x < p");
    const xx = modP(x4 * x4);
    const c4 = modP(xx * x4 + BigInt(7));
    let y4 = sqrtMod(c4);
    if (y4 % _2n4 !== _0n5)
      y4 = modP(-y4);
    const p4 = new Point(x4, y4, _1n5);
    p4.assertValidity();
    return p4;
  }
  function challenge(...args) {
    return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
  }
  function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes;
  }
  function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
    const m3 = ensureBytes("message", message);
    const { bytes: px, scalar: d4 } = schnorrGetExtPubKey(privateKey);
    const a3 = ensureBytes("auxRand", auxRand, 32);
    const t5 = numTo32b(d4 ^ bytesToNumberBE(taggedHash("BIP0340/aux", a3)));
    const rand = taggedHash("BIP0340/nonce", t5, px, m3);
    const k_ = modN(bytesToNumberBE(rand));
    if (k_ === _0n5)
      throw new Error("sign failed: k is zero");
    const { bytes: rx, scalar: k3 } = schnorrGetExtPubKey(k_);
    const e8 = challenge(rx, px, m3);
    const sig = new Uint8Array(64);
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k3 + e8 * d4)), 32);
    if (!schnorrVerify(sig, m3, px))
      throw new Error("sign: Invalid signature produced");
    return sig;
  }
  function schnorrVerify(signature, message, publicKey) {
    const sig = ensureBytes("signature", signature, 64);
    const m3 = ensureBytes("message", message);
    const pub = ensureBytes("publicKey", publicKey, 32);
    try {
      const P3 = lift_x(bytesToNumberBE(pub));
      const r4 = bytesToNumberBE(sig.subarray(0, 32));
      if (!fe(r4))
        return false;
      const s5 = bytesToNumberBE(sig.subarray(32, 64));
      if (!ge(s5))
        return false;
      const e8 = challenge(numTo32b(r4), pointToBytes(P3), m3);
      const R4 = GmulAdd(P3, s5, modN(-e8));
      if (!R4 || !R4.hasEvenY() || R4.toAffine().x !== r4)
        return false;
      return true;
    } catch (error) {
      return false;
    }
  }
  var schnorr = /* @__PURE__ */ (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
      randomPrivateKey: secp256k1.utils.randomPrivateKey,
      lift_x,
      pointToBytes,
      numberToBytesBE,
      bytesToNumberBE,
      taggedHash,
      mod
    }
  }))();

  // node_modules/@scure/base/lib/esm/index.js
  function assertNumber(n7) {
    if (!Number.isSafeInteger(n7))
      throw new Error(`Wrong integer: ${n7}`);
  }
  function chain(...args) {
    const wrap = (a3, b3) => (c4) => a3(b3(c4));
    const encode = Array.from(args).reverse().reduce((acc, i4) => acc ? wrap(acc, i4.encode) : i4.encode, void 0);
    const decode2 = args.reduce((acc, i4) => acc ? wrap(acc, i4.decode) : i4.decode, void 0);
    return { encode, decode: decode2 };
  }
  function alphabet(alphabet2) {
    return {
      encode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return digits.map((i4) => {
          assertNumber(i4);
          if (i4 < 0 || i4 >= alphabet2.length)
            throw new Error(`Digit index outside alphabet: ${i4} (alphabet: ${alphabet2.length})`);
          return alphabet2[i4];
        });
      },
      decode: (input) => {
        if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
          throw new Error("alphabet.decode input should be array of strings");
        return input.map((letter) => {
          if (typeof letter !== "string")
            throw new Error(`alphabet.decode: not string element=${letter}`);
          const index = alphabet2.indexOf(letter);
          if (index === -1)
            throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
          return index;
        });
      }
    };
  }
  function join(separator = "") {
    if (typeof separator !== "string")
      throw new Error("join separator should be string");
    return {
      encode: (from) => {
        if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
          throw new Error("join.encode input should be array of strings");
        for (let i4 of from)
          if (typeof i4 !== "string")
            throw new Error(`join.encode: non-string input=${i4}`);
        return from.join(separator);
      },
      decode: (to2) => {
        if (typeof to2 !== "string")
          throw new Error("join.decode input should be string");
        return to2.split(separator);
      }
    };
  }
  function padding(bits, chr = "=") {
    assertNumber(bits);
    if (typeof chr !== "string")
      throw new Error("padding chr should be string");
    return {
      encode(data) {
        if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
          throw new Error("padding.encode input should be array of strings");
        for (let i4 of data)
          if (typeof i4 !== "string")
            throw new Error(`padding.encode: non-string input=${i4}`);
        while (data.length * bits % 8)
          data.push(chr);
        return data;
      },
      decode(input) {
        if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
          throw new Error("padding.encode input should be array of strings");
        for (let i4 of input)
          if (typeof i4 !== "string")
            throw new Error(`padding.decode: non-string input=${i4}`);
        let end = input.length;
        if (end * bits % 8)
          throw new Error("Invalid padding: string should have whole number of bytes");
        for (; end > 0 && input[end - 1] === chr; end--) {
          if (!((end - 1) * bits % 8))
            throw new Error("Invalid padding: string has too much padding");
        }
        return input.slice(0, end);
      }
    };
  }
  function normalize(fn) {
    if (typeof fn !== "function")
      throw new Error("normalize fn should be function");
    return { encode: (from) => from, decode: (to2) => fn(to2) };
  }
  function convertRadix(data, from, to2) {
    if (from < 2)
      throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
    if (to2 < 2)
      throw new Error(`convertRadix: wrong to=${to2}, base cannot be less than 2`);
    if (!Array.isArray(data))
      throw new Error("convertRadix: data should be array");
    if (!data.length)
      return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data);
    digits.forEach((d4) => {
      assertNumber(d4);
      if (d4 < 0 || d4 >= from)
        throw new Error(`Wrong integer: ${d4}`);
    });
    while (true) {
      let carry = 0;
      let done = true;
      for (let i4 = pos; i4 < digits.length; i4++) {
        const digit = digits[i4];
        const digitBase = from * carry + digit;
        if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
          throw new Error("convertRadix: carry overflow");
        }
        carry = digitBase % to2;
        digits[i4] = Math.floor(digitBase / to2);
        if (!Number.isSafeInteger(digits[i4]) || digits[i4] * to2 + carry !== digitBase)
          throw new Error("convertRadix: carry overflow");
        if (!done)
          continue;
        else if (!digits[i4])
          pos = i4;
        else
          done = false;
      }
      res.push(carry);
      if (done)
        break;
    }
    for (let i4 = 0; i4 < data.length - 1 && data[i4] === 0; i4++)
      res.push(0);
    return res.reverse();
  }
  var gcd = (a3, b3) => !b3 ? a3 : gcd(b3, a3 % b3);
  var radix2carry = (from, to2) => from + (to2 - gcd(from, to2));
  function convertRadix2(data, from, to2, padding2) {
    if (!Array.isArray(data))
      throw new Error("convertRadix2: data should be array");
    if (from <= 0 || from > 32)
      throw new Error(`convertRadix2: wrong from=${from}`);
    if (to2 <= 0 || to2 > 32)
      throw new Error(`convertRadix2: wrong to=${to2}`);
    if (radix2carry(from, to2) > 32) {
      throw new Error(`convertRadix2: carry overflow from=${from} to=${to2} carryBits=${radix2carry(from, to2)}`);
    }
    let carry = 0;
    let pos = 0;
    const mask = 2 ** to2 - 1;
    const res = [];
    for (const n7 of data) {
      assertNumber(n7);
      if (n7 >= 2 ** from)
        throw new Error(`convertRadix2: invalid data word=${n7} from=${from}`);
      carry = carry << from | n7;
      if (pos + from > 32)
        throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
      pos += from;
      for (; pos >= to2; pos -= to2)
        res.push((carry >> pos - to2 & mask) >>> 0);
      carry &= 2 ** pos - 1;
    }
    carry = carry << to2 - pos & mask;
    if (!padding2 && pos >= from)
      throw new Error("Excess padding");
    if (!padding2 && carry)
      throw new Error(`Non-zero padding: ${carry}`);
    if (padding2 && pos > 0)
      res.push(carry >>> 0);
    return res;
  }
  function radix(num) {
    assertNumber(num);
    return {
      encode: (bytes2) => {
        if (!(bytes2 instanceof Uint8Array))
          throw new Error("radix.encode input should be Uint8Array");
        return convertRadix(Array.from(bytes2), 2 ** 8, num);
      },
      decode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("radix.decode input should be array of strings");
        return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
      }
    };
  }
  function radix2(bits, revPadding = false) {
    assertNumber(bits);
    if (bits <= 0 || bits > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (bytes2) => {
        if (!(bytes2 instanceof Uint8Array))
          throw new Error("radix2.encode input should be Uint8Array");
        return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
      },
      decode: (digits) => {
        if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
          throw new Error("radix2.decode input should be array of strings");
        return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
      }
    };
  }
  function unsafeWrapper(fn) {
    if (typeof fn !== "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...args) {
      try {
        return fn.apply(null, args);
      } catch (e8) {
      }
    };
  }
  function checksum(len, fn) {
    assertNumber(len);
    if (typeof fn !== "function")
      throw new Error("checksum fn should be function");
    return {
      encode(data) {
        if (!(data instanceof Uint8Array))
          throw new Error("checksum.encode: input should be Uint8Array");
        const checksum2 = fn(data).slice(0, len);
        const res = new Uint8Array(data.length + len);
        res.set(data);
        res.set(checksum2, data.length);
        return res;
      },
      decode(data) {
        if (!(data instanceof Uint8Array))
          throw new Error("checksum.decode: input should be Uint8Array");
        const payload = data.slice(0, -len);
        const newChecksum = fn(payload).slice(0, len);
        const oldChecksum = data.slice(-len);
        for (let i4 = 0; i4 < len; i4++)
          if (newChecksum[i4] !== oldChecksum[i4])
            throw new Error("Invalid checksum");
        return payload;
      }
    };
  }
  var utils = { alphabet, chain, checksum, radix, radix2, join, padding };
  var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
  var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
  var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
  var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s5) => s5.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
  var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
  var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
  var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
  var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
  var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
  var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  var base58xmr = {
    encode(data) {
      let res = "";
      for (let i4 = 0; i4 < data.length; i4 += 8) {
        const block = data.subarray(i4, i4 + 8);
        res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
      }
      return res;
    },
    decode(str) {
      let res = [];
      for (let i4 = 0; i4 < str.length; i4 += 11) {
        const slice = str.slice(i4, i4 + 11);
        const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
        const block = base58.decode(slice);
        for (let j2 = 0; j2 < block.length - blockLen; j2++) {
          if (block[j2] !== 0)
            throw new Error("base58xmr: wrong padding");
        }
        res = res.concat(Array.from(block.slice(block.length - blockLen)));
      }
      return Uint8Array.from(res);
    }
  };
  var base58check = (sha2562) => chain(checksum(4, (data) => sha2562(sha2562(data))), base58);
  var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
  var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function bech32Polymod(pre) {
    const b3 = pre >> 25;
    let chk = (pre & 33554431) << 5;
    for (let i4 = 0; i4 < POLYMOD_GENERATORS.length; i4++) {
      if ((b3 >> i4 & 1) === 1)
        chk ^= POLYMOD_GENERATORS[i4];
    }
    return chk;
  }
  function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for (let i4 = 0; i4 < len; i4++) {
      const c4 = prefix.charCodeAt(i4);
      if (c4 < 33 || c4 > 126)
        throw new Error(`Invalid prefix (${prefix})`);
      chk = bech32Polymod(chk) ^ c4 >> 5;
    }
    chk = bech32Polymod(chk);
    for (let i4 = 0; i4 < len; i4++)
      chk = bech32Polymod(chk) ^ prefix.charCodeAt(i4) & 31;
    for (let v4 of words)
      chk = bech32Polymod(chk) ^ v4;
    for (let i4 = 0; i4 < 6; i4++)
      chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
  }
  function genBech32(encoding) {
    const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
      if (typeof prefix !== "string")
        throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
      if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
        throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
      const actualLength = prefix.length + 7 + words.length;
      if (limit !== false && actualLength > limit)
        throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
      prefix = prefix.toLowerCase();
      return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;
    }
    function decode2(str, limit = 90) {
      if (typeof str !== "string")
        throw new Error(`bech32.decode input should be string, not ${typeof str}`);
      if (str.length < 8 || limit !== false && str.length > limit)
        throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
      const lowered = str.toLowerCase();
      if (str !== lowered && str !== str.toUpperCase())
        throw new Error(`String must be lowercase or uppercase`);
      str = lowered;
      const sepIndex = str.lastIndexOf("1");
      if (sepIndex === 0 || sepIndex === -1)
        throw new Error(`Letter "1" must be present between prefix and data only`);
      const prefix = str.slice(0, sepIndex);
      const _words2 = str.slice(sepIndex + 1);
      if (_words2.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
      const sum = bechChecksum(prefix, words, ENCODING_CONST);
      if (!_words2.endsWith(sum))
        throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
      return { prefix, words };
    }
    const decodeUnsafe = unsafeWrapper(decode2);
    function decodeToBytes(str) {
      const { prefix, words } = decode2(str, false);
      return { prefix, words, bytes: fromWords(words) };
    }
    return { encode, decode: decode2, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
  }
  var bech32 = genBech32("bech32");
  var bech32m = genBech32("bech32m");
  var utf8 = {
    encode: (data) => new TextDecoder().decode(data),
    decode: (str) => new TextEncoder().encode(str)
  };
  var hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s5) => {
    if (typeof s5 !== "string" || s5.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof s5} with length ${s5.length}`);
    return s5.toLowerCase();
  }));
  var CODERS = {
    utf8,
    hex,
    base16,
    base32,
    base64,
    base64url,
    base58,
    base58xmr
  };
  var coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`;

  // node_modules/@scure/bip39/esm/wordlists/english.js
  var wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");

  // node_modules/@noble/hashes/esm/pbkdf2.js
  function pbkdf2Init(hash2, _password, _salt, _opts) {
    assert_default.hash(hash2);
    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c: c4, dkLen, asyncTick } = opts;
    assert_default.number(c4);
    assert_default.number(dkLen);
    assert_default.number(asyncTick);
    if (c4 < 1)
      throw new Error("PBKDF2: iterations (c) should be >= 1");
    const password = toBytes(_password);
    const salt2 = toBytes(_salt);
    const DK = new Uint8Array(dkLen);
    const PRF = hmac.create(hash2, password);
    const PRFSalt = PRF._cloneInto().update(salt2);
    return { c: c4, dkLen, asyncTick, DK, PRF, PRFSalt };
  }
  function pbkdf2Output(PRF, PRFSalt, DK, prfW, u5) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
      prfW.destroy();
    u5.fill(0);
    return DK;
  }
  function pbkdf2(hash2, password, salt2, opts) {
    const { c: c4, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt2, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = createView(arr);
    const u5 = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u5);
      Ti.set(u5.subarray(0, Ti.length));
      for (let ui = 1; ui < c4; ui++) {
        PRF._cloneInto(prfW).update(u5).digestInto(u5);
        for (let i4 = 0; i4 < Ti.length; i4++)
          Ti[i4] ^= u5[i4];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u5);
  }

  // node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK64 = BigInt(2 ** 32 - 1);
  var _32n = BigInt(32);
  function fromBig(n7, le2 = false) {
    if (le2)
      return { h: Number(n7 & U32_MASK64), l: Number(n7 >> _32n & U32_MASK64) };
    return { h: Number(n7 >> _32n & U32_MASK64) | 0, l: Number(n7 & U32_MASK64) | 0 };
  }
  function split(lst, le2 = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i4 = 0; i4 < lst.length; i4++) {
      const { h: h5, l: l6 } = fromBig(lst[i4], le2);
      [Ah[i4], Al[i4]] = [h5, l6];
    }
    return [Ah, Al];
  }
  var toBig = (h5, l6) => BigInt(h5 >>> 0) << _32n | BigInt(l6 >>> 0);
  var shrSH = (h5, l6, s5) => h5 >>> s5;
  var shrSL = (h5, l6, s5) => h5 << 32 - s5 | l6 >>> s5;
  var rotrSH = (h5, l6, s5) => h5 >>> s5 | l6 << 32 - s5;
  var rotrSL = (h5, l6, s5) => h5 << 32 - s5 | l6 >>> s5;
  var rotrBH = (h5, l6, s5) => h5 << 64 - s5 | l6 >>> s5 - 32;
  var rotrBL = (h5, l6, s5) => h5 >>> s5 - 32 | l6 << 64 - s5;
  var rotr32H = (h5, l6) => l6;
  var rotr32L = (h5, l6) => h5;
  var rotlSH = (h5, l6, s5) => h5 << s5 | l6 >>> 32 - s5;
  var rotlSL = (h5, l6, s5) => l6 << s5 | h5 >>> 32 - s5;
  var rotlBH = (h5, l6, s5) => l6 << s5 - 32 | h5 >>> 64 - s5;
  var rotlBL = (h5, l6, s5) => h5 << s5 - 32 | l6 >>> 64 - s5;
  function add(Ah, Al, Bh, Bl) {
    const l6 = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l6 / 2 ** 32 | 0) | 0, l: l6 | 0 };
  }
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  var u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  var u64_default = u64;

  // node_modules/@noble/hashes/esm/sha512.js
  var [SHA512_Kh, SHA512_Kl] = u64_default.split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n7) => BigInt(n7)));
  var SHA512_W_H = new Uint32Array(80);
  var SHA512_W_L = new Uint32Array(80);
  var SHA512 = class extends SHA2 {
    constructor() {
      super(128, 64, 16, false);
      this.Ah = 1779033703 | 0;
      this.Al = 4089235720 | 0;
      this.Bh = 3144134277 | 0;
      this.Bl = 2227873595 | 0;
      this.Ch = 1013904242 | 0;
      this.Cl = 4271175723 | 0;
      this.Dh = 2773480762 | 0;
      this.Dl = 1595750129 | 0;
      this.Eh = 1359893119 | 0;
      this.El = 2917565137 | 0;
      this.Fh = 2600822924 | 0;
      this.Fl = 725511199 | 0;
      this.Gh = 528734635 | 0;
      this.Gl = 4215389547 | 0;
      this.Hh = 1541459225 | 0;
      this.Hl = 327033209 | 0;
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i4 = 0; i4 < 16; i4++, offset += 4) {
        SHA512_W_H[i4] = view.getUint32(offset);
        SHA512_W_L[i4] = view.getUint32(offset += 4);
      }
      for (let i4 = 16; i4 < 80; i4++) {
        const W15h = SHA512_W_H[i4 - 15] | 0;
        const W15l = SHA512_W_L[i4 - 15] | 0;
        const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
        const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i4 - 2] | 0;
        const W2l = SHA512_W_L[i4 - 2] | 0;
        const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
        const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
        const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i4 - 7], SHA512_W_L[i4 - 16]);
        const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i4 - 7], SHA512_W_H[i4 - 16]);
        SHA512_W_H[i4] = SUMh | 0;
        SHA512_W_L[i4] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i4 = 0; i4 < 80; i4++) {
        const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
        const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i4], SHA512_W_L[i4]);
        const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i4], SHA512_W_H[i4]);
        const T1l = T1ll | 0;
        const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
        const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = u64_default.add3L(T1l, sigma0l, MAJl);
        Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      SHA512_W_H.fill(0);
      SHA512_W_L.fill(0);
    }
    destroy() {
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var SHA512_224 = class extends SHA512 {
    constructor() {
      super();
      this.Ah = 2352822216 | 0;
      this.Al = 424955298 | 0;
      this.Bh = 1944164710 | 0;
      this.Bl = 2312950998 | 0;
      this.Ch = 502970286 | 0;
      this.Cl = 855612546 | 0;
      this.Dh = 1738396948 | 0;
      this.Dl = 1479516111 | 0;
      this.Eh = 258812777 | 0;
      this.El = 2077511080 | 0;
      this.Fh = 2011393907 | 0;
      this.Fl = 79989058 | 0;
      this.Gh = 1067287976 | 0;
      this.Gl = 1780299464 | 0;
      this.Hh = 286451373 | 0;
      this.Hl = 2446758561 | 0;
      this.outputLen = 28;
    }
  };
  var SHA512_256 = class extends SHA512 {
    constructor() {
      super();
      this.Ah = 573645204 | 0;
      this.Al = 4230739756 | 0;
      this.Bh = 2673172387 | 0;
      this.Bl = 3360449730 | 0;
      this.Ch = 596883563 | 0;
      this.Cl = 1867755857 | 0;
      this.Dh = 2520282905 | 0;
      this.Dl = 1497426621 | 0;
      this.Eh = 2519219938 | 0;
      this.El = 2827943907 | 0;
      this.Fh = 3193839141 | 0;
      this.Fl = 1401305490 | 0;
      this.Gh = 721525244 | 0;
      this.Gl = 746961066 | 0;
      this.Hh = 246885852 | 0;
      this.Hl = 2177182882 | 0;
      this.outputLen = 32;
    }
  };
  var SHA384 = class extends SHA512 {
    constructor() {
      super();
      this.Ah = 3418070365 | 0;
      this.Al = 3238371032 | 0;
      this.Bh = 1654270250 | 0;
      this.Bl = 914150663 | 0;
      this.Ch = 2438529370 | 0;
      this.Cl = 812702999 | 0;
      this.Dh = 355462360 | 0;
      this.Dl = 4144912697 | 0;
      this.Eh = 1731405415 | 0;
      this.El = 4290775857 | 0;
      this.Fh = 2394180231 | 0;
      this.Fl = 1750603025 | 0;
      this.Gh = 3675008525 | 0;
      this.Gl = 1694076839 | 0;
      this.Hh = 1203062813 | 0;
      this.Hl = 3204075428 | 0;
      this.outputLen = 48;
    }
  };
  var sha512 = wrapConstructor(() => new SHA512());
  var sha512_224 = wrapConstructor(() => new SHA512_224());
  var sha512_256 = wrapConstructor(() => new SHA512_256());
  var sha384 = wrapConstructor(() => new SHA384());

  // node_modules/@scure/bip39/esm/index.js
  var isJapanese = (wordlist2) => wordlist2[0] === "\u3042\u3044\u3053\u304F\u3057\u3093";
  function nfkd(str) {
    if (typeof str !== "string")
      throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
    return str.normalize("NFKD");
  }
  function normalize2(str) {
    const norm = nfkd(str);
    const words = norm.split(" ");
    if (![12, 15, 18, 21, 24].includes(words.length))
      throw new Error("Invalid mnemonic");
    return { nfkd: norm, words };
  }
  function assertEntropy(entropy) {
    assert_default.bytes(entropy, 16, 20, 24, 28, 32);
  }
  function generateMnemonic(wordlist2, strength = 128) {
    assert_default.number(strength);
    if (strength % 32 !== 0 || strength > 256)
      throw new TypeError("Invalid entropy");
    return entropyToMnemonic(randomBytes(strength / 8), wordlist2);
  }
  var calcChecksum = (entropy) => {
    const bitsLeft = 8 - entropy.length / 4;
    return new Uint8Array([sha256(entropy)[0] >> bitsLeft << bitsLeft]);
  };
  function getCoder(wordlist2) {
    if (!Array.isArray(wordlist2) || wordlist2.length !== 2048 || typeof wordlist2[0] !== "string")
      throw new Error("Worlist: expected array of 2048 strings");
    wordlist2.forEach((i4) => {
      if (typeof i4 !== "string")
        throw new Error(`Wordlist: non-string element: ${i4}`);
    });
    return utils.chain(utils.checksum(1, calcChecksum), utils.radix2(11, true), utils.alphabet(wordlist2));
  }
  function mnemonicToEntropy(mnemonic, wordlist2) {
    const { words } = normalize2(mnemonic);
    const entropy = getCoder(wordlist2).decode(words);
    assertEntropy(entropy);
    return entropy;
  }
  function entropyToMnemonic(entropy, wordlist2) {
    assertEntropy(entropy);
    const words = getCoder(wordlist2).encode(entropy);
    return words.join(isJapanese(wordlist2) ? "\u3000" : " ");
  }
  function validateMnemonic(mnemonic, wordlist2) {
    try {
      mnemonicToEntropy(mnemonic, wordlist2);
    } catch (e8) {
      return false;
    }
    return true;
  }
  var salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
  function mnemonicToSeedSync(mnemonic, passphrase = "") {
    return pbkdf2(sha512, normalize2(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
  }

  // node_modules/@noble/hashes/esm/ripemd160.js
  var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
  var Id = Uint8Array.from({ length: 16 }, (_3, i4) => i4);
  var Pi = Id.map((i4) => (9 * i4 + 5) % 16);
  var idxL = [Id];
  var idxR = [Pi];
  for (let i4 = 0; i4 < 4; i4++)
    for (let j2 of [idxL, idxR])
      j2.push(j2[i4].map((k3) => Rho[k3]));
  var shifts = [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
  ].map((i4) => new Uint8Array(i4));
  var shiftsL = idxL.map((idx, i4) => idx.map((j2) => shifts[i4][j2]));
  var shiftsR = idxR.map((idx, i4) => idx.map((j2) => shifts[i4][j2]));
  var Kl = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
  var Kr = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
  var rotl = (word, shift) => word << shift | word >>> 32 - shift;
  function f2(group, x4, y4, z3) {
    if (group === 0)
      return x4 ^ y4 ^ z3;
    else if (group === 1)
      return x4 & y4 | ~x4 & z3;
    else if (group === 2)
      return (x4 | ~y4) ^ z3;
    else if (group === 3)
      return x4 & z3 | y4 & ~z3;
    else
      return x4 ^ (y4 | ~z3);
  }
  var BUF = new Uint32Array(16);
  var RIPEMD160 = class extends SHA2 {
    constructor() {
      super(64, 20, 8, true);
      this.h0 = 1732584193 | 0;
      this.h1 = 4023233417 | 0;
      this.h2 = 2562383102 | 0;
      this.h3 = 271733878 | 0;
      this.h4 = 3285377520 | 0;
    }
    get() {
      const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
      return [h0, h1, h22, h32, h42];
    }
    set(h0, h1, h22, h32, h42) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h22 | 0;
      this.h3 = h32 | 0;
      this.h4 = h42 | 0;
    }
    process(view, offset) {
      for (let i4 = 0; i4 < 16; i4++, offset += 4)
        BUF[i4] = view.getUint32(offset, true);
      let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
      for (let group = 0; group < 5; group++) {
        const rGroup = 4 - group;
        const hbl = Kl[group], hbr = Kr[group];
        const rl = idxL[group], rr = idxR[group];
        const sl = shiftsL[group], sr = shiftsR[group];
        for (let i4 = 0; i4 < 16; i4++) {
          const tl = rotl(al + f2(group, bl, cl, dl) + BUF[rl[i4]] + hbl, sl[i4]) + el | 0;
          al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
        }
        for (let i4 = 0; i4 < 16; i4++) {
          const tr = rotl(ar + f2(rGroup, br, cr, dr) + BUF[rr[i4]] + hbr, sr[i4]) + er | 0;
          ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
        }
      }
      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
    roundClean() {
      BUF.fill(0);
    }
    destroy() {
      this.destroyed = true;
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0);
    }
  };
  var ripemd160 = wrapConstructor(() => new RIPEMD160());

  // node_modules/@scure/bip32/lib/esm/index.js
  var Point2 = secp256k1.ProjectivePoint;
  var base58check2 = base58check(sha256);
  function bytesToNumber(bytes2) {
    return BigInt(`0x${bytesToHex(bytes2)}`);
  }
  function numberToBytes(num) {
    return hexToBytes(num.toString(16).padStart(64, "0"));
  }
  var MASTER_SECRET = utf8ToBytes("Bitcoin seed");
  var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
  var HARDENED_OFFSET = 2147483648;
  var hash160 = (data) => ripemd160(sha256(data));
  var fromU32 = (data) => createView(data).getUint32(0, false);
  var toU32 = (n7) => {
    if (!Number.isSafeInteger(n7) || n7 < 0 || n7 > 2 ** 32 - 1) {
      throw new Error(`Invalid number=${n7}. Should be from 0 to 2 ** 32 - 1`);
    }
    const buf = new Uint8Array(4);
    createView(buf).setUint32(0, n7, false);
    return buf;
  };
  var HDKey = class _HDKey {
    get fingerprint() {
      if (!this.pubHash) {
        throw new Error("No publicKey set!");
      }
      return fromU32(this.pubHash);
    }
    get identifier() {
      return this.pubHash;
    }
    get pubKeyHash() {
      return this.pubHash;
    }
    get privateKey() {
      return this.privKeyBytes || null;
    }
    get publicKey() {
      return this.pubKey || null;
    }
    get privateExtendedKey() {
      const priv = this.privateKey;
      if (!priv) {
        throw new Error("No private key");
      }
      return base58check2.encode(this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv)));
    }
    get publicExtendedKey() {
      if (!this.pubKey) {
        throw new Error("No public key");
      }
      return base58check2.encode(this.serialize(this.versions.public, this.pubKey));
    }
    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
      bytes(seed);
      if (8 * seed.length < 128 || 8 * seed.length > 512) {
        throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
      }
      const I3 = hmac(sha512, MASTER_SECRET, seed);
      return new _HDKey({
        versions,
        chainCode: I3.slice(32),
        privateKey: I3.slice(0, 32)
      });
    }
    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
      const keyBuffer = base58check2.decode(base58key);
      const keyView = createView(keyBuffer);
      const version = keyView.getUint32(0, false);
      const opt = {
        versions,
        depth: keyBuffer[4],
        parentFingerprint: keyView.getUint32(5, false),
        index: keyView.getUint32(9, false),
        chainCode: keyBuffer.slice(13, 45)
      };
      const key = keyBuffer.slice(45);
      const isPriv = key[0] === 0;
      if (version !== versions[isPriv ? "private" : "public"]) {
        throw new Error("Version mismatch");
      }
      if (isPriv) {
        return new _HDKey({ ...opt, privateKey: key.slice(1) });
      } else {
        return new _HDKey({ ...opt, publicKey: key });
      }
    }
    static fromJSON(json) {
      return _HDKey.fromExtendedKey(json.xpriv);
    }
    constructor(opt) {
      this.depth = 0;
      this.index = 0;
      this.chainCode = null;
      this.parentFingerprint = 0;
      if (!opt || typeof opt !== "object") {
        throw new Error("HDKey.constructor must not be called directly");
      }
      this.versions = opt.versions || BITCOIN_VERSIONS;
      this.depth = opt.depth || 0;
      this.chainCode = opt.chainCode;
      this.index = opt.index || 0;
      this.parentFingerprint = opt.parentFingerprint || 0;
      if (!this.depth) {
        if (this.parentFingerprint || this.index) {
          throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
        }
      }
      if (opt.publicKey && opt.privateKey) {
        throw new Error("HDKey: publicKey and privateKey at same time.");
      }
      if (opt.privateKey) {
        if (!secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
          throw new Error("Invalid private key");
        }
        this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
        this.privKeyBytes = numberToBytes(this.privKey);
        this.pubKey = secp256k1.getPublicKey(opt.privateKey, true);
      } else if (opt.publicKey) {
        this.pubKey = Point2.fromHex(opt.publicKey).toRawBytes(true);
      } else {
        throw new Error("HDKey: no public or private key provided");
      }
      this.pubHash = hash160(this.pubKey);
    }
    derive(path) {
      if (!/^[mM]'?/.test(path)) {
        throw new Error('Path must start with "m" or "M"');
      }
      if (/^[mM]'?$/.test(path)) {
        return this;
      }
      const parts = path.replace(/^[mM]'?\//, "").split("/");
      let child = this;
      for (const c4 of parts) {
        const m3 = /^(\d+)('?)$/.exec(c4);
        if (!m3 || m3.length !== 3) {
          throw new Error(`Invalid child index: ${c4}`);
        }
        let idx = +m3[1];
        if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {
          throw new Error("Invalid index");
        }
        if (m3[2] === "'") {
          idx += HARDENED_OFFSET;
        }
        child = child.deriveChild(idx);
      }
      return child;
    }
    deriveChild(index) {
      if (!this.pubKey || !this.chainCode) {
        throw new Error("No publicKey or chainCode set");
      }
      let data = toU32(index);
      if (index >= HARDENED_OFFSET) {
        const priv = this.privateKey;
        if (!priv) {
          throw new Error("Could not derive hardened child key");
        }
        data = concatBytes(new Uint8Array([0]), priv, data);
      } else {
        data = concatBytes(this.pubKey, data);
      }
      const I3 = hmac(sha512, this.chainCode, data);
      const childTweak = bytesToNumber(I3.slice(0, 32));
      const chainCode = I3.slice(32);
      if (!secp256k1.utils.isValidPrivateKey(childTweak)) {
        throw new Error("Tweak bigger than curve order");
      }
      const opt = {
        versions: this.versions,
        chainCode,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint,
        index
      };
      try {
        if (this.privateKey) {
          const added = mod(this.privKey + childTweak, secp256k1.CURVE.n);
          if (!secp256k1.utils.isValidPrivateKey(added)) {
            throw new Error("The tweak was out of range or the resulted private key is invalid");
          }
          opt.privateKey = added;
        } else {
          const added = Point2.fromHex(this.pubKey).add(Point2.fromPrivateKey(childTweak));
          if (added.equals(Point2.ZERO)) {
            throw new Error("The tweak was equal to negative P, which made the result key invalid");
          }
          opt.publicKey = added.toRawBytes(true);
        }
        return new _HDKey(opt);
      } catch (err) {
        return this.deriveChild(index + 1);
      }
    }
    sign(hash2) {
      if (!this.privateKey) {
        throw new Error("No privateKey set!");
      }
      bytes(hash2, 32);
      return secp256k1.sign(hash2, this.privKey).toCompactRawBytes();
    }
    verify(hash2, signature) {
      bytes(hash2, 32);
      bytes(signature, 64);
      if (!this.publicKey) {
        throw new Error("No publicKey set!");
      }
      let sig;
      try {
        sig = secp256k1.Signature.fromCompact(signature);
      } catch (error) {
        return false;
      }
      return secp256k1.verify(sig, hash2, this.publicKey);
    }
    wipePrivateData() {
      this.privKey = void 0;
      if (this.privKeyBytes) {
        this.privKeyBytes.fill(0);
        this.privKeyBytes = void 0;
      }
      return this;
    }
    toJSON() {
      return {
        xpriv: this.privateExtendedKey,
        xpub: this.publicExtendedKey
      };
    }
    serialize(version, key) {
      if (!this.chainCode) {
        throw new Error("No chainCode set");
      }
      bytes(key, 33);
      return concatBytes(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
    }
  };

  // node_modules/nostr-tools/lib/esm/nostr.mjs
  var __defProp2 = Object.defineProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  function generatePrivateKey() {
    return bytesToHex(schnorr.utils.randomPrivateKey());
  }
  function getPublicKey(privateKey) {
    return bytesToHex(schnorr.getPublicKey(privateKey));
  }
  var utils_exports2 = {};
  __export2(utils_exports2, {
    MessageNode: () => MessageNode,
    MessageQueue: () => MessageQueue,
    insertEventIntoAscendingList: () => insertEventIntoAscendingList,
    insertEventIntoDescendingList: () => insertEventIntoDescendingList,
    normalizeURL: () => normalizeURL,
    utf8Decoder: () => utf8Decoder,
    utf8Encoder: () => utf8Encoder
  });
  var utf8Decoder = new TextDecoder("utf-8");
  var utf8Encoder = new TextEncoder();
  function normalizeURL(url) {
    let p4 = new URL(url);
    p4.pathname = p4.pathname.replace(/\/+/g, "/");
    if (p4.pathname.endsWith("/"))
      p4.pathname = p4.pathname.slice(0, -1);
    if (p4.port === "80" && p4.protocol === "ws:" || p4.port === "443" && p4.protocol === "wss:")
      p4.port = "";
    p4.searchParams.sort();
    p4.hash = "";
    return p4.toString();
  }
  function insertEventIntoDescendingList(sortedArray, event) {
    let start = 0;
    let end = sortedArray.length - 1;
    let midPoint;
    let position = start;
    if (end < 0) {
      position = 0;
    } else if (event.created_at < sortedArray[end].created_at) {
      position = end + 1;
    } else if (event.created_at >= sortedArray[start].created_at) {
      position = start;
    } else
      while (true) {
        if (end <= start + 1) {
          position = end;
          break;
        }
        midPoint = Math.floor(start + (end - start) / 2);
        if (sortedArray[midPoint].created_at > event.created_at) {
          start = midPoint;
        } else if (sortedArray[midPoint].created_at < event.created_at) {
          end = midPoint;
        } else {
          position = midPoint;
          break;
        }
      }
    if (sortedArray[position]?.id !== event.id) {
      return [
        ...sortedArray.slice(0, position),
        event,
        ...sortedArray.slice(position)
      ];
    }
    return sortedArray;
  }
  function insertEventIntoAscendingList(sortedArray, event) {
    let start = 0;
    let end = sortedArray.length - 1;
    let midPoint;
    let position = start;
    if (end < 0) {
      position = 0;
    } else if (event.created_at > sortedArray[end].created_at) {
      position = end + 1;
    } else if (event.created_at <= sortedArray[start].created_at) {
      position = start;
    } else
      while (true) {
        if (end <= start + 1) {
          position = end;
          break;
        }
        midPoint = Math.floor(start + (end - start) / 2);
        if (sortedArray[midPoint].created_at < event.created_at) {
          start = midPoint;
        } else if (sortedArray[midPoint].created_at > event.created_at) {
          end = midPoint;
        } else {
          position = midPoint;
          break;
        }
      }
    if (sortedArray[position]?.id !== event.id) {
      return [
        ...sortedArray.slice(0, position),
        event,
        ...sortedArray.slice(position)
      ];
    }
    return sortedArray;
  }
  var MessageNode = class {
    _value;
    _next;
    get value() {
      return this._value;
    }
    set value(message) {
      this._value = message;
    }
    get next() {
      return this._next;
    }
    set next(node) {
      this._next = node;
    }
    constructor(message) {
      this._value = message;
      this._next = null;
    }
  };
  var MessageQueue = class {
    _first;
    _last;
    get first() {
      return this._first;
    }
    set first(messageNode) {
      this._first = messageNode;
    }
    get last() {
      return this._last;
    }
    set last(messageNode) {
      this._last = messageNode;
    }
    _size;
    get size() {
      return this._size;
    }
    set size(v4) {
      this._size = v4;
    }
    constructor() {
      this._first = null;
      this._last = null;
      this._size = 0;
    }
    enqueue(message) {
      const newNode = new MessageNode(message);
      if (this._size === 0 || !this._last) {
        this._first = newNode;
        this._last = newNode;
      } else {
        this._last.next = newNode;
        this._last = newNode;
      }
      this._size++;
      return true;
    }
    dequeue() {
      if (this._size === 0 || !this._first)
        return null;
      let prev = this._first;
      this._first = prev.next;
      prev.next = null;
      this._size--;
      return prev.value;
    }
  };
  function getBlankEvent(kind = 255) {
    return {
      kind,
      content: "",
      tags: [],
      created_at: 0
    };
  }
  function finishEvent(t5, privateKey) {
    let event = t5;
    event.pubkey = getPublicKey(privateKey);
    event.id = getEventHash(event);
    event.sig = getSignature(event, privateKey);
    return event;
  }
  function serializeEvent(evt) {
    if (!validateEvent(evt))
      throw new Error("can't serialize event with wrong or missing properties");
    return JSON.stringify([
      0,
      evt.pubkey,
      evt.created_at,
      evt.kind,
      evt.tags,
      evt.content
    ]);
  }
  function getEventHash(event) {
    let eventHash = sha256(utf8Encoder.encode(serializeEvent(event)));
    return bytesToHex(eventHash);
  }
  var isRecord = (obj) => obj instanceof Object;
  function validateEvent(event) {
    if (!isRecord(event))
      return false;
    if (typeof event.kind !== "number")
      return false;
    if (typeof event.content !== "string")
      return false;
    if (typeof event.created_at !== "number")
      return false;
    if (typeof event.pubkey !== "string")
      return false;
    if (!event.pubkey.match(/^[a-f0-9]{64}$/))
      return false;
    if (!Array.isArray(event.tags))
      return false;
    for (let i4 = 0; i4 < event.tags.length; i4++) {
      let tag = event.tags[i4];
      if (!Array.isArray(tag))
        return false;
      for (let j2 = 0; j2 < tag.length; j2++) {
        if (typeof tag[j2] === "object")
          return false;
      }
    }
    return true;
  }
  function verifySignature(event) {
    try {
      return schnorr.verify(event.sig, getEventHash(event), event.pubkey);
    } catch (err) {
      return false;
    }
  }
  function getSignature(event, key) {
    return bytesToHex(schnorr.sign(getEventHash(event), key));
  }
  function matchFilter(filter, event) {
    if (filter.ids && filter.ids.indexOf(event.id) === -1) {
      if (!filter.ids.some((prefix) => event.id.startsWith(prefix))) {
        return false;
      }
    }
    if (filter.kinds && filter.kinds.indexOf(event.kind) === -1)
      return false;
    if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {
      if (!filter.authors.some((prefix) => event.pubkey.startsWith(prefix))) {
        return false;
      }
    }
    for (let f5 in filter) {
      if (f5[0] === "#") {
        let tagName = f5.slice(1);
        let values = filter[`#${tagName}`];
        if (values && !event.tags.find(
          ([t5, v4]) => t5 === f5.slice(1) && values.indexOf(v4) !== -1
        ))
          return false;
      }
    }
    if (filter.since && event.created_at < filter.since)
      return false;
    if (filter.until && event.created_at > filter.until)
      return false;
    return true;
  }
  function matchFilters(filters, event) {
    for (let i4 = 0; i4 < filters.length; i4++) {
      if (matchFilter(filters[i4], event))
        return true;
    }
    return false;
  }
  var fakejson_exports = {};
  __export2(fakejson_exports, {
    getHex64: () => getHex64,
    getInt: () => getInt,
    getSubscriptionId: () => getSubscriptionId,
    matchEventId: () => matchEventId,
    matchEventKind: () => matchEventKind,
    matchEventPubkey: () => matchEventPubkey
  });
  function getHex64(json, field) {
    let len = field.length + 3;
    let idx = json.indexOf(`"${field}":`) + len;
    let s5 = json.slice(idx).indexOf(`"`) + idx + 1;
    return json.slice(s5, s5 + 64);
  }
  function getInt(json, field) {
    let len = field.length;
    let idx = json.indexOf(`"${field}":`) + len + 3;
    let sliced = json.slice(idx);
    let end = Math.min(sliced.indexOf(","), sliced.indexOf("}"));
    return parseInt(sliced.slice(0, end), 10);
  }
  function getSubscriptionId(json) {
    let idx = json.slice(0, 22).indexOf(`"EVENT"`);
    if (idx === -1)
      return null;
    let pstart = json.slice(idx + 7 + 1).indexOf(`"`);
    if (pstart === -1)
      return null;
    let start = idx + 7 + 1 + pstart;
    let pend = json.slice(start + 1, 80).indexOf(`"`);
    if (pend === -1)
      return null;
    let end = start + 1 + pend;
    return json.slice(start + 1, end);
  }
  function matchEventId(json, id) {
    return id === getHex64(json, "id");
  }
  function matchEventPubkey(json, pubkey) {
    return pubkey === getHex64(json, "pubkey");
  }
  function matchEventKind(json, kind) {
    return kind === getInt(json, "kind");
  }
  var newListeners = () => ({
    connect: [],
    disconnect: [],
    error: [],
    notice: [],
    auth: []
  });
  function relayInit(url, options = {}) {
    let { listTimeout = 3e3, getTimeout = 3e3, countTimeout = 3e3 } = options;
    var ws;
    var openSubs = {};
    var listeners = newListeners();
    var subListeners = {};
    var pubListeners = {};
    var connectionPromise;
    async function connectRelay() {
      if (connectionPromise)
        return connectionPromise;
      connectionPromise = new Promise((resolve, reject) => {
        try {
          ws = new WebSocket(url);
        } catch (err) {
          reject(err);
        }
        ws.onopen = () => {
          listeners.connect.forEach((cb) => cb());
          resolve();
        };
        ws.onerror = () => {
          connectionPromise = void 0;
          listeners.error.forEach((cb) => cb());
          reject();
        };
        ws.onclose = async () => {
          connectionPromise = void 0;
          listeners.disconnect.forEach((cb) => cb());
        };
        let incomingMessageQueue = new MessageQueue();
        let handleNextInterval;
        ws.onmessage = (e8) => {
          incomingMessageQueue.enqueue(e8.data);
          if (!handleNextInterval) {
            handleNextInterval = setInterval(handleNext, 0);
          }
        };
        function handleNext() {
          if (incomingMessageQueue.size === 0) {
            clearInterval(handleNextInterval);
            handleNextInterval = null;
            return;
          }
          var json = incomingMessageQueue.dequeue();
          if (!json)
            return;
          let subid = getSubscriptionId(json);
          if (subid) {
            let so2 = openSubs[subid];
            if (so2 && so2.alreadyHaveEvent && so2.alreadyHaveEvent(getHex64(json, "id"), url)) {
              return;
            }
          }
          try {
            let data = JSON.parse(json);
            switch (data[0]) {
              case "EVENT": {
                let id2 = data[1];
                let event = data[2];
                if (validateEvent(event) && openSubs[id2] && (openSubs[id2].skipVerification || verifySignature(event)) && matchFilters(openSubs[id2].filters, event)) {
                  openSubs[id2];
                  (subListeners[id2]?.event || []).forEach((cb) => cb(event));
                }
                return;
              }
              case "COUNT":
                let id = data[1];
                let payload = data[2];
                if (openSubs[id]) {
                  ;
                  (subListeners[id]?.count || []).forEach((cb) => cb(payload));
                }
                return;
              case "EOSE": {
                let id2 = data[1];
                if (id2 in subListeners) {
                  subListeners[id2].eose.forEach((cb) => cb());
                  subListeners[id2].eose = [];
                }
                return;
              }
              case "OK": {
                let id2 = data[1];
                let ok = data[2];
                let reason = data[3] || "";
                if (id2 in pubListeners) {
                  if (ok)
                    pubListeners[id2].ok.forEach((cb) => cb());
                  else
                    pubListeners[id2].failed.forEach((cb) => cb(reason));
                  pubListeners[id2].ok = [];
                  pubListeners[id2].failed = [];
                }
                return;
              }
              case "NOTICE":
                let notice = data[1];
                listeners.notice.forEach((cb) => cb(notice));
                return;
              case "AUTH": {
                let challenge2 = data[1];
                listeners.auth?.forEach((cb) => cb(challenge2));
                return;
              }
            }
          } catch (err) {
            return;
          }
        }
      });
      return connectionPromise;
    }
    function connected() {
      return ws?.readyState === 1;
    }
    async function connect() {
      if (connected())
        return;
      await connectRelay();
    }
    async function trySend(params) {
      let msg = JSON.stringify(params);
      if (!connected()) {
        await new Promise((resolve) => setTimeout(resolve, 1e3));
        if (!connected()) {
          return;
        }
      }
      try {
        ws.send(msg);
      } catch (err) {
        console.log(err);
      }
    }
    const sub = (filters, {
      verb = "REQ",
      skipVerification = false,
      alreadyHaveEvent = null,
      id = Math.random().toString().slice(2)
    } = {}) => {
      let subid = id;
      openSubs[subid] = {
        id: subid,
        filters,
        skipVerification,
        alreadyHaveEvent
      };
      trySend([verb, subid, ...filters]);
      return {
        sub: (newFilters, newOpts = {}) => sub(newFilters || filters, {
          skipVerification: newOpts.skipVerification || skipVerification,
          alreadyHaveEvent: newOpts.alreadyHaveEvent || alreadyHaveEvent,
          id: subid
        }),
        unsub: () => {
          delete openSubs[subid];
          delete subListeners[subid];
          trySend(["CLOSE", subid]);
        },
        on: (type, cb) => {
          subListeners[subid] = subListeners[subid] || {
            event: [],
            count: [],
            eose: []
          };
          subListeners[subid][type].push(cb);
        },
        off: (type, cb) => {
          let listeners2 = subListeners[subid];
          let idx = listeners2[type].indexOf(cb);
          if (idx >= 0)
            listeners2[type].splice(idx, 1);
        }
      };
    };
    function _publishEvent(event, type) {
      if (!event.id)
        throw new Error(`event ${event} has no id`);
      let id = event.id;
      trySend([type, event]);
      return {
        on: (type2, cb) => {
          pubListeners[id] = pubListeners[id] || {
            ok: [],
            failed: []
          };
          pubListeners[id][type2].push(cb);
        },
        off: (type2, cb) => {
          let listeners2 = pubListeners[id];
          if (!listeners2)
            return;
          let idx = listeners2[type2].indexOf(cb);
          if (idx >= 0)
            listeners2[type2].splice(idx, 1);
        }
      };
    }
    return {
      url,
      sub,
      on: (type, cb) => {
        listeners[type].push(cb);
        if (type === "connect" && ws?.readyState === 1) {
          ;
          cb();
        }
      },
      off: (type, cb) => {
        let index = listeners[type].indexOf(cb);
        if (index !== -1)
          listeners[type].splice(index, 1);
      },
      list: (filters, opts) => new Promise((resolve) => {
        let s5 = sub(filters, opts);
        let events = [];
        let timeout = setTimeout(() => {
          s5.unsub();
          resolve(events);
        }, listTimeout);
        s5.on("eose", () => {
          s5.unsub();
          clearTimeout(timeout);
          resolve(events);
        });
        s5.on("event", (event) => {
          events.push(event);
        });
      }),
      get: (filter, opts) => new Promise((resolve) => {
        let s5 = sub([filter], opts);
        let timeout = setTimeout(() => {
          s5.unsub();
          resolve(null);
        }, getTimeout);
        s5.on("event", (event) => {
          s5.unsub();
          clearTimeout(timeout);
          resolve(event);
        });
      }),
      count: (filters) => new Promise((resolve) => {
        let s5 = sub(filters, { ...sub, verb: "COUNT" });
        let timeout = setTimeout(() => {
          s5.unsub();
          resolve(null);
        }, countTimeout);
        s5.on("count", (event) => {
          s5.unsub();
          clearTimeout(timeout);
          resolve(event);
        });
      }),
      publish(event) {
        return _publishEvent(event, "EVENT");
      },
      auth(event) {
        return _publishEvent(event, "AUTH");
      },
      connect,
      close() {
        listeners = newListeners();
        subListeners = {};
        pubListeners = {};
        if (ws.readyState === WebSocket.OPEN) {
          ws?.close();
        }
      },
      get status() {
        return ws?.readyState ?? 3;
      }
    };
  }
  var nip19_exports = {};
  __export2(nip19_exports, {
    BECH32_REGEX: () => BECH32_REGEX,
    decode: () => decode,
    naddrEncode: () => naddrEncode,
    neventEncode: () => neventEncode,
    noteEncode: () => noteEncode,
    nprofileEncode: () => nprofileEncode,
    npubEncode: () => npubEncode,
    nrelayEncode: () => nrelayEncode,
    nsecEncode: () => nsecEncode
  });
  var Bech32MaxSize = 5e3;
  var BECH32_REGEX = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
  function decode(nip19) {
    let { prefix, words } = bech32.decode(nip19, Bech32MaxSize);
    let data = new Uint8Array(bech32.fromWords(words));
    switch (prefix) {
      case "nprofile": {
        let tlv = parseTLV(data);
        if (!tlv[0]?.[0])
          throw new Error("missing TLV 0 for nprofile");
        if (tlv[0][0].length !== 32)
          throw new Error("TLV 0 should be 32 bytes");
        return {
          type: "nprofile",
          data: {
            pubkey: bytesToHex(tlv[0][0]),
            relays: tlv[1] ? tlv[1].map((d4) => utf8Decoder.decode(d4)) : []
          }
        };
      }
      case "nevent": {
        let tlv = parseTLV(data);
        if (!tlv[0]?.[0])
          throw new Error("missing TLV 0 for nevent");
        if (tlv[0][0].length !== 32)
          throw new Error("TLV 0 should be 32 bytes");
        if (tlv[2] && tlv[2][0].length !== 32)
          throw new Error("TLV 2 should be 32 bytes");
        return {
          type: "nevent",
          data: {
            id: bytesToHex(tlv[0][0]),
            relays: tlv[1] ? tlv[1].map((d4) => utf8Decoder.decode(d4)) : [],
            author: tlv[2]?.[0] ? bytesToHex(tlv[2][0]) : void 0
          }
        };
      }
      case "naddr": {
        let tlv = parseTLV(data);
        if (!tlv[0]?.[0])
          throw new Error("missing TLV 0 for naddr");
        if (!tlv[2]?.[0])
          throw new Error("missing TLV 2 for naddr");
        if (tlv[2][0].length !== 32)
          throw new Error("TLV 2 should be 32 bytes");
        if (!tlv[3]?.[0])
          throw new Error("missing TLV 3 for naddr");
        if (tlv[3][0].length !== 4)
          throw new Error("TLV 3 should be 4 bytes");
        return {
          type: "naddr",
          data: {
            identifier: utf8Decoder.decode(tlv[0][0]),
            pubkey: bytesToHex(tlv[2][0]),
            kind: parseInt(bytesToHex(tlv[3][0]), 16),
            relays: tlv[1] ? tlv[1].map((d4) => utf8Decoder.decode(d4)) : []
          }
        };
      }
      case "nrelay": {
        let tlv = parseTLV(data);
        if (!tlv[0]?.[0])
          throw new Error("missing TLV 0 for nrelay");
        return {
          type: "nrelay",
          data: utf8Decoder.decode(tlv[0][0])
        };
      }
      case "nsec":
      case "npub":
      case "note":
        return { type: prefix, data: bytesToHex(data) };
      default:
        throw new Error(`unknown prefix ${prefix}`);
    }
  }
  function parseTLV(data) {
    let result = {};
    let rest = data;
    while (rest.length > 0) {
      let t5 = rest[0];
      let l6 = rest[1];
      if (!l6)
        throw new Error(`malformed TLV ${t5}`);
      let v4 = rest.slice(2, 2 + l6);
      rest = rest.slice(2 + l6);
      if (v4.length < l6)
        throw new Error(`not enough data to read on TLV ${t5}`);
      result[t5] = result[t5] || [];
      result[t5].push(v4);
    }
    return result;
  }
  function nsecEncode(hex2) {
    return encodeBytes("nsec", hex2);
  }
  function npubEncode(hex2) {
    return encodeBytes("npub", hex2);
  }
  function noteEncode(hex2) {
    return encodeBytes("note", hex2);
  }
  function encodeBech32(prefix, data) {
    let words = bech32.toWords(data);
    return bech32.encode(prefix, words, Bech32MaxSize);
  }
  function encodeBytes(prefix, hex2) {
    let data = hexToBytes(hex2);
    return encodeBech32(prefix, data);
  }
  function nprofileEncode(profile) {
    let data = encodeTLV({
      0: [hexToBytes(profile.pubkey)],
      1: (profile.relays || []).map((url) => utf8Encoder.encode(url))
    });
    return encodeBech32("nprofile", data);
  }
  function neventEncode(event) {
    let data = encodeTLV({
      0: [hexToBytes(event.id)],
      1: (event.relays || []).map((url) => utf8Encoder.encode(url)),
      2: event.author ? [hexToBytes(event.author)] : []
    });
    return encodeBech32("nevent", data);
  }
  function naddrEncode(addr) {
    let kind = new ArrayBuffer(4);
    new DataView(kind).setUint32(0, addr.kind, false);
    let data = encodeTLV({
      0: [utf8Encoder.encode(addr.identifier)],
      1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),
      2: [hexToBytes(addr.pubkey)],
      3: [new Uint8Array(kind)]
    });
    return encodeBech32("naddr", data);
  }
  function nrelayEncode(url) {
    let data = encodeTLV({
      0: [utf8Encoder.encode(url)]
    });
    return encodeBech32("nrelay", data);
  }
  function encodeTLV(tlv) {
    let entries = [];
    Object.entries(tlv).forEach(([t5, vs]) => {
      vs.forEach((v4) => {
        let entry = new Uint8Array(v4.length + 2);
        entry.set([parseInt(t5)], 0);
        entry.set([v4.length], 1);
        entry.set(v4, 2);
        entries.push(entry);
      });
    });
    return concatBytes(...entries);
  }
  var nip04_exports = {};
  __export2(nip04_exports, {
    decrypt: () => decrypt,
    encrypt: () => encrypt
  });
  if (typeof crypto !== "undefined" && !crypto.subtle && crypto.webcrypto) {
    crypto.subtle = crypto.webcrypto.subtle;
  }
  async function encrypt(privkey, pubkey, text) {
    const key = secp256k1.getSharedSecret(privkey, "02" + pubkey);
    const normalizedKey = getNormalizedX(key);
    let iv = Uint8Array.from(randomBytes(16));
    let plaintext = utf8Encoder.encode(text);
    let cryptoKey = await crypto.subtle.importKey(
      "raw",
      normalizedKey,
      { name: "AES-CBC" },
      false,
      ["encrypt"]
    );
    let ciphertext = await crypto.subtle.encrypt(
      { name: "AES-CBC", iv },
      cryptoKey,
      plaintext
    );
    let ctb64 = base64.encode(new Uint8Array(ciphertext));
    let ivb64 = base64.encode(new Uint8Array(iv.buffer));
    return `${ctb64}?iv=${ivb64}`;
  }
  async function decrypt(privkey, pubkey, data) {
    let [ctb64, ivb64] = data.split("?iv=");
    let key = secp256k1.getSharedSecret(privkey, "02" + pubkey);
    let normalizedKey = getNormalizedX(key);
    let cryptoKey = await crypto.subtle.importKey(
      "raw",
      normalizedKey,
      { name: "AES-CBC" },
      false,
      ["decrypt"]
    );
    let ciphertext = base64.decode(ctb64);
    let iv = base64.decode(ivb64);
    let plaintext = await crypto.subtle.decrypt(
      { name: "AES-CBC", iv },
      cryptoKey,
      ciphertext
    );
    let text = utf8Decoder.decode(plaintext);
    return text;
  }
  function getNormalizedX(key) {
    return key.slice(1, 33);
  }
  var nip05_exports = {};
  __export2(nip05_exports, {
    NIP05_REGEX: () => NIP05_REGEX,
    queryProfile: () => queryProfile,
    searchDomain: () => searchDomain,
    useFetchImplementation: () => useFetchImplementation
  });
  var NIP05_REGEX = /^(?:([\w.+-]+)@)?([\w.-]+)$/;
  var _fetch;
  try {
    _fetch = fetch;
  } catch {
  }
  function useFetchImplementation(fetchImplementation) {
    _fetch = fetchImplementation;
  }
  async function searchDomain(domain, query = "") {
    try {
      let res = await (await _fetch(`https://${domain}/.well-known/nostr.json?name=${query}`)).json();
      return res.names;
    } catch (_3) {
      return {};
    }
  }
  async function queryProfile(fullname) {
    const match = fullname.match(NIP05_REGEX);
    if (!match)
      return null;
    const [_3, name = "_", domain] = match;
    try {
      const res = await _fetch(`https://${domain}/.well-known/nostr.json?name=${name}`);
      const { names, relays } = parseNIP05Result(await res.json());
      const pubkey = names[name];
      return pubkey ? { pubkey, relays: relays?.[pubkey] } : null;
    } catch (_e2) {
      return null;
    }
  }
  function parseNIP05Result(json) {
    const result = {
      names: {}
    };
    for (const [name, pubkey] of Object.entries(json.names)) {
      if (typeof name === "string" && typeof pubkey === "string") {
        result.names[name] = pubkey;
      }
    }
    if (json.relays) {
      result.relays = {};
      for (const [pubkey, relays] of Object.entries(json.relays)) {
        if (typeof pubkey === "string" && Array.isArray(relays)) {
          result.relays[pubkey] = relays.filter((relay) => typeof relay === "string");
        }
      }
    }
    return result;
  }
  var nip06_exports = {};
  __export2(nip06_exports, {
    generateSeedWords: () => generateSeedWords,
    privateKeyFromSeedWords: () => privateKeyFromSeedWords,
    validateWords: () => validateWords
  });
  function privateKeyFromSeedWords(mnemonic, passphrase) {
    let root = HDKey.fromMasterSeed(mnemonicToSeedSync(mnemonic, passphrase));
    let privateKey = root.derive(`m/44'/1237'/0'/0/0`).privateKey;
    if (!privateKey)
      throw new Error("could not derive private key");
    return bytesToHex(privateKey);
  }
  function generateSeedWords() {
    return generateMnemonic(wordlist);
  }
  function validateWords(words) {
    return validateMnemonic(words, wordlist);
  }
  var nip10_exports = {};
  __export2(nip10_exports, {
    parse: () => parse
  });
  function parse(event) {
    const result = {
      reply: void 0,
      root: void 0,
      mentions: [],
      profiles: []
    };
    const eTags = [];
    for (const tag of event.tags) {
      if (tag[0] === "e" && tag[1]) {
        eTags.push(tag);
      }
      if (tag[0] === "p" && tag[1]) {
        result.profiles.push({
          pubkey: tag[1],
          relays: tag[2] ? [tag[2]] : []
        });
      }
    }
    for (let eTagIndex = 0; eTagIndex < eTags.length; eTagIndex++) {
      const eTag = eTags[eTagIndex];
      const [_3, eTagEventId, eTagRelayUrl, eTagMarker] = eTag;
      const eventPointer = {
        id: eTagEventId,
        relays: eTagRelayUrl ? [eTagRelayUrl] : []
      };
      const isFirstETag = eTagIndex === 0;
      const isLastETag = eTagIndex === eTags.length - 1;
      if (eTagMarker === "root") {
        result.root = eventPointer;
        continue;
      }
      if (eTagMarker === "reply") {
        result.reply = eventPointer;
        continue;
      }
      if (eTagMarker === "mention") {
        result.mentions.push(eventPointer);
        continue;
      }
      if (isFirstETag) {
        result.root = eventPointer;
        continue;
      }
      if (isLastETag) {
        result.reply = eventPointer;
        continue;
      }
      result.mentions.push(eventPointer);
    }
    return result;
  }
  var nip13_exports = {};
  __export2(nip13_exports, {
    getPow: () => getPow
  });
  function getPow(id) {
    return getLeadingZeroBits(hexToBytes(id));
  }
  function getLeadingZeroBits(hash2) {
    let total, i4, bits;
    for (i4 = 0, total = 0; i4 < hash2.length; i4++) {
      bits = msb(hash2[i4]);
      total += bits;
      if (bits !== 8) {
        break;
      }
    }
    return total;
  }
  function msb(b3) {
    let n7 = 0;
    if (b3 === 0) {
      return 8;
    }
    while (b3 >>= 1) {
      n7++;
    }
    return 7 - n7;
  }
  var nip18_exports = {};
  __export2(nip18_exports, {
    finishRepostEvent: () => finishRepostEvent,
    getRepostedEvent: () => getRepostedEvent,
    getRepostedEventPointer: () => getRepostedEventPointer
  });
  function finishRepostEvent(t5, reposted, relayUrl, privateKey) {
    return finishEvent({
      kind: 6,
      tags: [
        ...t5.tags ?? [],
        ["e", reposted.id, relayUrl],
        ["p", reposted.pubkey]
      ],
      content: t5.content === "" ? "" : JSON.stringify(reposted),
      created_at: t5.created_at
    }, privateKey);
  }
  function getRepostedEventPointer(event) {
    if (event.kind !== 6) {
      return void 0;
    }
    let lastETag;
    let lastPTag;
    for (let i4 = event.tags.length - 1; i4 >= 0 && (lastETag === void 0 || lastPTag === void 0); i4--) {
      const tag = event.tags[i4];
      if (tag.length >= 2) {
        if (tag[0] === "e" && lastETag === void 0) {
          lastETag = tag;
        } else if (tag[0] === "p" && lastPTag === void 0) {
          lastPTag = tag;
        }
      }
    }
    if (lastETag === void 0) {
      return void 0;
    }
    return {
      id: lastETag[1],
      relays: [lastETag[2], lastPTag?.[2]].filter((x4) => typeof x4 === "string"),
      author: lastPTag?.[1]
    };
  }
  function getRepostedEvent(event, { skipVerification } = {}) {
    const pointer = getRepostedEventPointer(event);
    if (pointer === void 0 || event.content === "") {
      return void 0;
    }
    let repostedEvent;
    try {
      repostedEvent = JSON.parse(event.content);
    } catch (error) {
      return void 0;
    }
    if (repostedEvent.id !== pointer.id) {
      return void 0;
    }
    if (!skipVerification && !verifySignature(repostedEvent)) {
      return void 0;
    }
    return repostedEvent;
  }
  var nip21_exports = {};
  __export2(nip21_exports, {
    NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,
    parse: () => parse2,
    test: () => test
  });
  var NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);
  function test(value) {
    return typeof value === "string" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);
  }
  function parse2(uri) {
    const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));
    if (!match)
      throw new Error(`Invalid Nostr URI: ${uri}`);
    return {
      uri: match[0],
      value: match[1],
      decoded: decode(match[1])
    };
  }
  var nip25_exports = {};
  __export2(nip25_exports, {
    finishReactionEvent: () => finishReactionEvent,
    getReactedEventPointer: () => getReactedEventPointer
  });
  function finishReactionEvent(t5, reacted, privateKey) {
    const inheritedTags = reacted.tags.filter(
      (tag) => tag.length >= 2 && (tag[0] === "e" || tag[0] === "p")
    );
    return finishEvent({
      ...t5,
      kind: 7,
      tags: [
        ...t5.tags ?? [],
        ...inheritedTags,
        ["e", reacted.id],
        ["p", reacted.pubkey]
      ],
      content: t5.content ?? "+"
    }, privateKey);
  }
  function getReactedEventPointer(event) {
    if (event.kind !== 7) {
      return void 0;
    }
    let lastETag;
    let lastPTag;
    for (let i4 = event.tags.length - 1; i4 >= 0 && (lastETag === void 0 || lastPTag === void 0); i4--) {
      const tag = event.tags[i4];
      if (tag.length >= 2) {
        if (tag[0] === "e" && lastETag === void 0) {
          lastETag = tag;
        } else if (tag[0] === "p" && lastPTag === void 0) {
          lastPTag = tag;
        }
      }
    }
    if (lastETag === void 0 || lastPTag === void 0) {
      return void 0;
    }
    return {
      id: lastETag[1],
      relays: [lastETag[2], lastPTag[2]].filter((x4) => x4 !== void 0),
      author: lastPTag[1]
    };
  }
  var nip26_exports = {};
  __export2(nip26_exports, {
    createDelegation: () => createDelegation,
    getDelegator: () => getDelegator
  });
  function createDelegation(privateKey, parameters) {
    let conditions = [];
    if ((parameters.kind || -1) >= 0)
      conditions.push(`kind=${parameters.kind}`);
    if (parameters.until)
      conditions.push(`created_at<${parameters.until}`);
    if (parameters.since)
      conditions.push(`created_at>${parameters.since}`);
    let cond = conditions.join("&");
    if (cond === "")
      throw new Error("refusing to create a delegation without any conditions");
    let sighash = sha256(
      utf8Encoder.encode(`nostr:delegation:${parameters.pubkey}:${cond}`)
    );
    let sig = bytesToHex(
      schnorr.sign(sighash, privateKey)
    );
    return {
      from: getPublicKey(privateKey),
      to: parameters.pubkey,
      cond,
      sig
    };
  }
  function getDelegator(event) {
    let tag = event.tags.find((tag2) => tag2[0] === "delegation" && tag2.length >= 4);
    if (!tag)
      return null;
    let pubkey = tag[1];
    let cond = tag[2];
    let sig = tag[3];
    let conditions = cond.split("&");
    for (let i4 = 0; i4 < conditions.length; i4++) {
      let [key, operator, value] = conditions[i4].split(/\b/);
      if (key === "kind" && operator === "=" && event.kind === parseInt(value))
        continue;
      else if (key === "created_at" && operator === "<" && event.created_at < parseInt(value))
        continue;
      else if (key === "created_at" && operator === ">" && event.created_at > parseInt(value))
        continue;
      else
        return null;
    }
    let sighash = sha256(
      utf8Encoder.encode(`nostr:delegation:${event.pubkey}:${cond}`)
    );
    if (!schnorr.verify(sig, sighash, pubkey))
      return null;
    return pubkey;
  }
  var nip27_exports = {};
  __export2(nip27_exports, {
    matchAll: () => matchAll,
    regex: () => regex,
    replaceAll: () => replaceAll
  });
  var regex = () => new RegExp(`\\b${NOSTR_URI_REGEX.source}\\b`, "g");
  function* matchAll(content) {
    const matches = content.matchAll(regex());
    for (const match of matches) {
      try {
        const [uri, value] = match;
        yield {
          uri,
          value,
          decoded: decode(value),
          start: match.index,
          end: match.index + uri.length
        };
      } catch (_e2) {
      }
    }
  }
  function replaceAll(content, replacer) {
    return content.replaceAll(regex(), (uri, value) => {
      return replacer({
        uri,
        value,
        decoded: decode(value)
      });
    });
  }
  var nip39_exports = {};
  __export2(nip39_exports, {
    useFetchImplementation: () => useFetchImplementation2,
    validateGithub: () => validateGithub
  });
  var _fetch2;
  try {
    _fetch2 = fetch;
  } catch {
  }
  function useFetchImplementation2(fetchImplementation) {
    _fetch2 = fetchImplementation;
  }
  async function validateGithub(pubkey, username, proof) {
    try {
      let res = await (await _fetch2(`https://gist.github.com/${username}/${proof}/raw`)).text();
      return res === `Verifying that I control the following Nostr public key: ${pubkey}`;
    } catch (_3) {
      return false;
    }
  }
  var nip42_exports = {};
  __export2(nip42_exports, {
    authenticate: () => authenticate
  });
  var authenticate = async ({
    challenge: challenge2,
    relay,
    sign
  }) => {
    const e8 = {
      kind: 22242,
      created_at: Math.floor(Date.now() / 1e3),
      tags: [
        ["relay", relay.url],
        ["challenge", challenge2]
      ],
      content: ""
    };
    const pub = relay.auth(await sign(e8));
    return new Promise((resolve, reject) => {
      pub.on("ok", function ok() {
        pub.off("ok", ok);
        resolve();
      });
      pub.on("failed", function fail(reason) {
        pub.off("failed", fail);
        reject(reason);
      });
    });
  };
  var nip57_exports = {};
  __export2(nip57_exports, {
    getZapEndpoint: () => getZapEndpoint,
    makeZapReceipt: () => makeZapReceipt,
    makeZapRequest: () => makeZapRequest,
    useFetchImplementation: () => useFetchImplementation3,
    validateZapRequest: () => validateZapRequest
  });
  var _fetch3;
  try {
    _fetch3 = fetch;
  } catch {
  }
  function useFetchImplementation3(fetchImplementation) {
    _fetch3 = fetchImplementation;
  }
  async function getZapEndpoint(metadata) {
    try {
      let lnurl = "";
      let { lud06, lud16 } = JSON.parse(metadata.content);
      if (lud06) {
        let { words } = bech32.decode(lud06, 1e3);
        let data = bech32.fromWords(words);
        lnurl = utf8Decoder.decode(data);
      } else if (lud16) {
        let [name, domain] = lud16.split("@");
        lnurl = `https://${domain}/.well-known/lnurlp/${name}`;
      } else {
        return null;
      }
      let res = await _fetch3(lnurl);
      let body = await res.json();
      if (body.allowsNostr && body.nostrPubkey) {
        return body.callback;
      }
    } catch (err) {
    }
    return null;
  }
  function makeZapRequest({
    profile,
    event,
    amount,
    relays,
    comment = ""
  }) {
    if (!amount)
      throw new Error("amount not given");
    if (!profile)
      throw new Error("profile not given");
    let zr = {
      kind: 9734,
      created_at: Math.round(Date.now() / 1e3),
      content: comment,
      tags: [
        ["p", profile],
        ["amount", amount.toString()],
        ["relays", ...relays]
      ]
    };
    if (event) {
      zr.tags.push(["e", event]);
    }
    return zr;
  }
  function validateZapRequest(zapRequestString) {
    let zapRequest;
    try {
      zapRequest = JSON.parse(zapRequestString);
    } catch (err) {
      return "Invalid zap request JSON.";
    }
    if (!validateEvent(zapRequest))
      return "Zap request is not a valid Nostr event.";
    if (!verifySignature(zapRequest))
      return "Invalid signature on zap request.";
    let p4 = zapRequest.tags.find(([t5, v4]) => t5 === "p" && v4);
    if (!p4)
      return "Zap request doesn't have a 'p' tag.";
    if (!p4[1].match(/^[a-f0-9]{64}$/))
      return "Zap request 'p' tag is not valid hex.";
    let e8 = zapRequest.tags.find(([t5, v4]) => t5 === "e" && v4);
    if (e8 && !e8[1].match(/^[a-f0-9]{64}$/))
      return "Zap request 'e' tag is not valid hex.";
    let relays = zapRequest.tags.find(([t5, v4]) => t5 === "relays" && v4);
    if (!relays)
      return "Zap request doesn't have a 'relays' tag.";
    return null;
  }
  function makeZapReceipt({
    zapRequest,
    preimage,
    bolt11,
    paidAt
  }) {
    let zr = JSON.parse(zapRequest);
    let tagsFromZapRequest = zr.tags.filter(
      ([t5]) => t5 === "e" || t5 === "p" || t5 === "a"
    );
    let zap = {
      kind: 9735,
      created_at: Math.round(paidAt.getTime() / 1e3),
      content: "",
      tags: [
        ...tagsFromZapRequest,
        ["bolt11", bolt11],
        ["description", zapRequest]
      ]
    };
    if (preimage) {
      zap.tags.push(["preimage", preimage]);
    }
    return zap;
  }
  var nip98_exports = {};
  __export2(nip98_exports, {
    getToken: () => getToken,
    validateToken: () => validateToken
  });
  var _authorizationScheme = "Nostr ";
  async function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false) {
    if (!loginUrl || !httpMethod)
      throw new Error("Missing loginUrl or httpMethod");
    if (httpMethod !== "get" && httpMethod !== "post")
      throw new Error("Unknown httpMethod");
    const event = getBlankEvent(
      27235
      /* HttpAuth */
    );
    event.tags = [
      ["u", loginUrl],
      ["method", httpMethod]
    ];
    event.created_at = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
    const signedEvent = await sign(event);
    const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : "";
    return authorizationScheme + base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));
  }
  async function validateToken(token, url, method) {
    if (!token) {
      throw new Error("Missing token");
    }
    token = token.replace(_authorizationScheme, "");
    const eventB64 = utf8Decoder.decode(base64.decode(token));
    if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith("{")) {
      throw new Error("Invalid token");
    }
    const event = JSON.parse(eventB64);
    if (!event) {
      throw new Error("Invalid nostr event");
    }
    if (!verifySignature(event)) {
      throw new Error("Invalid nostr event, signature invalid");
    }
    if (event.kind !== 27235) {
      throw new Error("Invalid nostr event, kind invalid");
    }
    if (!event.created_at) {
      throw new Error("Invalid nostr event, created_at invalid");
    }
    if (Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) - event.created_at > 60) {
      throw new Error("Invalid nostr event, expired");
    }
    const urlTag = event.tags.find((t5) => t5[0] === "u");
    if (urlTag?.length !== 1 && urlTag?.[1] !== url) {
      throw new Error("Invalid nostr event, url tag invalid");
    }
    const methodTag = event.tags.find((t5) => t5[0] === "method");
    if (methodTag?.length !== 1 && methodTag?.[1].toLowerCase() !== method.toLowerCase()) {
      throw new Error("Invalid nostr event, method tag invalid");
    }
    return true;
  }

  // node_modules/@getalby/sdk/dist/index.modern.js
  function u3() {
    return u3 = Object.assign ? Object.assign.bind() : function(e8) {
      for (var t5 = 1; t5 < arguments.length; t5++) {
        var n7 = arguments[t5];
        for (var s5 in n7)
          Object.prototype.hasOwnProperty.call(n7, s5) && (e8[s5] = n7[s5]);
      }
      return e8;
    }, u3.apply(this, arguments);
  }
  function h3(e8, t5) {
    if (null == e8)
      return {};
    var n7, s5, o6 = {}, r4 = Object.keys(e8);
    for (s5 = 0; s5 < r4.length; s5++)
      t5.indexOf(n7 = r4[s5]) >= 0 || (o6[n7] = e8[n7]);
    return o6;
  }
  function l5(e8) {
    return Object.entries(e8).map(([e9, t5]) => e9 && t5 ? `${e9}=${t5}` : "").filter((e9) => e9).join("&");
  }
  var p2 = class extends Error {
    constructor(e8, t5, n7, s5) {
      let o6 = e8.toString();
      t5 && (o6 += ` ${t5}`), o6 += ": ", o6 += s5.message ? s5.message : JSON.stringify(s5), super(o6), this.status = void 0, this.statusText = void 0, this.headers = void 0, this.error = void 0, this.status = e8, this.statusText = t5, this.headers = n7, this.error = s5;
    }
  };
  var y2 = ["auth", "endpoint", "params", "request_body", "method", "max_retries", "base_url", "user_agent", "headers"];
  var w2 = "https://api.getalby.com";
  async function f3(e8, t5, n7 = 0) {
    const s5 = await fetch(e8, t5);
    if (429 === s5.status && n7 > 0) {
      const o6 = Number(s5.headers.get("x-rate-limit-reset")), r4 = Number(s5.headers.get("x-rate-limit-remaining")), i4 = 1e3 * o6 - Date.now();
      let a3 = 1e3;
      return 0 === r4 && (a3 = i4), await new Promise((e9) => setTimeout(e9, a3)), f3(e8, t5, n7 - 1);
    }
    return s5;
  }
  async function g2(e8) {
    let { auth: t5, endpoint: n7, params: s5 = {}, request_body: o6, method: r4, max_retries: i4, base_url: a3 = w2, user_agent: c4, headers: d4 } = e8, m3 = h3(e8, y2);
    const g4 = new URL(a3 + n7);
    g4.search = l5(s5);
    const v4 = "POST" === r4 && !!o6, b3 = t5 ? await t5.getAuthHeader(g4.href, r4) : void 0, _3 = await f3(g4.toString(), u3({ headers: u3({}, v4 ? { "Content-Type": "application/json; charset=utf-8" } : void 0, b3, d4, { "User-Agent": null != c4 ? c4 : "@getalby/sdk", "X-User-Agent": null != c4 ? c4 : "@getalby/sdk" }), method: r4, body: v4 ? JSON.stringify(o6) : void 0 }, m3), i4);
    if (!_3.ok) {
      const e9 = await _3.json();
      throw new p2(_3.status, _3.statusText, _3.headers, e9);
    }
    return _3;
  }
  async function v2(e8) {
    return (await g2(e8)).json();
  }
  var E2 = class {
    constructor(e8) {
      this.bearer_token = void 0, this.bearer_token = e8;
    }
    getAuthHeader() {
      return { Authorization: `Bearer ${this.bearer_token}` };
    }
  };
  var q = { alby: { authorizationUrl: "https://nwc.getalby.com/apps/new", relayUrl: "wss://relay.getalby.com/v1", walletPubkey: "69effe7b49a6dd5cf525bd0905917a5005ffe480b58eeb8e861418cf3ae760d9" } };
  var T2 = { get_balance: "getBalance", make_invoice: "makeInvoice", pay_invoice: "sendPayment", lookup_invoice: "lookupInvoice" };
  var A2 = class _A {
    static parseWalletConnectUrl(e8) {
      e8 = e8.replace("nostrwalletconnect://", "http://").replace("nostr+walletconnect://", "http://");
      const t5 = new URL(e8), n7 = {};
      n7.walletPubkey = t5.host;
      const s5 = t5.searchParams.get("secret"), o6 = t5.searchParams.get("relay");
      return s5 && (n7.secret = s5), o6 && (n7.relayUrl = o6), n7;
    }
    static withNewSecret(e8) {
      return (e8 = e8 || {}).secret = generatePrivateKey(), new _A(e8);
    }
    constructor(e8) {
      var t5;
      this.relay = void 0, this.relayUrl = void 0, this.secret = void 0, this.walletPubkey = void 0, this.options = void 0, this.subscribers = void 0, e8 && e8.nostrWalletConnectUrl && (e8 = u3({}, _A.parseWalletConnectUrl(e8.nostrWalletConnectUrl), e8));
      const n7 = q[(null == (t5 = e8) ? void 0 : t5.providerName) || "alby"];
      this.options = u3({}, n7, e8 || {}), this.relayUrl = this.options.relayUrl, this.relay = relayInit(this.relayUrl), this.options.secret && (this.secret = this.options.secret.toLowerCase().startsWith("nsec") ? nip19_exports.decode(this.options.secret).data : this.options.secret), this.walletPubkey = this.options.walletPubkey.toLowerCase().startsWith("npub") ? nip19_exports.decode(this.options.walletPubkey).data : this.options.walletPubkey, this.subscribers = {}, void 0 === globalThis.WebSocket && console.error("WebSocket is undefined. Make sure to `import websocket-polyfill` for nodejs environments");
    }
    on(e8, t5) {
      this.subscribers[e8] = t5;
    }
    notify(e8, t5) {
      const n7 = this.subscribers[e8];
      n7 && n7(t5);
    }
    getNostrWalletConnectUrl(e8 = true) {
      let t5 = `nostr+walletconnect://${this.walletPubkey}?relay=${this.relayUrl}&pubkey=${this.publicKey}`;
      return e8 && (t5 = `${t5}&secret=${this.secret}`), t5;
    }
    get nostrWalletConnectUrl() {
      return this.getNostrWalletConnectUrl();
    }
    get connected() {
      return 1 === this.relay.status;
    }
    get publicKey() {
      if (!this.secret)
        throw new Error("Missing secret key");
      return getPublicKey(this.secret);
    }
    getPublicKey() {
      return Promise.resolve(this.publicKey);
    }
    signEvent(e8) {
      if (!this.secret)
        throw new Error("Missing secret key");
      return Promise.resolve(finishEvent(e8, this.secret));
    }
    getEventHash(e8) {
      return getEventHash(e8);
    }
    async enable() {
      if (this.connected)
        return Promise.resolve();
      await this.relay.connect();
    }
    close() {
      return this.relay.close();
    }
    async encrypt(e8, t5) {
      if (!this.secret)
        throw new Error("Missing secret");
      return await nip04_exports.encrypt(this.secret, e8, t5);
    }
    async decrypt(e8, t5) {
      if (!this.secret)
        throw new Error("Missing secret");
      return await nip04_exports.decrypt(this.secret, e8, t5);
    }
    async getInfo() {
      return { methods: ["getInfo", "sendPayment", "makeInvoice", "getBalance", "lookupInvoice"], node: {}, supports: ["lightning"], version: "NWC" };
    }
    getBalance() {
      return this.checkConnected(), this.executeNip47Request("get_balance", void 0, (e8) => void 0 !== e8.balance, (e8) => ({ balance: Math.floor(e8.balance / 1e3), currency: "sats" }));
    }
    sendPayment(e8) {
      return this.checkConnected(), this.executeNip47Request("pay_invoice", { invoice: e8 }, (e9) => !!e9.preimage, (e9) => ({ preimage: e9.preimage }));
    }
    keysend(e8) {
      throw new Error("Method not implemented.");
    }
    lnurl(e8) {
      throw new Error("Method not implemented.");
    }
    makeInvoice(e8) {
      var t5;
      this.checkConnected();
      const n7 = "object" == typeof e8 ? e8 : void 0, s5 = +(null != (t5 = null == n7 ? void 0 : n7.amount) ? t5 : e8);
      if (!s5)
        throw new Error("No amount specified");
      return this.executeNip47Request("make_invoice", { amount: 1e3 * s5, description: null == n7 ? void 0 : n7.defaultMemo }, (e9) => !!e9.invoice, (e9) => ({ paymentRequest: e9.invoice }));
    }
    lookupInvoice(e8) {
      return this.checkConnected(), this.executeNip47Request("lookup_invoice", e8, (e9) => void 0 !== e9.invoice && void 0 !== e9.paid, (e9) => ({ paymentRequest: e9.invoice, paid: e9.paid }));
    }
    request(e8, t5) {
      throw new Error("Method not implemented.");
    }
    signMessage(e8) {
      throw new Error("Method not implemented.");
    }
    verifyMessage(e8, t5) {
      throw new Error("Method not implemented.");
    }
    getAuthorizationUrl(e8) {
      if (!this.options.authorizationUrl)
        throw new Error("Missing authorizationUrl option");
      const t5 = new URL(this.options.authorizationUrl);
      return null != e8 && e8.name && t5.searchParams.set("c", null == e8 ? void 0 : e8.name), t5.searchParams.set("pubkey", this.publicKey), null != e8 && e8.returnTo && t5.searchParams.set("return_to", e8.returnTo), null != e8 && e8.budgetRenewal && t5.searchParams.set("budget_renewal", e8.budgetRenewal), null != e8 && e8.expiresAt && t5.searchParams.set("expires_at", Math.floor(e8.expiresAt.getTime() / 1e3).toString()), null != e8 && e8.maxAmount && t5.searchParams.set("max_amount", e8.maxAmount.toString()), void 0 !== (null == e8 ? void 0 : e8.editable) && t5.searchParams.set("editable", e8.editable.toString()), t5;
    }
    initNWC(e8 = {}) {
      e8.name || (e8.name = document.location.host);
      const t5 = this.getAuthorizationUrl(e8), n7 = window.outerHeight / 2 + window.screenY - 300, s5 = window.outerWidth / 2 + window.screenX - 200;
      return new Promise((e9, o6) => {
        const r4 = window.open(t5.toString(), `${document.title} - Wallet Connect`, `height=600,width=400,top=${n7},left=${s5}`);
        if (!r4)
          return void o6();
        const i4 = (n8) => {
          const s6 = n8.data;
          s6 && "nwc:success" === s6.type && n8.origin === `${t5.protocol}//${t5.host}` && (e9(s6), clearInterval(a3), window.removeEventListener("message", i4), r4 && r4.close());
        }, a3 = setInterval(() => {
          r4 && r4.closed && (o6(), clearInterval(a3), window.removeEventListener("message", i4));
        }, 500);
        window.addEventListener("message", i4);
      });
    }
    checkConnected() {
      if (!this.connected)
        throw new Error("please call enable() and await the promise before calling this function");
    }
    executeNip47Request(e8, t5, n7, s5) {
      var o6 = this;
      const r4 = T2[e8];
      return new Promise((i4, a3) => {
        !async function() {
          const c4 = { method: e8, params: t5 }, u5 = await o6.encrypt(o6.walletPubkey, JSON.stringify(c4)), h5 = { kind: 23194, created_at: Math.floor(Date.now() / 1e3), tags: [["p", o6.walletPubkey]], content: u5, pubkey: o6.publicKey }, l6 = await o6.signEvent(h5), d4 = o6.relay.sub([{ kinds: [23195], authors: [o6.walletPubkey], "#e": [l6.id] }]), p4 = setTimeout(function() {
            d4.unsub(), a3({ error: `reply timeout: event ${l6.id}`, code: "INTERNAL" });
          }, 6e4);
          d4.on("event", async function(e9) {
            clearTimeout(p4), d4.unsub();
            const t6 = await o6.decrypt(o6.walletPubkey, e9.content);
            let c5;
            try {
              c5 = JSON.parse(t6);
            } catch (e10) {
              return void a3({ error: "invalid response", code: "INTERNAL" });
            }
            var u6, h6;
            23195 == e9.kind && c5.result ? n7(c5.result) ? (i4(s5(c5.result)), o6.notify(r4, c5.result)) : a3({ error: "Response from NWC failed validation: " + JSON.stringify(c5.result), code: "INTERNAL" }) : a3({ error: null == (u6 = c5.error) ? void 0 : u6.message, code: null == (h6 = c5.error) ? void 0 : h6.code });
          });
          const m3 = o6.relay.publish(l6), y4 = setTimeout(function() {
            a3({ error: `Publish timeout: event ${l6.id}` });
          }, 5e3);
          m3.on("failed", (e9) => {
            clearTimeout(y4), a3({ error: `Failed to publish request: ${e9}` });
          }), m3.on("ok", () => {
            clearTimeout(y4);
          });
        }();
      });
    }
  };
  var O = A2;
  function x2(e8) {
    const t5 = {};
    return e8.recipient.customKey && e8.recipient.customValue && (t5[e8.recipient.customKey] = e8.recipient.customValue), t5[7629169] = JSON.stringify(e8.boostagram), { destination: e8.recipient.address, amount: e8.amount, customRecords: t5 };
  }
  var R2 = class {
    constructor(e8, t5) {
      this.auth = void 0, this.defaultRequestOptions = void 0, this.auth = "string" == typeof e8 ? new E2(e8) : e8, this.defaultRequestOptions = u3({}, t5, { user_agent: null == t5 ? void 0 : t5.user_agent });
    }
    accountBalance(e8, t5) {
      return v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: "/balance", params: e8, method: "GET" }));
    }
    accountSummary(e8, t5) {
      return v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: "/user/summary", params: e8, method: "GET" }));
    }
    accountInformation(e8, t5) {
      return v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: "/user/me", params: e8, method: "GET" }));
    }
    accountValue4Value(e8, t5) {
      return v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: "/user/value4value", params: e8, method: "GET" }));
    }
    incomingInvoices(e8, t5) {
      return v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: "/invoices/incoming", params: e8, method: "GET" }));
    }
    outgoingInvoices(e8, t5) {
      return v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: "/invoices/outgoing", params: e8, method: "GET" }));
    }
    getInvoice(e8, t5) {
      return v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: `/invoices/${e8}`, method: "GET" }));
    }
    createInvoice(e8, t5) {
      return v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: "/invoices", request_body: e8, method: "POST" }));
    }
    keysend(e8, t5) {
      let n7, s5;
      return Array.isArray(e8) ? (n7 = "/payments/keysend/multi", s5 = { keysends: e8 }) : (n7 = "/payments/keysend", s5 = e8), v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: n7, request_body: s5, method: "POST" }));
    }
    sendPayment(e8, t5) {
      return v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: "/payments/bolt11", request_body: e8, method: "POST" }));
    }
    sendBoostagram(e8, t5) {
      let n7, s5;
      return Array.isArray(e8) ? (n7 = "/payments/keysend/multi", s5 = { keysends: e8.map((e9) => x2(e9)) }) : (n7 = "/payments/keysend", s5 = x2(e8)), v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: n7, request_body: s5, method: "POST" }));
    }
    sendToAlbyAccount(e8, t5) {
      return v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: "/payments/keysend", request_body: { destination: "030a58b8653d32b99200a2334cfe913e51dc7d155aa0116c176657a4f1722677a3", customRecords: { 696969: e8.account }, amount: e8.amount, memo: e8.memo }, method: "POST" }));
    }
    createWebhookEndpoint(e8, t5) {
      return v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: "/webhook_endpoints", request_body: e8, method: "POST" }));
    }
    deleteWebhookEndpoint(e8, t5) {
      return v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: `/webhook_endpoints/${e8}`, method: "DELETE" }));
    }
    getSwapInfo(e8) {
      return v2(u3({ auth: this.auth }, this.defaultRequestOptions, e8, { endpoint: "/swaps/info", method: "GET" }));
    }
    createSwap(e8, t5) {
      return v2(u3({ auth: this.auth }, this.defaultRequestOptions, t5, { endpoint: "/swaps", method: "POST", request_body: e8 }));
    }
  };
  var S3 = { __proto__: null, NostrWebLNProvider: A2, NWC: O, OauthWeblnProvider: class {
    constructor(e8) {
      this.client = void 0, this.auth = void 0, this.oauth = void 0, this.subscribers = void 0, this.isExecuting = void 0, this.auth = e8.auth, this.client = new R2(e8.auth), this.oauth = true, this.subscribers = {}, this.isExecuting = false;
    }
    on(e8, t5) {
      this.subscribers[e8] = t5;
    }
    notify(e8, t5) {
      const n7 = this.subscribers[e8];
      n7 && n7(t5);
    }
    async enable() {
      var e8;
      if (!this.isExecuting) {
        if (null != (e8 = this.auth.token) && e8.access_token)
          return { enabled: true };
        if ("undefined" == typeof window || void 0 === window.document)
          throw new Error("Missing access token");
        try {
          this.isExecuting = true, await this.openAuthorization();
        } finally {
          this.isExecuting = false;
        }
      }
    }
    async sendPayment(e8) {
      if (!this.isExecuting)
        try {
          this.isExecuting = true;
          const t5 = await this.client.sendPayment({ invoice: e8 });
          return this.notify("sendPayment", t5), { preimage: t5.payment_preimage };
        } catch (e9) {
          let t5 = "Unknown Error";
          throw e9 instanceof Error && (t5 = e9.message), new Error(t5);
        } finally {
          this.isExecuting = false;
        }
    }
    async keysend(e8) {
      if (!this.isExecuting)
        try {
          this.isExecuting = true;
          const t5 = await this.client.keysend(e8);
          return this.notify("keysend", t5), { preimage: t5.payment_preimage };
        } catch (e9) {
          let t5 = "Unknown Error";
          throw e9 instanceof Error && (t5 = e9.message), new Error(t5);
        } finally {
          this.isExecuting = false;
        }
    }
    async getInfo() {
      return { alias: "Alby" };
    }
    async makeInvoice(e8) {
      if (!this.isExecuting)
        try {
          this.isExecuting = true;
          const t5 = await this.client.createInvoice({ amount: parseInt(e8.amount.toString()), description: e8.defaultMemo });
          return this.notify("makeInvoice", t5), { paymentRequest: t5.payment_request };
        } catch (e9) {
          let t5 = "Unknown Error";
          throw e9 instanceof Error && (t5 = e9.message), new Error(t5);
        } finally {
          this.isExecuting = false;
        }
    }
    openAuthorization() {
      var e8 = this;
      const t5 = window.outerHeight / 2 + window.screenY - 350, n7 = window.outerWidth / 2 + window.screenX - 300, s5 = this.auth.generateAuthURL({ code_challenge_method: "S256" });
      return new Promise((o6, r4) => {
        const i4 = window.open(s5, `${document.title} - WebLN enable`, `height=700,width=600,top=${t5},left=${n7}`);
        let a3 = false;
        window.addEventListener("message", async function(t6) {
          const n8 = t6.data;
          if (n8 && "alby:oauth:success" === n8.type && t6.origin === `${document.location.protocol}//${document.location.host}` && !a3) {
            a3 = true, console.info("Processing OAuth code response");
            const t7 = n8.payload.code;
            try {
              await e8.auth.requestAccessToken(t7), e8.client = new R2(e8.auth), i4 && i4.close(), e8.notify("enable"), o6({ enabled: true });
            } catch (e9) {
              console.error(e9), r4({ enabled: false });
            }
          }
        });
      });
    }
  } };

  // dist/index.modern.js
  function c3(e8, t5, o6, n7) {
    var r4, i4 = arguments.length, a3 = i4 < 3 ? t5 : null === n7 ? n7 = Object.getOwnPropertyDescriptor(t5, o6) : n7;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
      a3 = Reflect.decorate(e8, t5, o6, n7);
    else
      for (var l6 = e8.length - 1; l6 >= 0; l6--)
        (r4 = e8[l6]) && (a3 = (i4 < 3 ? r4(a3) : i4 > 3 ? r4(t5, o6, a3) : r4(t5, o6)) || a3);
    return i4 > 3 && a3 && Object.defineProperty(t5, o6, a3), a3;
  }
  var d3 = false;
  var p3 = class {
    constructor(e8) {
      this._config = e8;
    }
    async init() {
      if (!window.webln)
        throw new Error("window.webln does not exist");
      await window.webln.enable();
    }
    async getBalance() {
      try {
        if (!window.webln)
          throw new Error("webln not found");
        const e8 = await (null == window.webln.getBalance ? void 0 : window.webln.getBalance());
        return null == e8 ? void 0 : e8.balance;
      } catch (e8) {
        console.error("Failed to get balance", e8);
      }
    }
    async getAlias() {
      try {
        if (!window.webln)
          throw new Error("webln not found");
        return (await window.webln.getInfo()).node.alias;
      } catch (e8) {
        return void console.error("Failed to get alias", e8);
      }
    }
  };
  var f4 = class extends p3 {
    constructor(e8) {
      if (super(e8), !e8.nwcUrl)
        throw new Error("no nwc URL provided");
      const t5 = new S3.NostrWebLNProvider({ nostrWalletConnectUrl: e8.nwcUrl });
      window.webln = t5;
    }
  };
  var u4 = { "extension.generic": class extends p3 {
    constructor(e8) {
      super(e8);
    }
    async init() {
      await new Promise((e8) => setTimeout(e8, 1e3)), await super.init();
    }
  }, "nwc.alby": f4, "nwc.generic": f4 };
  function h4(e8) {
    const t5 = new Event(e8, { bubbles: true, composed: true });
    window.dispatchEvent(t5);
  }
  var g3 = createStore((e8) => ({ connector: void 0, config: void 0, setConfig: (t5) => {
    e8({ config: t5 });
  }, setConnector: (t5) => {
    e8({ connector: t5 });
  } }));
  var C2 = createStore((e8) => ({ route: "/start", connected: false, connecting: false, alias: void 0, balance: void 0, connectorName: void 0, connect: async (t5) => {
    h4("bc:connecting"), e8({ connecting: true });
    try {
      const o6 = new u4[t5.connectorType](t5);
      await o6.init();
      const n7 = await o6.getBalance(), r4 = await o6.getAlias();
      g3.getState().setConfig(t5), g3.getState().setConnector(o6), e8({ connected: true, connecting: false, balance: n7, alias: r4, connectorName: t5.connectorName }), h4("bc:connected");
    } catch (t6) {
      console.error(t6), e8({ connecting: false });
    }
    !function(e9) {
      window.localStorage.setItem("bc:config", JSON.stringify(e9));
    }(t5);
  }, disconnect: () => {
    g3.getState().setConfig(void 0), g3.getState().setConnector(void 0), e8({ connected: false, alias: void 0, balance: void 0, connectorName: void 0 }), window.localStorage.removeItem("bc:config"), h4("bc:disconnected");
  }, setAlias: (t5) => {
    e8({ alias: t5 });
  }, setBalance: (t5) => {
    e8({ balance: t5 });
  }, getConnectorName: () => {
    var e9;
    return null == (e9 = g3.getState().config) ? void 0 : e9.connectorName;
  }, setRoute: (t5) => {
    e8({ route: t5 });
  } }));
  var b2;
  !function() {
    const e8 = window.localStorage.getItem("bc:config");
    if (e8) {
      const t5 = JSON.parse(e8);
      C2.getState().connect(t5);
    }
  }(), window.addEventListener("webln:enabled", async () => {
    C2.getState().connecting || await C2.getState().connect({ connectorName: "Extension", connectorType: "extension.generic" });
  });
  var m2 = class extends s4 {
  };
  m2.styles = [i(b2 || (b2 = ((e8) => e8)`
      :host {
        all: initial;
        font-variant-numeric: slashed-zero;
      }
    `))];
  var y3 = class extends m2 {
    constructor() {
      super(), this._connected = false, this._connecting = false, this._connectorName = void 0, this._alias = void 0, this._balance = void 0, function() {
        if (!d3) {
          d3 = true;
          for (const e8 of ["Inter", "Roboto Mono"]) {
            const t5 = document.createElement("link");
            t5.href = `https://fonts.googleapis.com/css2?family=${e8}:wght@400;500;600;700&display=swap`, t5.rel = "stylesheet", document.head.appendChild(t5);
          }
        }
      }(), this._connected = C2.getState().connected, this._connecting = C2.getState().connecting, this._alias = C2.getState().alias, this._balance = C2.getState().balance, this._connectorName = C2.getState().connectorName, C2.subscribe((e8) => {
        this._connected = e8.connected, this._connecting = e8.connecting, this._alias = e8.alias, this._balance = e8.balance, this._connectorName = e8.connectorName;
      });
    }
    connectedCallback() {
      super.connectedCallback();
    }
  };
  function w3(e8) {
    return [...e8.v, (e8.i ? "!" : "") + e8.n].join(":");
  }
  function x3(e8, t5 = ",") {
    return e8.map(w3).join(t5);
  }
  c3([t3()], y3.prototype, "_connected", void 0), c3([t3()], y3.prototype, "_connecting", void 0), c3([t3()], y3.prototype, "_connectorName", void 0), c3([t3()], y3.prototype, "_alias", void 0), c3([t3()], y3.prototype, "_balance", void 0);
  var v3 = "undefined" != typeof CSS && CSS.escape || ((e8) => e8.replace(/[!"'`*+.,;:\\/<=>?@#$%&^|~()[\]{}]/g, "\\$&").replace(/^\d/, "\\3$& "));
  function L2(e8) {
    for (var t5 = 9, o6 = e8.length; o6--; )
      t5 = Math.imul(t5 ^ e8.charCodeAt(o6), 1597334677);
    return "#" + ((t5 ^ t5 >>> 9) >>> 0).toString(36);
  }
  function $2(e8, t5 = "@media ") {
    return t5 + k2(e8).map((e9) => ("string" == typeof e9 && (e9 = { min: e9 }), e9.raw || Object.keys(e9).map((t6) => `(${t6}-width:${e9[t6]})`).join(" and "))).join(",");
  }
  function k2(e8 = []) {
    return Array.isArray(e8) ? e8 : null == e8 ? [] : [e8];
  }
  function M2(e8) {
    return e8;
  }
  function S4() {
  }
  var _2 = { d: 0, b: 134217728, c: 268435456, a: 671088640, u: 805306368, o: 939524096 };
  function Z2(e8) {
    return e8.match(/[-=:;]/g)?.length || 0;
  }
  function F(e8) {
    return Math.min(/(?:^|width[^\d]+)(\d+(?:.\d+)?)(p)?/.test(e8) ? Math.max(0, 29.63 * (+RegExp.$1 / (RegExp.$2 ? 15 : 1)) ** 0.137 - 43) : 0, 15) << 22 | Math.min(Z2(e8), 15) << 18;
  }
  var O2 = ["rst-c", "st-ch", "h-chi", "y-lin", "nk", "sited", "ecked", "pty", "ad-on", "cus-w", "ver", "cus", "cus-v", "tive", "sable", "tiona", "quire"];
  function z2({ n: e8, i: t5, v: o6 = [] }, n7, r4, i4) {
    e8 && (e8 = w3({ n: e8, i: t5, v: o6 })), i4 = [...k2(i4)];
    for (let e9 of o6) {
      let t6 = n7.theme("screens", e9);
      for (let o7 of k2(t6 && $2(t6) || n7.v(e9)))
        i4.push(o7), r4 |= t6 ? 67108864 | F(o7) : "dark" == e9 ? 1073741824 : "@" == o7[0] ? F(o7) : 1 << ~(/:([a-z-]+)/.test(o7) && ~O2.indexOf(RegExp.$1.slice(2, 7)) || -18);
    }
    return { n: e8, p: r4, r: i4, i: t5 };
  }
  var A3 = /* @__PURE__ */ new Map();
  function j(e8) {
    if (e8.d) {
      let t5 = [], o6 = E3(e8.r.reduce((e9, o7) => "@" == o7[0] ? (t5.push(o7), e9) : o7 ? E3(e9, (e10) => E3(o7, (t6) => {
        let o8 = /(:merge\(.+?\))(:[a-z-]+|\\[.+])/.exec(t6);
        if (o8) {
          let n7 = e10.indexOf(o8[1]);
          return ~n7 ? e10.slice(0, n7) + o8[0] + e10.slice(n7 + o8[1].length) : R3(e10, t6);
        }
        return R3(t6, e10);
      })) : e9, "&"), (t6) => R3(t6, e8.n ? "." + v3(e8.n) : ""));
      return o6 && t5.push(o6.replace(/:merge\((.+?)\)/g, "$1")), t5.reduceRight((e9, t6) => t6 + "{" + e9 + "}", e8.d);
    }
  }
  function E3(e8, t5) {
    return e8.replace(/ *((?:\(.+?\)|\[.+?\]|[^,])+) *(,|$)/g, (e9, o6, n7) => t5(o6) + n7);
  }
  function R3(e8, t5) {
    return e8.replace(/&/g, t5);
  }
  var T3 = new Intl.Collator("en", { numeric: true });
  function V2(e8, t5) {
    for (var o6 = 0, n7 = e8.length; o6 < n7; ) {
      let r4 = n7 + o6 >> 1;
      0 >= D2(e8[r4], t5) ? o6 = r4 + 1 : n7 = r4;
    }
    return n7;
  }
  function D2(e8, t5) {
    let o6 = e8.p & _2.o;
    return o6 != (t5.p & _2.o) || o6 != _2.b && o6 != _2.o ? e8.p - t5.p || e8.o - t5.o || T3.compare(W(e8.n), W(t5.n)) || T3.compare(H2(e8.n), H2(t5.n)) : 0;
  }
  function W(e8) {
    return (e8 || "").split(/:/).pop().split("/").pop() || "\0";
  }
  function H2(e8) {
    return (e8 || "").replace(/\W/g, (e9) => String.fromCharCode(127 + e9.charCodeAt(0))) + "\0";
  }
  function U(e8, t5) {
    return Math.round(parseInt(e8, 16) * t5);
  }
  function B2(e8, t5 = {}) {
    if ("function" == typeof e8)
      return e8(t5);
    let { opacityValue: o6 = "1", opacityVariable: n7 } = t5, r4 = n7 ? `var(${n7})` : o6;
    if (e8.includes("<alpha-value>"))
      return e8.replace("<alpha-value>", r4);
    if ("#" == e8[0] && (4 == e8.length || 7 == e8.length)) {
      let t6 = (e8.length - 1) / 3, o7 = [17, 1, 0.062272][t6 - 1];
      return `rgba(${[U(e8.substr(1, t6), o7), U(e8.substr(1 + t6, t6), o7), U(e8.substr(1 + 2 * t6, t6), o7), r4]})`;
    }
    return "1" == r4 ? e8 : "0" == r4 ? "#0000" : e8.replace(/^(rgb|hsl)(\([^)]+)\)$/, `$1a$2,${r4})`);
  }
  function N2(e8, t5, o6, n7, r4 = []) {
    return function e9(t6, { n: o7, p: n8, r: r5 = [], i: i4 }, a3) {
      let l6 = [], s5 = "", c4 = 0, d4 = 0;
      for (let u5 in t6 || {}) {
        var p4, f5;
        let h5 = t6[u5];
        if ("@" == u5[0]) {
          if (!h5)
            continue;
          if ("a" == u5[1]) {
            l6.push(...Y(o7, n8, Q("" + h5), a3, n8, r5, i4, true));
            continue;
          }
          if ("l" == u5[1]) {
            for (let t7 of k2(h5))
              l6.push(...e9(t7, { n: o7, p: (p4 = _2[u5[7]], n8 & ~_2.o | p4), r: "d" == u5[7] ? [] : r5, i: i4 }, a3));
            continue;
          }
          if ("i" == u5[1]) {
            l6.push(...k2(h5).map((e10) => ({ p: -1, o: 0, r: [], d: u5 + " " + e10 })));
            continue;
          }
          if ("k" == u5[1]) {
            l6.push({ p: _2.d, o: 0, r: [u5], d: e9(h5, { p: _2.d }, a3).map(j).join("") });
            continue;
          }
          if ("f" == u5[1]) {
            l6.push(...k2(h5).map((t7) => ({ p: _2.d, o: 0, r: [u5], d: e9(t7, { p: _2.d }, a3).map(j).join("") })));
            continue;
          }
        }
        if ("object" != typeof h5 || Array.isArray(h5))
          "label" == u5 && h5 ? o7 = h5 + L2(JSON.stringify([n8, i4, t6])) : (h5 || 0 === h5) && (u5 = u5.replace(/[A-Z]/g, (e10) => "-" + e10.toLowerCase()), d4 += 1, c4 = Math.max(c4, "-" == (f5 = u5)[0] ? 0 : Z2(f5) + (/^(?:(border-(?!w|c|sty)|[tlbr].{2,4}m?$|c.{7,8}$)|([fl].{5}l|g.{8}$|pl))/.test(f5) ? +!!RegExp.$1 || -!!RegExp.$2 : 0) + 1), s5 += (s5 ? ";" : "") + k2(h5).map((e10) => a3.s(u5, I2("" + e10, a3.theme) + (i4 ? " !important" : ""))).join(";"));
        else if ("@" == u5[0] || u5.includes("&")) {
          let t7 = n8;
          "@" == u5[0] && (u5 = u5.replace(/\bscreen\(([^)]+)\)/g, (e10, o8) => {
            let n9 = a3.theme("screens", o8);
            return n9 ? (t7 |= 67108864, $2(n9, "")) : e10;
          }), t7 |= F(u5)), l6.push(...e9(h5, { n: o7, p: t7, r: [...r5, u5], i: i4 }, a3));
        } else
          l6.push(...e9(h5, { p: n8, r: [...r5, u5] }, a3));
      }
      return l6.unshift({ n: o7, p: n8, o: Math.max(0, 15 - d4) + 1.5 * Math.min(c4 || 15, 15), r: r5, d: s5 }), l6.sort(D2);
    }(e8, z2(t5, o6, n7, r4), o6);
  }
  function I2(e8, t5) {
    return e8.replace(/theme\((["'`])?(.+?)\1(?:\s*,\s*(["'`])?(.+?)\3)?\)/g, (e9, o6, n7, r4, i4 = "") => {
      let a3 = t5(n7, i4);
      return "function" == typeof a3 && /color|fill|stroke/i.test(n7) ? B2(a3) : "" + k2(a3).filter((e10) => Object(e10) !== e10);
    });
  }
  function P2(e8, t5) {
    let o6, n7 = [];
    for (let r4 of e8)
      r4.d && r4.n ? o6?.p == r4.p && "" + o6.r == "" + r4.r ? (o6.c = [o6.c, r4.c].filter(Boolean).join(" "), o6.d = o6.d + ";" + r4.d) : n7.push(o6 = { ...r4, n: r4.n && t5 }) : n7.push({ ...r4, n: r4.n && t5 });
    return n7;
  }
  function G(e8, t5, o6 = _2.u, n7, r4) {
    let i4 = [];
    for (let a3 of e8)
      for (let e9 of function(e10, t6, o7, n8, r5) {
        let i5 = function(e11, t7) {
          let o8 = A3.get(e11.n);
          return o8 ? o8(e11, t7) : t7.r(e11.n, "dark" == e11.v[0]);
        }(e10 = { ...e10, i: e10.i || r5 }, t6);
        return i5 ? "string" == typeof i5 ? ({ r: n8, p: o7 } = z2(e10, t6, o7, n8), P2(G(Q(i5), t6, o7, n8, e10.i), e10.n)) : Array.isArray(i5) ? i5.map((e11) => {
          var t7, r6;
          return { o: 0, ...e11, r: [...k2(n8), ...k2(e11.r)], p: (t7 = o7, r6 = e11.p ?? o7, t7 & ~_2.o | r6) };
        }) : N2(i5, e10, t6, o7, n8) : [{ c: w3(e10), p: 0, o: 0, r: [] }];
      }(a3, t5, o6, n7, r4))
        i4.splice(V2(i4, e9), 0, e9);
    return i4;
  }
  function Y(e8, t5, o6, n7, r4, i4, a3, l6) {
    return P2((l6 ? o6.flatMap((e9) => G([e9], n7, r4, i4, a3)) : G(o6, n7, r4, i4, a3)).map((e9) => e9.p & _2.o && (e9.n || t5 == _2.b) ? { ...e9, p: e9.p & ~_2.o | t5, o: 0 } : e9), e8);
  }
  function q2(e8, t5, o6, n7) {
    return A3.set(e8, (e9, r4) => {
      let { n: i4, p: a3, r: l6, i: s5 } = z2(e9, r4, t5);
      return o6 && Y(i4, t5, o6, r4, a3, l6, s5, n7);
    }), e8;
  }
  function J(e8, t5, o6) {
    if ("(" != e8[e8.length - 1]) {
      let o7 = [], n7 = false, r4 = false, i4 = "";
      for (let t6 of e8)
        if ("(" != t6 && !/[~@]$/.test(t6)) {
          if ("!" == t6[0] && (t6 = t6.slice(1), n7 = !n7), t6.endsWith(":")) {
            o7["dark:" == t6 ? "unshift" : "push"](t6.slice(0, -1));
            continue;
          }
          "-" == t6[0] && (t6 = t6.slice(1), r4 = !r4), t6.endsWith("-") && (t6 = t6.slice(0, -1)), t6 && "&" != t6 && (i4 += (i4 && "-") + t6);
        }
      i4 && (r4 && (i4 = "-" + i4), t5[0].push({ n: i4, v: o7.filter(X), i: n7 }));
    }
  }
  function X(e8, t5, o6) {
    return o6.indexOf(e8) == t5;
  }
  var K = /* @__PURE__ */ new Map();
  function Q(e8) {
    let t5 = K.get(e8);
    if (!t5) {
      let o6 = [], n7 = [[]], r4 = 0, i4 = 0, a3 = null, l6 = 0, s5 = (t6, i5 = 0) => {
        r4 != l6 && (o6.push(e8.slice(r4, l6 + i5)), t6 && J(o6, n7)), r4 = l6 + 1;
      };
      for (; l6 < e8.length; l6++) {
        let t6 = e8[l6];
        if (i4)
          "\\" != e8[l6 - 1] && (i4 += +("[" == t6) || -("]" == t6));
        else if ("[" == t6)
          i4 += 1;
        else if (a3)
          "\\" != e8[l6 - 1] && a3.test(e8.slice(l6)) && (a3 = null, r4 = l6 + RegExp.lastMatch.length);
        else if ("/" != t6 || "\\" == e8[l6 - 1] || "*" != e8[l6 + 1] && "/" != e8[l6 + 1])
          if ("(" == t6)
            s5(), o6.push(t6);
          else if (":" == t6)
            ":" != e8[l6 + 1] && s5(false, 1);
          else if (/[\s,)]/.test(t6)) {
            s5(true);
            let e9 = o6.lastIndexOf("(");
            if (")" == t6) {
              let t7 = o6[e9 - 1];
              if (/[~@]$/.test(t7)) {
                let r5 = n7.shift();
                o6.length = e9, J([...o6, "#"], n7);
                let { v: i5 } = n7[0].pop();
                for (let e10 of r5)
                  e10.v.splice(+("dark" == e10.v[0]) - +("dark" == i5[0]), i5.length);
                J([...o6, q2(t7.length > 1 ? t7.slice(0, -1) + L2(JSON.stringify([t7, r5])) : t7 + "(" + x3(r5) + ")", _2.a, r5, /@$/.test(t7))], n7);
              }
              e9 = o6.lastIndexOf("(", e9 - 1);
            }
            o6.length = e9 + 1;
          } else
            /[~@]/.test(t6) && "(" == e8[l6 + 1] && n7.unshift([]);
        else
          a3 = "*" == e8[l6 + 1] ? /^\*\// : /^[\r\n]/;
      }
      s5(true), K.set(e8, t5 = n7[0]);
    }
    return t5;
  }
  function ee(e8, t5, o6) {
    return [e8, te(t5, o6)];
  }
  function te(e8, t5) {
    return "function" == typeof e8 ? e8 : "string" == typeof e8 && /^[\w-]+$/.test(e8) ? (o6, n7) => ({ [e8]: t5 ? t5(o6, n7) : oe(o6, 1) }) : (t6) => e8 || { [t6[1]]: oe(t6, 2) };
  }
  function oe(e8, t5, o6 = e8.slice(t5).find(Boolean) || e8.$$ || e8.input) {
    return "-" == e8.input[0] ? `calc(${o6} * -1)` : o6;
  }
  function ne(e8, t5, o6, n7) {
    return [e8, re(t5, o6, n7)];
  }
  function re(e8, t5, o6) {
    let n7 = "string" == typeof t5 ? (e9, n8) => ({ [t5]: o6 ? o6(e9, n8) : e9._ }) : t5 || (({ 1: e9, _: t6 }, o7, n8) => ({ [e9 || n8]: t6 }));
    return (t6, o7) => {
      let r4 = ce(e8 || t6[1]), i4 = o7.theme(r4, t6.$$) ?? se(t6.$$, r4, o7);
      if (null != i4)
        return t6._ = oe(t6, 0, i4), n7(t6, o7, r4);
    };
  }
  function ie(e8, t5 = {}, o6) {
    return [e8, ae(t5, o6)];
  }
  function ae(e8 = {}, t5) {
    return (o6, n7) => {
      let { section: r4 = ce(o6[0]).replace("-", "") + "Color" } = e8, [i4, a3] = (o6.$$.match(/^(\[[^\]]+]|[^/]+?)(?:\/(.+))?$/) || []).slice(1);
      if (!i4)
        return;
      let l6 = n7.theme(r4, i4) || se(i4, r4, n7);
      if (!l6 || "object" == typeof l6)
        return;
      let { opacityVariable: s5 = `--tw-${o6[0].replace(/-$/, "")}-opacity`, opacitySection: c4 = r4.replace("Color", "Opacity"), property: d4 = r4, selector: p4 } = e8, f5 = n7.theme(c4, a3 || "DEFAULT") || a3 && se(a3, c4, n7), u5 = t5 || (({ _: e9 }) => {
        let t6 = le(d4, e9);
        return p4 ? { [p4]: t6 } : t6;
      });
      o6._ = { value: B2(l6, { opacityVariable: s5 || void 0, opacityValue: f5 || void 0 }), color: (e9) => B2(l6, e9), opacityVariable: s5 || void 0, opacityValue: f5 || void 0 };
      let h5 = u5(o6, n7);
      if (!o6.dark) {
        let e9 = n7.d(r4, i4, l6);
        e9 && e9 !== l6 && (o6._ = { value: B2(e9, { opacityVariable: s5 || void 0, opacityValue: f5 || "1" }), color: (t6) => B2(e9, t6), opacityVariable: s5 || void 0, opacityValue: f5 || void 0 }, h5 = { "&": h5, [n7.v("dark")]: u5(o6, n7) });
      }
      return h5;
    };
  }
  function le(e8, t5) {
    let o6 = {};
    return "string" == typeof t5 ? o6[e8] = t5 : (t5.opacityVariable && t5.value.includes(t5.opacityVariable) && (o6[t5.opacityVariable] = t5.opacityValue || "1"), o6[e8] = t5.value), o6;
  }
  function se(e8, t5, o6) {
    if ("[" == e8[0] && "]" == e8.slice(-1)) {
      if (e8 = de(I2(e8.slice(1, -1), o6.theme)), !t5)
        return e8;
      if (!(/color|fill|stroke/i.test(t5) && !/^color:/.test(e8) && !/^(#|((hsl|rgb)a?|hwb|lab|lch|color)\(|[a-z]+$)/.test(e8) || /image/i.test(t5) && !/^image:/.test(e8) && !/^[a-z-]+\(/.test(e8) || /weight/i.test(t5) && !/^(number|any):/.test(e8) && !/^\d+$/.test(e8) || /position/i.test(t5) && /^(length|size):/.test(e8)))
        return e8.replace(/^[a-z-]+:/, "");
    }
  }
  function ce(e8) {
    return e8.replace(/-./g, (e9) => e9[1].toUpperCase());
  }
  function de(e8) {
    return e8.includes("url(") ? e8.replace(/(.*?)(url\(.*?\))(.*?)/g, (e9, t5 = "", o6, n7 = "") => de(t5) + o6 + de(n7)) : e8.replace(/(^|[^\\])_+/g, (e9, t5) => t5 + " ".repeat(e9.length - t5.length)).replace(/\\_/g, "_").replace(/(calc|min|max|clamp)\(.+\)/g, (e9) => e9.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 "));
  }
  function pe({ presets: e8 = [], ...t5 }) {
    let o6 = { darkMode: void 0, darkColor: void 0, preflight: false !== t5.preflight && [], theme: {}, variants: k2(t5.variants), rules: k2(t5.rules), ignorelist: k2(t5.ignorelist), hash: void 0, stringify: (e9, t6) => e9 + ":" + t6, finalize: [] };
    for (let n7 of k2([...e8, { darkMode: t5.darkMode, darkColor: t5.darkColor, preflight: false !== t5.preflight && k2(t5.preflight), theme: t5.theme, hash: t5.hash, stringify: t5.stringify, finalize: t5.finalize }])) {
      let { preflight: e9, darkMode: t6 = o6.darkMode, darkColor: r4 = o6.darkColor, theme: i4, variants: a3, rules: l6, ignorelist: s5, hash: c4 = o6.hash, stringify: d4 = o6.stringify, finalize: p4 } = "function" == typeof n7 ? n7(o6) : n7;
      o6 = { preflight: false !== o6.preflight && false !== e9 && [...o6.preflight, ...k2(e9)], darkMode: t6, darkColor: r4, theme: { ...o6.theme, ...i4, extend: { ...o6.theme.extend, ...i4?.extend } }, variants: [...o6.variants, ...k2(a3)], rules: [...o6.rules, ...k2(l6)], ignorelist: [...o6.ignorelist, ...k2(s5)], hash: c4, stringify: d4, finalize: [...o6.finalize, ...k2(p4)] };
    }
    return o6;
  }
  function fe2(e8, t5, o6, n7, r4, i4) {
    for (let a3 of t5) {
      let t6 = o6.get(a3);
      t6 || o6.set(a3, t6 = n7(a3));
      let l6 = t6(e8, r4, i4);
      if (l6)
        return l6;
    }
  }
  function ue(e8) {
    var t5;
    return ge2(e8[0], "function" == typeof (t5 = e8[1]) ? t5 : () => t5);
  }
  function he(e8) {
    return Array.isArray(e8) ? ge2(e8[0], te(e8[1], e8[2])) : ge2(e8, te(void 0, void 0));
  }
  function ge2(e8, t5) {
    return Ce(e8, (e9, o6, n7, r4) => {
      let i4 = o6.exec(e9);
      if (i4)
        return i4.$$ = e9.slice(i4[0].length), i4.dark = r4, t5(i4, n7);
    });
  }
  function Ce(e8, t5) {
    let o6 = k2(e8).map(be);
    return (e9, n7, r4) => {
      for (let i4 of o6) {
        let o7 = t5(e9, i4, n7, r4);
        if (o7)
          return o7;
      }
    };
  }
  function be(e8) {
    return "string" == typeof e8 ? RegExp("^" + e8 + (e8.includes("$") || "-" == e8.slice(-1) ? "" : "$")) : e8;
  }
  function me(e8) {
    let t5 = e8?.cssRules ? e8 : (e8 && "string" != typeof e8 ? e8 : function(e9) {
      let t6 = document.querySelector(e9 || 'style[data-twind=""]');
      return t6 && "STYLE" == t6.tagName || (t6 = document.createElement("style"), document.head.prepend(t6)), t6.dataset.twind = "claimed", t6;
    }(e8)).sheet;
    return { target: t5, snapshot() {
      let e9 = Array.from(t5.cssRules, (e10) => e10.cssText);
      return () => {
        this.clear(), e9.forEach(this.insert);
      };
    }, clear() {
      for (let e9 = t5.cssRules.length; e9--; )
        t5.deleteRule(e9);
    }, destroy() {
      t5.ownerNode?.remove();
    }, insert(e9, o6) {
      try {
        t5.insertRule(e9, o6);
      } catch (e10) {
        t5.insertRule(":root{}", o6);
      }
    }, resume: S4 };
  }
  var ye = { screens: { sm: "640px", md: "768px", lg: "1024px", xl: "1280px", "2xl": "1536px" }, columns: { auto: "auto", "3xs": "16rem", "2xs": "18rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem" }, spacing: { px: "1px", 0: "0px", .../* @__PURE__ */ ve(4, "rem", 4, 0.5, 0.5), .../* @__PURE__ */ ve(12, "rem", 4, 5), 14: "3.5rem", .../* @__PURE__ */ ve(64, "rem", 4, 16, 4), 72: "18rem", 80: "20rem", 96: "24rem" }, durations: { 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1e3: "1000ms" }, animation: { none: "none", spin: "spin 1s linear infinite", ping: "ping 1s cubic-bezier(0,0,0.2,1) infinite", pulse: "pulse 2s cubic-bezier(0.4,0,0.6,1) infinite", bounce: "bounce 1s infinite" }, aspectRatio: { auto: "auto", square: "1/1", video: "16/9" }, backdropBlur: /* @__PURE__ */ Le("blur"), backdropBrightness: /* @__PURE__ */ Le("brightness"), backdropContrast: /* @__PURE__ */ Le("contrast"), backdropGrayscale: /* @__PURE__ */ Le("grayscale"), backdropHueRotate: /* @__PURE__ */ Le("hueRotate"), backdropInvert: /* @__PURE__ */ Le("invert"), backdropOpacity: /* @__PURE__ */ Le("opacity"), backdropSaturate: /* @__PURE__ */ Le("saturate"), backdropSepia: /* @__PURE__ */ Le("sepia"), backgroundColor: /* @__PURE__ */ Le("colors"), backgroundImage: { none: "none" }, backgroundOpacity: /* @__PURE__ */ Le("opacity"), backgroundSize: { auto: "auto", cover: "cover", contain: "contain" }, blur: { none: "none", 0: "0", sm: "4px", DEFAULT: "8px", md: "12px", lg: "16px", xl: "24px", "2xl": "40px", "3xl": "64px" }, brightness: { .../* @__PURE__ */ ve(200, "", 100, 0, 50), .../* @__PURE__ */ ve(110, "", 100, 90, 5), 75: "0.75", 125: "1.25" }, borderColor: ({ theme: e8 }) => ({ DEFAULT: e8("colors.gray.200", "currentColor"), ...e8("colors") }), borderOpacity: /* @__PURE__ */ Le("opacity"), borderRadius: { none: "0px", sm: "0.125rem", DEFAULT: "0.25rem", md: "0.375rem", lg: "0.5rem", xl: "0.75rem", "2xl": "1rem", "3xl": "1.5rem", "1/2": "50%", full: "9999px" }, borderSpacing: /* @__PURE__ */ Le("spacing"), borderWidth: { DEFAULT: "1px", .../* @__PURE__ */ xe(8, "px") }, boxShadow: { sm: "0 1px 2px 0 rgba(0,0,0,0.05)", DEFAULT: "0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px -1px rgba(0,0,0,0.1)", md: "0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1)", lg: "0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -4px rgba(0,0,0,0.1)", xl: "0 20px 25px -5px rgba(0,0,0,0.1), 0 8px 10px -6px rgba(0,0,0,0.1)", "2xl": "0 25px 50px -12px rgba(0,0,0,0.25)", inner: "inset 0 2px 4px 0 rgba(0,0,0,0.05)", none: "0 0 #0000" }, boxShadowColor: Le("colors"), caretColor: /* @__PURE__ */ Le("colors"), accentColor: ({ theme: e8 }) => ({ auto: "auto", ...e8("colors") }), contrast: { .../* @__PURE__ */ ve(200, "", 100, 0, 50), 75: "0.75", 125: "1.25" }, content: { none: "none" }, divideColor: /* @__PURE__ */ Le("borderColor"), divideOpacity: /* @__PURE__ */ Le("borderOpacity"), divideWidth: /* @__PURE__ */ Le("borderWidth"), dropShadow: { sm: "0 1px 1px rgba(0,0,0,0.05)", DEFAULT: ["0 1px 2px rgba(0,0,0,0.1)", "0 1px 1px rgba(0,0,0,0.06)"], md: ["0 4px 3px rgba(0,0,0,0.07)", "0 2px 2px rgba(0,0,0,0.06)"], lg: ["0 10px 8px rgba(0,0,0,0.04)", "0 4px 3px rgba(0,0,0,0.1)"], xl: ["0 20px 13px rgba(0,0,0,0.03)", "0 8px 5px rgba(0,0,0,0.08)"], "2xl": "0 25px 25px rgba(0,0,0,0.15)", none: "0 0 #0000" }, fill: ({ theme: e8 }) => ({ ...e8("colors"), none: "none" }), grayscale: { DEFAULT: "100%", 0: "0" }, hueRotate: { 0: "0deg", 15: "15deg", 30: "30deg", 60: "60deg", 90: "90deg", 180: "180deg" }, invert: { DEFAULT: "100%", 0: "0" }, flex: { 1: "1 1 0%", auto: "1 1 auto", initial: "0 1 auto", none: "none" }, flexBasis: ({ theme: e8 }) => ({ ...e8("spacing"), ...we(2, 6), ...we(12, 12), auto: "auto", full: "100%" }), flexGrow: { DEFAULT: 1, 0: 0 }, flexShrink: { DEFAULT: 1, 0: 0 }, fontFamily: { sans: 'ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji"'.split(","), serif: 'ui-serif,Georgia,Cambria,"Times New Roman",Times,serif'.split(","), mono: 'ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'.split(",") }, fontSize: { xs: ["0.75rem", "1rem"], sm: ["0.875rem", "1.25rem"], base: ["1rem", "1.5rem"], lg: ["1.125rem", "1.75rem"], xl: ["1.25rem", "1.75rem"], "2xl": ["1.5rem", "2rem"], "3xl": ["1.875rem", "2.25rem"], "4xl": ["2.25rem", "2.5rem"], "5xl": ["3rem", "1"], "6xl": ["3.75rem", "1"], "7xl": ["4.5rem", "1"], "8xl": ["6rem", "1"], "9xl": ["8rem", "1"] }, fontWeight: { thin: "100", extralight: "200", light: "300", normal: "400", medium: "500", semibold: "600", bold: "700", extrabold: "800", black: "900" }, gap: /* @__PURE__ */ Le("spacing"), gradientColorStops: /* @__PURE__ */ Le("colors"), gridAutoColumns: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0,1fr)" }, gridAutoRows: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0,1fr)" }, gridColumn: { auto: "auto", "span-full": "1 / -1" }, gridRow: { auto: "auto", "span-full": "1 / -1" }, gridTemplateColumns: { none: "none" }, gridTemplateRows: { none: "none" }, height: ({ theme: e8 }) => ({ ...e8("spacing"), ...we(2, 6), min: "min-content", max: "max-content", fit: "fit-content", auto: "auto", full: "100%", screen: "100vh" }), inset: ({ theme: e8 }) => ({ ...e8("spacing"), ...we(2, 4), auto: "auto", full: "100%" }), keyframes: { spin: { from: { transform: "rotate(0deg)" }, to: { transform: "rotate(360deg)" } }, ping: { "0%": { transform: "scale(1)", opacity: "1" }, "75%,100%": { transform: "scale(2)", opacity: "0" } }, pulse: { "0%,100%": { opacity: "1" }, "50%": { opacity: ".5" } }, bounce: { "0%, 100%": { transform: "translateY(-25%)", animationTimingFunction: "cubic-bezier(0.8,0,1,1)" }, "50%": { transform: "none", animationTimingFunction: "cubic-bezier(0,0,0.2,1)" } } }, letterSpacing: { tighter: "-0.05em", tight: "-0.025em", normal: "0em", wide: "0.025em", wider: "0.05em", widest: "0.1em" }, lineHeight: { .../* @__PURE__ */ ve(10, "rem", 4, 3), none: "1", tight: "1.25", snug: "1.375", normal: "1.5", relaxed: "1.625", loose: "2" }, margin: ({ theme: e8 }) => ({ auto: "auto", ...e8("spacing") }), maxHeight: ({ theme: e8 }) => ({ full: "100%", min: "min-content", max: "max-content", fit: "fit-content", screen: "100vh", ...e8("spacing") }), maxWidth: ({ theme: e8, breakpoints: t5 }) => ({ ...t5(e8("screens")), none: "none", 0: "0rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", prose: "65ch" }), minHeight: { 0: "0px", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", screen: "100vh" }, minWidth: { 0: "0px", full: "100%", min: "min-content", max: "max-content", fit: "fit-content" }, opacity: { .../* @__PURE__ */ ve(100, "", 100, 0, 10), 5: "0.05", 25: "0.25", 75: "0.75", 95: "0.95" }, order: { first: "-9999", last: "9999", none: "0" }, padding: /* @__PURE__ */ Le("spacing"), placeholderColor: /* @__PURE__ */ Le("colors"), placeholderOpacity: /* @__PURE__ */ Le("opacity"), outlineColor: /* @__PURE__ */ Le("colors"), outlineOffset: /* @__PURE__ */ xe(8, "px"), outlineWidth: /* @__PURE__ */ xe(8, "px"), ringColor: ({ theme: e8 }) => ({ ...e8("colors"), DEFAULT: "#3b82f6" }), ringOffsetColor: /* @__PURE__ */ Le("colors"), ringOffsetWidth: /* @__PURE__ */ xe(8, "px"), ringOpacity: ({ theme: e8 }) => ({ ...e8("opacity"), DEFAULT: "0.5" }), ringWidth: { DEFAULT: "3px", .../* @__PURE__ */ xe(8, "px") }, rotate: { .../* @__PURE__ */ xe(2, "deg"), .../* @__PURE__ */ xe(12, "deg", 3), .../* @__PURE__ */ xe(180, "deg", 45) }, saturate: /* @__PURE__ */ ve(200, "", 100, 0, 50), scale: { .../* @__PURE__ */ ve(150, "", 100, 0, 50), .../* @__PURE__ */ ve(110, "", 100, 90, 5), 75: "0.75", 125: "1.25" }, scrollMargin: /* @__PURE__ */ Le("spacing"), scrollPadding: /* @__PURE__ */ Le("spacing"), sepia: { 0: "0", DEFAULT: "100%" }, skew: { .../* @__PURE__ */ xe(2, "deg"), .../* @__PURE__ */ xe(12, "deg", 3) }, space: /* @__PURE__ */ Le("spacing"), stroke: ({ theme: e8 }) => ({ ...e8("colors"), none: "none" }), strokeWidth: /* @__PURE__ */ ve(2), textColor: /* @__PURE__ */ Le("colors"), textDecorationColor: /* @__PURE__ */ Le("colors"), textDecorationThickness: { "from-font": "from-font", auto: "auto", .../* @__PURE__ */ xe(8, "px") }, textUnderlineOffset: { auto: "auto", .../* @__PURE__ */ xe(8, "px") }, textIndent: /* @__PURE__ */ Le("spacing"), textOpacity: /* @__PURE__ */ Le("opacity"), transitionDuration: ({ theme: e8 }) => ({ ...e8("durations"), DEFAULT: "150ms" }), transitionDelay: /* @__PURE__ */ Le("durations"), transitionProperty: { none: "none", all: "all", DEFAULT: "color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter", colors: "color,background-color,border-color,text-decoration-color,fill,stroke", opacity: "opacity", shadow: "box-shadow", transform: "transform" }, transitionTimingFunction: { DEFAULT: "cubic-bezier(0.4,0,0.2,1)", linear: "linear", in: "cubic-bezier(0.4,0,1,1)", out: "cubic-bezier(0,0,0.2,1)", "in-out": "cubic-bezier(0.4,0,0.2,1)" }, translate: ({ theme: e8 }) => ({ ...e8("spacing"), ...we(2, 4), full: "100%" }), width: ({ theme: e8 }) => ({ min: "min-content", max: "max-content", fit: "fit-content", screen: "100vw", ...e8("flexBasis") }), willChange: { scroll: "scroll-position" }, zIndex: { .../* @__PURE__ */ ve(50, "", 1, 0, 10), auto: "auto" } };
  function we(e8, t5) {
    let o6 = {};
    do {
      for (var n7 = 1; n7 < e8; n7++)
        o6[`${n7}/${e8}`] = Number((n7 / e8 * 100).toFixed(6)) + "%";
    } while (++e8 <= t5);
    return o6;
  }
  function xe(e8, t5, o6 = 0) {
    let n7 = {};
    for (; o6 <= e8; o6 = 2 * o6 || 1)
      n7[o6] = o6 + t5;
    return n7;
  }
  function ve(e8, t5 = "", o6 = 1, n7 = 0, r4 = 1, i4 = {}) {
    for (; n7 <= e8; n7 += r4)
      i4[n7] = n7 / o6 + t5;
    return i4;
  }
  function Le(e8) {
    return ({ theme: t5 }) => t5(e8);
  }
  var $e = { "*,::before,::after": { boxSizing: "border-box", borderWidth: "0", borderStyle: "solid", borderColor: "theme(borderColor.DEFAULT, currentColor)" }, "::before,::after": { "--tw-content": "''" }, html: { lineHeight: 1.5, WebkitTextSizeAdjust: "100%", MozTabSize: "4", tabSize: 4, fontFamily: `theme(fontFamily.sans, ${ye.fontFamily.sans})`, fontFeatureSettings: "theme(fontFamily.sans[1].fontFeatureSettings, normal)" }, body: { margin: "0", lineHeight: "inherit" }, hr: { height: "0", color: "inherit", borderTopWidth: "1px" }, "abbr:where([title])": { textDecoration: "underline dotted" }, "h1,h2,h3,h4,h5,h6": { fontSize: "inherit", fontWeight: "inherit" }, a: { color: "inherit", textDecoration: "inherit" }, "b,strong": { fontWeight: "bolder" }, "code,kbd,samp,pre": { fontFamily: `theme(fontFamily.mono, ${ye.fontFamily.mono})`, fontFeatureSettings: "theme(fontFamily.mono[1].fontFeatureSettings, normal)", fontSize: "1em" }, small: { fontSize: "80%" }, "sub,sup": { fontSize: "75%", lineHeight: 0, position: "relative", verticalAlign: "baseline" }, sub: { bottom: "-0.25em" }, sup: { top: "-0.5em" }, table: { textIndent: "0", borderColor: "inherit", borderCollapse: "collapse" }, "button,input,optgroup,select,textarea": { fontFamily: "inherit", fontSize: "100%", lineHeight: "inherit", color: "inherit", margin: "0", padding: "0" }, "button,select": { textTransform: "none" }, "button,[type='button'],[type='reset'],[type='submit']": { WebkitAppearance: "button", backgroundColor: "transparent", backgroundImage: "none" }, ":-moz-focusring": { outline: "auto" }, ":-moz-ui-invalid": { boxShadow: "none" }, progress: { verticalAlign: "baseline" }, "::-webkit-inner-spin-button,::-webkit-outer-spin-button": { height: "auto" }, "[type='search']": { WebkitAppearance: "textfield", outlineOffset: "-2px" }, "::-webkit-search-decoration": { WebkitAppearance: "none" }, "::-webkit-file-upload-button": { WebkitAppearance: "button", font: "inherit" }, summary: { display: "list-item" }, "blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre": { margin: "0" }, fieldset: { margin: "0", padding: "0" }, legend: { padding: "0" }, "ol,ul,menu": { listStyle: "none", margin: "0", padding: "0" }, textarea: { resize: "vertical" }, "input::placeholder,textarea::placeholder": { opacity: 1, color: "theme(colors.gray.400, #9ca3af)" }, 'button,[role="button"]': { cursor: "pointer" }, ":disabled": { cursor: "default" }, "img,svg,video,canvas,audio,iframe,embed,object": { display: "block", verticalAlign: "middle" }, "img,video": { maxWidth: "100%", height: "auto" }, "[hidden]": { display: "none" } };
  var ke = [ee("\\[([-\\w]+):(.+)]", ({ 1: e8, 2: t5 }, o6) => ({ "@layer overrides": { "&": { [e8]: se(`[${t5}]`, "", o6) } } })), ee("(group|peer)([~/][^-[]+)?", ({ input: e8 }, { h: t5 }) => [{ c: t5(e8) }]), ne("aspect-", "aspectRatio"), ee("container", (e8, { theme: t5 }) => {
    let { screens: o6 = t5("screens"), center: n7, padding: r4 } = t5("container"), i4 = { width: "100%", marginRight: n7 && "auto", marginLeft: n7 && "auto", ...a3("xs") };
    for (let e9 in o6) {
      let t6 = o6[e9];
      "string" == typeof t6 && (i4[$2(t6)] = { "&": { maxWidth: t6, ...a3(e9) } });
    }
    return i4;
    function a3(e9) {
      let t6 = r4 && ("string" == typeof r4 ? r4 : r4[e9] || r4.DEFAULT);
      if (t6)
        return { paddingRight: t6, paddingLeft: t6 };
    }
  }), ne("content-", "content", ({ _: e8 }) => ({ "--tw-content": e8, content: "var(--tw-content)" })), ee("(?:box-)?decoration-(slice|clone)", "boxDecorationBreak"), ee("box-(border|content)", "boxSizing", ({ 1: e8 }) => e8 + "-box"), ee("hidden", { display: "none" }), ee("table-(auto|fixed)", "tableLayout"), ee(["(block|flex|table|grid|inline|contents|flow-root|list-item)", "(inline-(block|flex|table|grid))", "(table-(caption|cell|column|row|(column|row|footer|header)-group))"], "display"), "(float)-(left|right|none)", "(clear)-(left|right|none|both)", "(overflow(?:-[xy])?)-(auto|hidden|clip|visible|scroll)", "(isolation)-(auto)", ee("isolate", "isolation"), ee("object-(contain|cover|fill|none|scale-down)", "objectFit"), ne("object-", "objectPosition"), ee("object-(top|bottom|center|(left|right)(-(top|bottom))?)", "objectPosition", Me), ee("overscroll(-[xy])?-(auto|contain|none)", ({ 1: e8 = "", 2: t5 }) => ({ ["overscroll-behavior" + e8]: t5 })), ee("(static|fixed|absolute|relative|sticky)", "position"), ne("-?inset(-[xy])?(?:$|-)", "inset", ({ 1: e8, _: t5 }) => ({ top: "-x" != e8 && t5, right: "-y" != e8 && t5, bottom: "-x" != e8 && t5, left: "-y" != e8 && t5 })), ne("-?(top|bottom|left|right)(?:$|-)", "inset"), ee("(visible|collapse)", "visibility"), ee("invisible", { visibility: "hidden" }), ne("-?z-", "zIndex"), ee("flex-((row|col)(-reverse)?)", "flexDirection", Se), ee("flex-(wrap|wrap-reverse|nowrap)", "flexWrap"), ne("(flex-(?:grow|shrink))(?:$|-)"), ne("(flex)-"), ne("grow(?:$|-)", "flexGrow"), ne("shrink(?:$|-)", "flexShrink"), ne("basis-", "flexBasis"), ne("-?(order)-"), "-?(order)-(\\d+)", ne("grid-cols-", "gridTemplateColumns"), ee("grid-cols-(\\d+)", "gridTemplateColumns", Te), ne("col-", "gridColumn"), ee("col-(span)-(\\d+)", "gridColumn", Re), ne("col-start-", "gridColumnStart"), ee("col-start-(auto|\\d+)", "gridColumnStart"), ne("col-end-", "gridColumnEnd"), ee("col-end-(auto|\\d+)", "gridColumnEnd"), ne("grid-rows-", "gridTemplateRows"), ee("grid-rows-(\\d+)", "gridTemplateRows", Te), ne("row-", "gridRow"), ee("row-(span)-(\\d+)", "gridRow", Re), ne("row-start-", "gridRowStart"), ee("row-start-(auto|\\d+)", "gridRowStart"), ne("row-end-", "gridRowEnd"), ee("row-end-(auto|\\d+)", "gridRowEnd"), ee("grid-flow-((row|col)(-dense)?)", "gridAutoFlow", (e8) => Me(Se(e8))), ee("grid-flow-(dense)", "gridAutoFlow"), ne("auto-cols-", "gridAutoColumns"), ne("auto-rows-", "gridAutoRows"), ne("gap-x(?:$|-)", "gap", "columnGap"), ne("gap-y(?:$|-)", "gap", "rowGap"), ne("gap(?:$|-)", "gap"), "(justify-(?:items|self))-", ee("justify-", "justifyContent", Fe), ee("(content|items|self)-", (e8) => ({ ["align-" + e8[1]]: Fe(e8) })), ee("(place-(content|items|self))-", ({ 1: e8, $$: t5 }) => ({ [e8]: ("wun".includes(t5[3]) ? "space-" : "") + t5 })), ne("p([xytrbl])?(?:$|-)", "padding", Oe("padding")), ne("-?m([xytrbl])?(?:$|-)", "margin", Oe("margin")), ne("-?space-(x|y)(?:$|-)", "space", ({ 1: e8, _: t5 }) => ({ "&>:not([hidden])~:not([hidden])": { [`--tw-space-${e8}-reverse`]: "0", ["margin-" + { y: "top", x: "left" }[e8]]: `calc(${t5} * calc(1 - var(--tw-space-${e8}-reverse)))`, ["margin-" + { y: "bottom", x: "right" }[e8]]: `calc(${t5} * var(--tw-space-${e8}-reverse))` } })), ee("space-(x|y)-reverse", ({ 1: e8 }) => ({ "&>:not([hidden])~:not([hidden])": { [`--tw-space-${e8}-reverse`]: "1" } })), ne("w-", "width"), ne("min-w-", "minWidth"), ne("max-w-", "maxWidth"), ne("h-", "height"), ne("min-h-", "minHeight"), ne("max-h-", "maxHeight"), ne("font-", "fontWeight"), ne("font-", "fontFamily", ({ _: e8 }) => "string" == typeof (e8 = k2(e8))[1] ? { fontFamily: Ze(e8) } : { fontFamily: Ze(e8[0]), ...e8[1] }), ee("antialiased", { WebkitFontSmoothing: "antialiased", MozOsxFontSmoothing: "grayscale" }), ee("subpixel-antialiased", { WebkitFontSmoothing: "auto", MozOsxFontSmoothing: "auto" }), ee("italic", "fontStyle"), ee("not-italic", { fontStyle: "normal" }), ee("(ordinal|slashed-zero|(normal|lining|oldstyle|proportional|tabular)-nums|(diagonal|stacked)-fractions)", ({ 1: e8, 2: t5 = "", 3: o6 }) => "normal" == t5 ? { fontVariantNumeric: "normal" } : { ["--tw-" + (o6 ? "numeric-fraction" : "pt".includes(t5[0]) ? "numeric-spacing" : t5 ? "numeric-figure" : e8)]: e8, fontVariantNumeric: "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)", ...Ve({ "--tw-ordinal": "var(--tw-empty,/*!*/ /*!*/)", "--tw-slashed-zero": "var(--tw-empty,/*!*/ /*!*/)", "--tw-numeric-figure": "var(--tw-empty,/*!*/ /*!*/)", "--tw-numeric-spacing": "var(--tw-empty,/*!*/ /*!*/)", "--tw-numeric-fraction": "var(--tw-empty,/*!*/ /*!*/)" }) }), ne("tracking-", "letterSpacing"), ne("leading-", "lineHeight"), ee("list-(inside|outside)", "listStylePosition"), ne("list-", "listStyleType"), ee("list-", "listStyleType"), ne("placeholder-opacity-", "placeholderOpacity", ({ _: e8 }) => ({ "&::placeholder": { "--tw-placeholder-opacity": e8 } })), ie("placeholder-", { property: "color", selector: "&::placeholder" }), ee("text-(left|center|right|justify|start|end)", "textAlign"), ee("text-(ellipsis|clip)", "textOverflow"), ne("text-opacity-", "textOpacity", "--tw-text-opacity"), ie("text-", { property: "color" }), ne("text-", "fontSize", ({ _: e8 }) => "string" == typeof e8 ? { fontSize: e8 } : { fontSize: e8[0], ..."string" == typeof e8[1] ? { lineHeight: e8[1] } : e8[1] }), ne("indent-", "textIndent"), ee("(overline|underline|line-through)", "textDecorationLine"), ee("no-underline", { textDecorationLine: "none" }), ne("underline-offset-", "textUnderlineOffset"), ie("decoration-", { section: "textDecorationColor", opacityVariable: false, opacitySection: "opacity" }), ne("decoration-", "textDecorationThickness"), ee("decoration-", "textDecorationStyle"), ee("(uppercase|lowercase|capitalize)", "textTransform"), ee("normal-case", { textTransform: "none" }), ee("truncate", { overflow: "hidden", whiteSpace: "nowrap", textOverflow: "ellipsis" }), ee("align-", "verticalAlign"), ee("whitespace-", "whiteSpace"), ee("break-normal", { wordBreak: "normal", overflowWrap: "normal" }), ee("break-words", { overflowWrap: "break-word" }), ee("break-all", { wordBreak: "break-all" }), ee("break-keep", { wordBreak: "keep-all" }), ie("caret-", { opacityVariable: false, opacitySection: "opacity" }), ie("accent-", { opacityVariable: false, opacitySection: "opacity" }), ee("bg-gradient-to-([trbl]|[tb][rl])", "backgroundImage", ({ 1: e8 }) => `linear-gradient(to ${_e(e8, " ")},var(--tw-gradient-stops))`), ie("from-", { section: "gradientColorStops", opacityVariable: false, opacitySection: "opacity" }, ({ _: e8 }) => ({ "--tw-gradient-from": e8.value, "--tw-gradient-to": e8.color({ opacityValue: "0" }), "--tw-gradient-stops": "var(--tw-gradient-from),var(--tw-gradient-to)" })), ie("via-", { section: "gradientColorStops", opacityVariable: false, opacitySection: "opacity" }, ({ _: e8 }) => ({ "--tw-gradient-to": e8.color({ opacityValue: "0" }), "--tw-gradient-stops": `var(--tw-gradient-from),${e8.value},var(--tw-gradient-to)` })), ie("to-", { section: "gradientColorStops", property: "--tw-gradient-to", opacityVariable: false, opacitySection: "opacity" }), ee("bg-(fixed|local|scroll)", "backgroundAttachment"), ee("bg-origin-(border|padding|content)", "backgroundOrigin", ({ 1: e8 }) => e8 + "-box"), ee(["bg-(no-repeat|repeat(-[xy])?)", "bg-repeat-(round|space)"], "backgroundRepeat"), ee("bg-blend-", "backgroundBlendMode"), ee("bg-clip-(border|padding|content|text)", "backgroundClip", ({ 1: e8 }) => e8 + ("text" == e8 ? "" : "-box")), ne("bg-opacity-", "backgroundOpacity", "--tw-bg-opacity"), ie("bg-", { section: "backgroundColor" }), ne("bg-", "backgroundImage"), ne("bg-", "backgroundPosition"), ee("bg-(top|bottom|center|(left|right)(-(top|bottom))?)", "backgroundPosition", Me), ne("bg-", "backgroundSize"), ne("rounded(?:$|-)", "borderRadius"), ne("rounded-([trbl]|[tb][rl])(?:$|-)", "borderRadius", ({ 1: e8, _: t5 }) => {
    let o6 = { t: ["tl", "tr"], r: ["tr", "br"], b: ["bl", "br"], l: ["bl", "tl"] }[e8] || [e8, e8];
    return { [`border-${_e(o6[0])}-radius`]: t5, [`border-${_e(o6[1])}-radius`]: t5 };
  }), ee("border-(collapse|separate)", "borderCollapse"), ne("border-opacity(?:$|-)", "borderOpacity", "--tw-border-opacity"), ee("border-(solid|dashed|dotted|double|none)", "borderStyle"), ne("border-spacing(-[xy])?(?:$|-)", "borderSpacing", ({ 1: e8, _: t5 }) => ({ ...Ve({ "--tw-border-spacing-x": "0", "--tw-border-spacing-y": "0" }), ["--tw-border-spacing" + (e8 || "-x")]: t5, ["--tw-border-spacing" + (e8 || "-y")]: t5, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" })), ie("border-([xytrbl])-", { section: "borderColor" }, Oe("border", "Color")), ie("border-"), ne("border-([xytrbl])(?:$|-)", "borderWidth", Oe("border", "Width")), ne("border(?:$|-)", "borderWidth"), ne("divide-opacity(?:$|-)", "divideOpacity", ({ _: e8 }) => ({ "&>:not([hidden])~:not([hidden])": { "--tw-divide-opacity": e8 } })), ee("divide-(solid|dashed|dotted|double|none)", ({ 1: e8 }) => ({ "&>:not([hidden])~:not([hidden])": { borderStyle: e8 } })), ee("divide-([xy]-reverse)", ({ 1: e8 }) => ({ "&>:not([hidden])~:not([hidden])": { ["--tw-divide-" + e8]: "1" } })), ne("divide-([xy])(?:$|-)", "divideWidth", ({ 1: e8, _: t5 }) => {
    let o6 = { x: "lr", y: "tb" }[e8];
    return { "&>:not([hidden])~:not([hidden])": { [`--tw-divide-${e8}-reverse`]: "0", [`border-${_e(o6[0])}Width`]: `calc(${t5} * calc(1 - var(--tw-divide-${e8}-reverse)))`, [`border-${_e(o6[1])}Width`]: `calc(${t5} * var(--tw-divide-${e8}-reverse))` } };
  }), ie("divide-", { property: "borderColor", selector: "&>:not([hidden])~:not([hidden])" }), ne("ring-opacity(?:$|-)", "ringOpacity", "--tw-ring-opacity"), ie("ring-offset-", { property: "--tw-ring-offset-color", opacityVariable: false }), ne("ring-offset(?:$|-)", "ringOffsetWidth", "--tw-ring-offset-width"), ee("ring-inset", { "--tw-ring-inset": "inset" }), ie("ring-", { property: "--tw-ring-color" }), ne("ring(?:$|-)", "ringWidth", ({ _: e8 }, { theme: t5 }) => ({ ...Ve({ "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000", "&": { "--tw-ring-inset": "var(--tw-empty,/*!*/ /*!*/)", "--tw-ring-offset-width": t5("ringOffsetWidth", "", "0px"), "--tw-ring-offset-color": B2(t5("ringOffsetColor", "", "#fff")), "--tw-ring-color": B2(t5("ringColor", "", "#93c5fd"), { opacityVariable: "--tw-ring-opacity" }), "--tw-ring-opacity": t5("ringOpacity", "", "0.5") } }), "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)", "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${e8} + var(--tw-ring-offset-width)) var(--tw-ring-color)`, boxShadow: "var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)" })), ie("shadow-", { section: "boxShadowColor", opacityVariable: false, opacitySection: "opacity" }, ({ _: e8 }) => ({ "--tw-shadow-color": e8.value, "--tw-shadow": "var(--tw-shadow-colored)" })), ne("shadow(?:$|-)", "boxShadow", ({ _: e8 }) => ({ ...Ve({ "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" }), "--tw-shadow": Ze(e8), "--tw-shadow-colored": Ze(e8).replace(/([^,]\s+)(?:#[a-f\d]+|(?:(?:hsl|rgb)a?|hwb|lab|lch|color|var)\(.+?\)|[a-z]+)(,|$)/g, "$1var(--tw-shadow-color)$2"), boxShadow: "var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)" })), ne("(opacity)-"), ee("mix-blend-", "mixBlendMode"), ...ze(), ...ze("backdrop-"), ne("transition(?:$|-)", "transitionProperty", (e8, { theme: t5 }) => ({ transitionProperty: Ze(e8), transitionTimingFunction: "none" == e8._ ? void 0 : Ze(t5("transitionTimingFunction", "")), transitionDuration: "none" == e8._ ? void 0 : Ze(t5("transitionDuration", "")) })), ne("duration(?:$|-)", "transitionDuration", "transitionDuration", Ze), ne("ease(?:$|-)", "transitionTimingFunction", "transitionTimingFunction", Ze), ne("delay(?:$|-)", "transitionDelay", "transitionDelay", Ze), ne("animate(?:$|-)", "animation", (e8, { theme: t5, h: o6, e: n7 }) => {
    let r4 = Ze(e8), i4 = r4.split(" "), a3 = t5("keyframes", i4[0]);
    return a3 ? { ["@keyframes " + (i4[0] = n7(o6(i4[0])))]: a3, animation: i4.join(" ") } : { animation: r4 };
  }), "(transform)-(none)", ee("transform", je), ee("transform-(cpu|gpu)", ({ 1: e8 }) => ({ "--tw-transform": Ee("gpu" == e8) })), ne("scale(-[xy])?-", "scale", ({ 1: e8, _: t5 }) => ({ ["--tw-scale" + (e8 || "-x")]: t5, ["--tw-scale" + (e8 || "-y")]: t5, ...je() })), ne("-?(rotate)-", "rotate", Ae), ne("-?(translate-[xy])-", "translate", Ae), ne("-?(skew-[xy])-", "skew", Ae), ee("origin-(center|((top|bottom)(-(left|right))?)|left|right)", "transformOrigin", Me), "(appearance)-", ne("(columns)-"), "(columns)-(\\d+)", "(break-(?:before|after|inside))-", ne("(cursor)-"), "(cursor)-", ee("snap-(none)", "scroll-snap-type"), ee("snap-(x|y|both)", ({ 1: e8 }) => ({ ...Ve({ "--tw-scroll-snap-strictness": "proximity" }), "scroll-snap-type": e8 + " var(--tw-scroll-snap-strictness)" })), ee("snap-(mandatory|proximity)", "--tw-scroll-snap-strictness"), ee("snap-(?:(start|end|center)|align-(none))", "scroll-snap-align"), ee("snap-(normal|always)", "scroll-snap-stop"), ee("scroll-(auto|smooth)", "scroll-behavior"), ne("scroll-p([xytrbl])?(?:$|-)", "padding", Oe("scroll-padding")), ne("-?scroll-m([xytrbl])?(?:$|-)", "scroll-margin", Oe("scroll-margin")), ee("touch-(auto|none|manipulation)", "touch-action"), ee("touch-(pinch-zoom|pan-(?:(x|left|right)|(y|up|down)))", ({ 1: e8, 2: t5, 3: o6 }) => ({ ...Ve({ "--tw-pan-x": "var(--tw-empty,/*!*/ /*!*/)", "--tw-pan-y": "var(--tw-empty,/*!*/ /*!*/)", "--tw-pinch-zoom": "var(--tw-empty,/*!*/ /*!*/)", "--tw-touch-action": "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)" }), [`--tw-${t5 ? "pan-x" : o6 ? "pan-y" : e8}`]: e8, "touch-action": "var(--tw-touch-action)" })), ee("outline-none", { outline: "2px solid transparent", "outline-offset": "2px" }), ee("outline", { outlineStyle: "solid" }), ee("outline-(dashed|dotted|double)", "outlineStyle"), ne("-?(outline-offset)-"), ie("outline-", { opacityVariable: false, opacitySection: "opacity" }), ne("outline-", "outlineWidth"), "(pointer-events)-", ne("(will-change)-"), "(will-change)-", ["resize(?:-(none|x|y))?", "resize", ({ 1: e8 }) => ({ x: "horizontal", y: "vertical" })[e8] || e8 || "both"], ee("select-(none|text|all|auto)", "userSelect"), ie("fill-", { section: "fill", opacityVariable: false, opacitySection: "opacity" }), ie("stroke-", { section: "stroke", opacityVariable: false, opacitySection: "opacity" }), ne("stroke-", "strokeWidth"), ee("sr-only", { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", whiteSpace: "nowrap", clip: "rect(0,0,0,0)", borderWidth: "0" }), ee("not-sr-only", { position: "static", width: "auto", height: "auto", padding: "0", margin: "0", overflow: "visible", whiteSpace: "normal", clip: "auto" })];
  function Me(e8) {
    return ("string" == typeof e8 ? e8 : e8[1]).replace(/-/g, " ").trim();
  }
  function Se(e8) {
    return ("string" == typeof e8 ? e8 : e8[1]).replace("col", "column");
  }
  function _e(e8, t5 = "-") {
    let o6 = [];
    for (let t6 of e8)
      o6.push({ t: "top", r: "right", b: "bottom", l: "left" }[t6]);
    return o6.join(t5);
  }
  function Ze(e8) {
    return e8 && "" + (e8._ || e8);
  }
  function Fe({ $$: e8 }) {
    return ({ r: "flex-", "": "flex-", w: "space-", u: "space-", n: "space-" }[e8[3] || ""] || "") + e8;
  }
  function Oe(e8, t5 = "") {
    return ({ 1: o6, _: n7 }) => {
      let r4 = { x: "lr", y: "tb" }[o6] || o6 + o6;
      return r4 ? { ...le(e8 + "-" + _e(r4[0]) + t5, n7), ...le(e8 + "-" + _e(r4[1]) + t5, n7) } : le(e8 + t5, n7);
    };
  }
  function ze(e8 = "") {
    let t5 = ["blur", "brightness", "contrast", "grayscale", "hue-rotate", "invert", e8 && "opacity", "saturate", "sepia", !e8 && "drop-shadow"].filter(Boolean), o6 = {};
    for (let n7 of t5)
      o6[`--tw-${e8}${n7}`] = "var(--tw-empty,/*!*/ /*!*/)";
    return o6 = { ...Ve(o6), [`${e8}filter`]: t5.map((t6) => `var(--tw-${e8}${t6})`).join(" ") }, [`(${e8}filter)-(none)`, ee(`${e8}filter`, o6), ...t5.map((t6) => ne(`${"h" == t6[0] ? "-?" : ""}(${e8}${t6})(?:$|-)`, t6, ({ 1: e9, _: n7 }) => ({ [`--tw-${e9}`]: k2(n7).map((e10) => `${t6}(${e10})`).join(" "), ...o6 })))];
  }
  function Ae({ 1: e8, _: t5 }) {
    return { ["--tw-" + e8]: t5, ...je() };
  }
  function je() {
    return { ...Ve({ "--tw-translate-x": "0", "--tw-translate-y": "0", "--tw-rotate": "0", "--tw-skew-x": "0", "--tw-skew-y": "0", "--tw-scale-x": "1", "--tw-scale-y": "1", "--tw-transform": Ee() }), transform: "var(--tw-transform)" };
  }
  function Ee(e8) {
    return [e8 ? "translate3d(var(--tw-translate-x),var(--tw-translate-y),0)" : "translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y))", "rotate(var(--tw-rotate))", "skewX(var(--tw-skew-x))", "skewY(var(--tw-skew-y))", "scaleX(var(--tw-scale-x))", "scaleY(var(--tw-scale-y))"].join(" ");
  }
  function Re({ 1: e8, 2: t5 }) {
    return `${e8} ${t5} / ${e8} ${t5}`;
  }
  function Te({ 1: e8 }) {
    return `repeat(${e8},minmax(0,1fr))`;
  }
  function Ve(e8) {
    return { "@layer defaults": { "*,::before,::after": e8, "::backdrop": e8 } };
  }
  var De = [["sticky", "@supports ((position: -webkit-sticky) or (position:sticky))"], ["motion-reduce", "@media (prefers-reduced-motion:reduce)"], ["motion-safe", "@media (prefers-reduced-motion:no-preference)"], ["print", "@media print"], ["(portrait|landscape)", ({ 1: e8 }) => `@media (orientation:${e8})`], ["contrast-(more|less)", ({ 1: e8 }) => `@media (prefers-contrast:${e8})`], ["(first-(letter|line)|placeholder|backdrop|before|after)", ({ 1: e8 }) => `&::${e8}`], ["(marker|selection)", ({ 1: e8 }) => `& *::${e8},&::${e8}`], ["file", "&::file-selector-button"], ["(first|last|only)", ({ 1: e8 }) => `&:${e8}-child`], ["even", "&:nth-child(2n)"], ["odd", "&:nth-child(odd)"], ["open", "&[open]"], ["(aria|data)-", ({ 1: e8, $$: t5 }, o6) => t5 && `&[${e8}-${o6.theme(e8, t5) || se(t5, "", o6) || `${t5}="true"`}]`], ["((group|peer)(~[^-[]+)?)(-\\[(.+)]|[-[].+?)(\\/.+)?", ({ 2: e8, 3: t5 = "", 4: o6, 5: n7 = "", 6: r4 = t5 }, { e: i4, h: a3, v: l6 }) => {
    let s5 = de(n7) || ("[" == o6[0] ? o6 : l6(o6.slice(1)));
    return `${(s5.includes("&") ? s5 : "&" + s5).replace(/&/g, `:merge(.${i4(a3(e8 + r4))})`)}${"p" == e8[0] ? "~" : " "}&`;
  }], ["(ltr|rtl)", ({ 1: e8 }) => `[dir="${e8}"] &`], ["supports-", ({ $$: e8 }, t5) => {
    if (e8 && (e8 = t5.theme("supports", e8) || se(e8, "", t5)), e8)
      return e8.includes(":") || (e8 += ":var(--tw)"), /^\w*\s*\(/.test(e8) || (e8 = `(${e8})`), `@supports ${e8.replace(/\b(and|or|not)\b/g, " $1 ").trim()}`;
  }], ["max-", ({ $$: e8 }, t5) => {
    if (e8 && (e8 = t5.theme("screens", e8) || se(e8, "", t5)), "string" == typeof e8)
      return `@media not all and (min-width:${e8})`;
  }], ["min-", ({ $$: e8 }, t5) => (e8 && (e8 = se(e8, "", t5)), e8 && `@media (min-width:${e8})`)], [/^\[(.+)]$/, ({ 1: e8 }) => /[&@]/.test(e8) && de(e8).replace(/[}]+$/, "").split("{")]];
  var We = { __proto__: null, slate: { 50: "#f8fafc", 100: "#f1f5f9", 200: "#e2e8f0", 300: "#cbd5e1", 400: "#94a3b8", 500: "#64748b", 600: "#475569", 700: "#334155", 800: "#1e293b", 900: "#0f172a" }, gray: { 50: "#f9fafb", 100: "#f3f4f6", 200: "#e5e7eb", 300: "#d1d5db", 400: "#9ca3af", 500: "#6b7280", 600: "#4b5563", 700: "#374151", 800: "#1f2937", 900: "#111827" }, zinc: { 50: "#fafafa", 100: "#f4f4f5", 200: "#e4e4e7", 300: "#d4d4d8", 400: "#a1a1aa", 500: "#71717a", 600: "#52525b", 700: "#3f3f46", 800: "#27272a", 900: "#18181b" }, neutral: { 50: "#fafafa", 100: "#f5f5f5", 200: "#e5e5e5", 300: "#d4d4d4", 400: "#a3a3a3", 500: "#737373", 600: "#525252", 700: "#404040", 800: "#262626", 900: "#171717" }, stone: { 50: "#fafaf9", 100: "#f5f5f4", 200: "#e7e5e4", 300: "#d6d3d1", 400: "#a8a29e", 500: "#78716c", 600: "#57534e", 700: "#44403c", 800: "#292524", 900: "#1c1917" }, red: { 50: "#fef2f2", 100: "#fee2e2", 200: "#fecaca", 300: "#fca5a5", 400: "#f87171", 500: "#ef4444", 600: "#dc2626", 700: "#b91c1c", 800: "#991b1b", 900: "#7f1d1d" }, orange: { 50: "#fff7ed", 100: "#ffedd5", 200: "#fed7aa", 300: "#fdba74", 400: "#fb923c", 500: "#f97316", 600: "#ea580c", 700: "#c2410c", 800: "#9a3412", 900: "#7c2d12" }, amber: { 50: "#fffbeb", 100: "#fef3c7", 200: "#fde68a", 300: "#fcd34d", 400: "#fbbf24", 500: "#f59e0b", 600: "#d97706", 700: "#b45309", 800: "#92400e", 900: "#78350f" }, yellow: { 50: "#fefce8", 100: "#fef9c3", 200: "#fef08a", 300: "#fde047", 400: "#facc15", 500: "#eab308", 600: "#ca8a04", 700: "#a16207", 800: "#854d0e", 900: "#713f12" }, lime: { 50: "#f7fee7", 100: "#ecfccb", 200: "#d9f99d", 300: "#bef264", 400: "#a3e635", 500: "#84cc16", 600: "#65a30d", 700: "#4d7c0f", 800: "#3f6212", 900: "#365314" }, green: { 50: "#f0fdf4", 100: "#dcfce7", 200: "#bbf7d0", 300: "#86efac", 400: "#4ade80", 500: "#22c55e", 600: "#16a34a", 700: "#15803d", 800: "#166534", 900: "#14532d" }, emerald: { 50: "#ecfdf5", 100: "#d1fae5", 200: "#a7f3d0", 300: "#6ee7b7", 400: "#34d399", 500: "#10b981", 600: "#059669", 700: "#047857", 800: "#065f46", 900: "#064e3b" }, teal: { 50: "#f0fdfa", 100: "#ccfbf1", 200: "#99f6e4", 300: "#5eead4", 400: "#2dd4bf", 500: "#14b8a6", 600: "#0d9488", 700: "#0f766e", 800: "#115e59", 900: "#134e4a" }, cyan: { 50: "#ecfeff", 100: "#cffafe", 200: "#a5f3fc", 300: "#67e8f9", 400: "#22d3ee", 500: "#06b6d4", 600: "#0891b2", 700: "#0e7490", 800: "#155e75", 900: "#164e63" }, sky: { 50: "#f0f9ff", 100: "#e0f2fe", 200: "#bae6fd", 300: "#7dd3fc", 400: "#38bdf8", 500: "#0ea5e9", 600: "#0284c7", 700: "#0369a1", 800: "#075985", 900: "#0c4a6e" }, blue: { 50: "#eff6ff", 100: "#dbeafe", 200: "#bfdbfe", 300: "#93c5fd", 400: "#60a5fa", 500: "#3b82f6", 600: "#2563eb", 700: "#1d4ed8", 800: "#1e40af", 900: "#1e3a8a" }, indigo: { 50: "#eef2ff", 100: "#e0e7ff", 200: "#c7d2fe", 300: "#a5b4fc", 400: "#818cf8", 500: "#6366f1", 600: "#4f46e5", 700: "#4338ca", 800: "#3730a3", 900: "#312e81" }, violet: { 50: "#f5f3ff", 100: "#ede9fe", 200: "#ddd6fe", 300: "#c4b5fd", 400: "#a78bfa", 500: "#8b5cf6", 600: "#7c3aed", 700: "#6d28d9", 800: "#5b21b6", 900: "#4c1d95" }, purple: { 50: "#faf5ff", 100: "#f3e8ff", 200: "#e9d5ff", 300: "#d8b4fe", 400: "#c084fc", 500: "#a855f7", 600: "#9333ea", 700: "#7e22ce", 800: "#6b21a8", 900: "#581c87" }, fuchsia: { 50: "#fdf4ff", 100: "#fae8ff", 200: "#f5d0fe", 300: "#f0abfc", 400: "#e879f9", 500: "#d946ef", 600: "#c026d3", 700: "#a21caf", 800: "#86198f", 900: "#701a75" }, pink: { 50: "#fdf2f8", 100: "#fce7f3", 200: "#fbcfe8", 300: "#f9a8d4", 400: "#f472b6", 500: "#ec4899", 600: "#db2777", 700: "#be185d", 800: "#9d174d", 900: "#831843" }, rose: { 50: "#fff1f2", 100: "#ffe4e6", 200: "#fecdd3", 300: "#fda4af", 400: "#fb7185", 500: "#f43f5e", 600: "#e11d48", 700: "#be123c", 800: "#9f1239", 900: "#881337" } };
  function He({ disablePreflight: e8 } = {}) {
    return function({ colors: e9, disablePreflight: t5 } = {}) {
      return { preflight: t5 ? void 0 : $e, theme: { ...ye, colors: { inherit: "inherit", current: "currentColor", transparent: "transparent", black: "#000", white: "#fff", ...e9 } }, variants: De, rules: ke, finalize: (e10) => e10.n && e10.d && e10.r.some((e11) => /^&::(before|after)$/.test(e11)) && !/(^|;)content:/.test(e10.d) ? { ...e10, d: "content:var(--tw-content);" + e10.d } : e10 };
    }({ colors: We, disablePreflight: e8 });
  }
  var Ue = "undefined" != typeof ShadowRoot && ("undefined" == typeof ShadyCSS || ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
  function Be(e8) {
    return e8.shadowRoot || e8.attachShadow({ mode: "open" });
  }
  var Ne = () => function(e8, t5 = true) {
    let o6 = function() {
      if (Ue)
        try {
          let e10 = me(new CSSStyleSheet());
          return e10.connect = (t7) => {
            let o8 = Be(t7);
            o8.adoptedStyleSheets = [...o8.adoptedStyleSheets, e10.target];
          }, e10.disconnect = S4, e10;
        } catch {
        }
      let e9 = document.createElement("style");
      e9.media = "not all", document.head.prepend(e9);
      let t6 = [me(e9)], o7 = /* @__PURE__ */ new WeakMap();
      return { get target() {
        return t6[0].target;
      }, snapshot() {
        let e10 = t6.map((e11) => e11.snapshot());
        return () => e10.forEach((e11) => e11());
      }, clear() {
        t6.forEach((e10) => e10.clear());
      }, destroy() {
        t6.forEach((e10) => e10.destroy());
      }, insert(e10, o8, n8) {
        t6[0].insert(e10, o8, n8);
        let r5 = this.target.cssRules[o8];
        t6.forEach((e11, t7) => t7 && e11.target.insertRule(r5.cssText, o8));
      }, resume: (e10, o8) => t6[0].resume(e10, o8), connect(e10) {
        let n8 = document.createElement("style");
        Be(e10).appendChild(n8);
        let r5 = me(n8), { cssRules: i4 } = this.target;
        for (let e11 = 0; e11 < i4.length; e11++)
          r5.target.insertRule(i4[e11].cssText, e11);
        t6.push(r5), o7.set(e10, r5);
      }, disconnect(e10) {
        let n8 = t6.indexOf(o7.get(e10));
        n8 >= 0 && t6.splice(n8, 1);
      } };
    }(), n7 = function(e9, t6) {
      let o7 = pe(e9), n8 = function({ theme: e10, darkMode: t7, darkColor: o8 = S4, variants: n9, rules: r6, hash: i5, stringify: a4, ignorelist: l7, finalize: s5 }) {
        let c4 = /* @__PURE__ */ new Map(), d4 = /* @__PURE__ */ new Map(), p4 = /* @__PURE__ */ new Map(), f5 = /* @__PURE__ */ new Map(), u5 = Ce(l7, (e11, t8) => t8.test(e11));
        n9.push(["dark", Array.isArray(t7) || "class" == t7 ? `${k2(t7)[1] || ".dark"} &` : "string" == typeof t7 && "media" != t7 ? t7 : "@media (prefers-color-scheme:dark)"]);
        let h5 = "function" == typeof i5 ? (e11) => i5(e11, L2) : i5 ? L2 : M2;
        h5 !== M2 && s5.push((e11) => ({ ...e11, n: e11.n && h5(e11.n), d: e11.d?.replace(/--(tw(?:-[\w-]+)?)\b/g, (e12, t8) => "--" + h5(t8).replace("#", "")) }));
        let g4 = { theme: function({ extend: e11 = {}, ...t8 }) {
          let o9 = {}, n10 = { get colors() {
            return r7("colors");
          }, theme: r7, negative: () => ({}), breakpoints(e12) {
            let t9 = {};
            for (let o10 in e12)
              "string" == typeof e12[o10] && (t9["screen-" + o10] = e12[o10]);
            return t9;
          } };
          return r7;
          function r7(n11, a5, l8, s6) {
            if (n11) {
              if ({ 1: n11, 2: s6 } = /^(\S+?)(?:\s*\/\s*([^/]+))?$/.exec(n11) || [, n11], /[.[]/.test(n11)) {
                let e12 = [];
                n11.replace(/\[([^\]]+)\]|([^.[]+)/g, (t9, o10, n12 = o10) => e12.push(n12)), n11 = e12.shift(), l8 = a5, a5 = e12.join("-");
              }
              let c6 = o9[n11] || Object.assign(Object.assign(o9[n11] = {}, i6(t8, n11)), i6(e11, n11));
              if (null == a5)
                return c6;
              a5 || (a5 = "DEFAULT");
              let d5 = c6[a5] ?? a5.split("-").reduce((e12, t9) => e12?.[t9], c6) ?? l8;
              return s6 ? B2(d5, { opacityValue: I2(s6, r7) }) : d5;
            }
            let c5 = {};
            for (let o10 of [...Object.keys(t8), ...Object.keys(e11)])
              c5[o10] = r7(o10);
            return c5;
          }
          function i6(e12, t9) {
            let o10 = e12[t9];
            return "function" == typeof o10 && (o10 = o10(n10)), o10 && /color|fill|stroke/i.test(t9) ? function e13(t10, o11 = []) {
              let n11 = {};
              for (let r8 in t10) {
                let i7 = t10[r8], a5 = [...o11, r8];
                n11[a5.join("-")] = i7, "DEFAULT" == r8 && (a5 = o11, n11[o11.join("-")] = i7), "object" == typeof i7 && Object.assign(n11, e13(i7, a5));
              }
              return n11;
            }(o10) : o10;
          }
        }(e10), e: v3, h: h5, s: (e11, t8) => a4(e11, t8, g4), d: (e11, t8, n10) => o8(e11, t8, g4, n10), v: (e11) => (c4.has(e11) || c4.set(e11, fe2(e11, n9, d4, ue, g4) || "&:" + e11), c4.get(e11)), r(e11, t8) {
          let o9 = JSON.stringify([e11, t8]);
          return p4.has(o9) || p4.set(o9, !u5(e11, g4) && fe2(e11, r6, f5, he, g4, t8)), p4.get(o9);
        }, f: (e11) => s5.reduce((e12, t8) => t8(e12, g4), e11) };
        return g4;
      }(o7), r5 = /* @__PURE__ */ new Map(), i4 = [], a3 = /* @__PURE__ */ new Set();
      function l6(e10) {
        let o8 = n8.f(e10), r6 = j(o8);
        if (r6 && !a3.has(r6)) {
          a3.add(r6);
          let o9 = V2(i4, e10);
          t6.insert(r6, o9, e10), i4.splice(o9, 0, e10);
        }
        return o8.n;
      }
      return t6.resume((e10) => r5.set(e10, e10), (e10, o8) => {
        t6.insert(e10, i4.length, o8), i4.push(o8), a3.add(e10);
      }), Object.defineProperties(function(e10) {
        if (!r5.size)
          for (let e11 of k2(o7.preflight))
            "function" == typeof e11 && (e11 = e11(n8)), e11 && ("string" == typeof e11 ? Y("", _2.b, Q(e11), n8, _2.b, [], false, true) : N2(e11, {}, n8, _2.b)).forEach(l6);
        let t7 = r5.get(e10 = "" + e10);
        if (!t7) {
          let o8 = /* @__PURE__ */ new Set();
          for (let t8 of G(Q(e10), n8))
            o8.add(t8.c).add(l6(t8));
          t7 = [...o8].filter(Boolean).join(" "), r5.set(e10, t7).set(t7, t7);
        }
        return t7;
      }, Object.getOwnPropertyDescriptors({ get target() {
        return t6.target;
      }, theme: n8.theme, config: o7, snapshot() {
        let e10 = t6.snapshot(), o8 = new Set(a3), n9 = new Map(r5), l7 = [...i4];
        return () => {
          e10(), a3 = o8, r5 = n9, i4 = l7;
        };
      }, clear() {
        t6.clear(), a3 = /* @__PURE__ */ new Set(), r5 = /* @__PURE__ */ new Map(), i4 = [];
      }, destroy() {
        this.clear(), t6.destroy();
      } }));
    }({ ...e8, hash: e8.hash ?? t5 }, o6), r4 = function(e9) {
      let t6 = new MutationObserver(o7);
      return { observe(e10) {
        t6.observe(e10, { attributeFilter: ["class"], subtree: true, childList: true }), n8(e10), o7([{ target: e10, type: "" }]);
      }, disconnect() {
        t6.disconnect();
      } };
      function o7(e10) {
        for (let { type: t7, target: o8 } of e10)
          if ("a" == t7[0])
            n8(o8);
          else
            for (let e11 of o8.querySelectorAll("[class]"))
              n8(e11);
        t6.takeRecords();
      }
      function n8(t7) {
        let o8, n9 = t7.getAttribute?.("class");
        var r5, i4;
        n9 && (r5 = n9) != (i4 = o8 = e9(n9)) && "" + r5.split(" ").sort() != "" + i4.split(" ").sort() && t7.setAttribute("class", o8);
      }
    }(n7);
    return function(e9) {
      return class extends e9 {
        connectedCallback() {
          super.connectedCallback?.(), o6.connect(this), r4.observe(Be(this));
        }
        disconnectedCallback() {
          o6.disconnect(this), super.disconnectedCallback?.();
        }
        constructor(...e10) {
          super(...e10), this.tw = n7;
        }
      };
    };
  }(pe({ theme: { fontFamily: { sans: ["Inter", "sans-serif"], mono: ["Roboto Mono", "monospace"] }, extend: { animation: { darken: "darken 0.2s ease-out forwards", lighten: "lighten 0.2s ease-out forwards", "fade-in": "fade-in 0.2s ease-out forwards", "fade-out": "fade-out 0.2s ease-out forwards" }, keyframes: { darken: { "0%": { opacity: 0 }, "100%": { opacity: 0.5 } }, lighten: { "0%": { opacity: 0.5 }, "100%": { opacity: 0 } }, "fade-in": { "0%": { opacity: 0 }, "100%": { opacity: 1 } }, "fade-out": { "0%": { opacity: 1 }, "100%": { opacity: 0 } } } } }, presets: [He({})], hash: false }));
  var Ie;
  var Pe = b(Ie || (Ie = ((e8) => e8)`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet" focusable="false" class="w-12 h-12"><g><path d="M20.5 11H19V7c0-1.1-.9-2-2-2h-4V3.5C13 2.12 11.88 1 10.5 1S8 2.12 8 3.5V5H4c-1.1 0-1.99.9-1.99 2v3.8H3.5c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7H2V20c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7 1.49 0 2.7 1.21 2.7 2.7V22H17c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5S21.88 11 20.5 11z"></path></g></svg>`));
  function Ge() {
    return Ge = Object.assign ? Object.assign.bind() : function(e8) {
      for (var t5 = 1; t5 < arguments.length; t5++) {
        var o6 = arguments[t5];
        for (var n7 in o6)
          Object.prototype.hasOwnProperty.call(o6, n7) && (e8[n7] = o6[n7]);
      }
      return e8;
    }, Ge.apply(this, arguments);
  }
  var Ye = "bc-color-";
  var qe = { primary: "#2EA7FF", secondary: "#0045B1", tertiary: void 0, "bg-primary": "#FFFFFF", "bg-secondary": "#000000", "text-primary": "#FFFFFF", "text-secondary": "#404040", "text-tertiary": "#FFFFFF" };
  function Je(e8, t5 = qe[e8]) {
    return `var(--${Ye}${e8}, ${t5})`;
  }
  var Xe = "transition-all hover:brightness-110 active:scale-95";
  var Ke;
  var Qe = (e8) => e8;
  var et = class extends Ne()(y3) {
    constructor(e8, t5, o6, n7) {
      super(), this._connectorType = e8, this._title = t5, this._background = o6, this._icon = n7;
    }
    render() {
      return x(Ke || (Ke = Qe`<div
      class="flex flex-col justify-between items-center w-32 h-24 cursor-pointer ${0}"
      @click=${0}
    >
      <div
        class="w-16 h-16 drop-shadow-lg rounded-2xl flex justify-center items-center"
        style="background: ${0};"
      >
        ${0}
      </div>
      <span
        class="text-sm font-sans font-medium"
        style="color: ${0}"
        >${0}</span
      >
    </div>`), Xe, this._onClick, this._background, this._icon, Je("text-secondary"), this._title);
    }
    _connect(e8) {
      C2.getState().connect(Ge({}, e8, { connectorName: this._title, connectorType: this._connectorType }));
    }
  };
  var tt;
  var ot = class extends et {
    constructor() {
      super("extension.generic", "Extension", "linear-gradient(180deg, #E7E7E7 63.72%, #D1D1D1 95.24%)", Pe);
    }
    _onClick() {
      this._connect({});
    }
  };
  ot = c3([e4("bc-extension-connector")], ot);
  var nt = b(tt || (tt = ((e8) => e8)`<svg width="45" height="64" viewBox="0 0 45 64" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M32.9716 52.1905C38.5774 52.1905 41.1289 39.7778 41.1289 35.0713C41.1289 31.4029 38.5976 29.1797 35.2699 29.1797C31.9629 29.1797 29.2782 30.6017 29.2449 32.3627C29.2448 37.01 28.4268 52.1905 32.9716 52.1905Z" fill="white" stroke="black" stroke-width="1.66938"/>
<path d="M12.4972 52.1905C6.89139 52.1905 4.33989 39.7778 4.33989 35.0713C4.33989 31.4029 6.87114 29.1797 10.1989 29.1797C13.5058 29.1797 16.1906 30.6017 16.2239 32.3627C16.224 37.01 17.0419 52.1905 12.4972 52.1905Z" fill="white" stroke="black" stroke-width="1.66938"/>
<path d="M7.84577 33.579L7.84575 33.5787C7.83973 33.5213 7.8514 33.488 7.86332 33.4663C7.87739 33.4406 7.90412 33.4101 7.949 33.3846C8.04196 33.3318 8.17216 33.3222 8.29337 33.3931C12.457 35.8337 17.2594 37.2328 22.4806 37.2328C27.7028 37.2328 32.5942 35.8065 36.7846 33.3233C36.905 33.252 37.0349 33.2608 37.1281 33.3133C37.1732 33.3386 37.2001 33.3691 37.2144 33.3949C37.2264 33.4167 37.2382 33.4501 37.2324 33.5076C36.5842 39.9314 33.0999 45.2421 28.4166 47.6866L28.4165 47.6867C26.8697 48.4942 25.8061 49.897 24.8719 51.1291L24.8218 51.1952L24.8217 51.1954C24.0624 52.197 23.3752 53.094 22.5354 53.755C21.6955 53.094 21.0084 52.197 20.2491 51.1954L20.249 51.1952C20.2323 51.1732 20.2156 51.1512 20.1989 51.1291C19.2647 49.897 18.2011 48.4942 16.6542 47.6867L16.6542 47.6866C11.9887 45.2516 8.51323 39.9716 7.84577 33.579Z" fill="#FFDF6F" stroke="black" stroke-width="1.6609"/>
<ellipse cx="22.5675" cy="33.4515" rx="14.6905" ry="4.89684" fill="black" stroke="black" stroke-width="1.66938"/>
<path d="M10.7715 41.6875C10.7715 41.6875 18.0175 44.1359 22.6797 44.1359C27.3419 44.1359 34.5879 41.6875 34.5879 41.6875" stroke="black" stroke-width="1.66938" stroke-linecap="round"/>
<circle cx="3.3218" cy="3.3218" r="3.3218" transform="matrix(-1 0 0 1 12.0703 9.19043)" fill="black"/>
<path d="M8.19579 12.0137L14.3965 18.2144" stroke="black" stroke-width="1.6609"/>
<circle cx="35.8784" cy="12.5122" r="3.3218" fill="black"/>
<path d="M36.4878 12.0137L30.2871 18.2144" stroke="black" stroke-width="1.6609"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M9.69481 32.3343C7.90447 31.482 6.86251 29.568 7.21154 27.6161C8.70958 19.2385 14.9526 12.9551 22.4267 12.9551C29.9188 12.9551 36.174 19.269 37.6526 27.677C37.9965 29.6325 36.946 31.5456 35.1496 32.391C31.3055 34.1999 27.0119 35.2111 22.482 35.2111C17.9051 35.2111 13.5693 34.1788 9.69481 32.3343Z" fill="#FFDF6F"/>
<path d="M37.6526 27.677L36.8347 27.8209L37.6526 27.677ZM8.02903 27.7623C9.47654 19.6673 15.46 13.7855 22.4267 13.7855V12.1246C14.4452 12.1246 7.94263 18.8097 6.39406 27.4699L8.02903 27.7623ZM22.4267 13.7855C29.4101 13.7855 35.4059 19.696 36.8347 27.8209L38.4705 27.5332C36.9421 18.842 30.4275 12.1246 22.4267 12.1246V13.7855ZM34.796 31.6396C31.0602 33.3976 26.8871 34.3807 22.482 34.3807V36.0416C27.1366 36.0416 31.5508 35.0023 35.5032 33.1424L34.796 31.6396ZM22.482 34.3807C18.0312 34.3807 13.8172 33.377 10.0518 31.5845L9.33786 33.0841C13.3215 34.9806 17.779 36.0416 22.482 36.0416V34.3807ZM36.8347 27.8209C37.1104 29.3886 36.2709 30.9454 34.796 31.6396L35.5032 33.1424C37.6211 32.1457 38.8825 29.8763 38.4705 27.5332L36.8347 27.8209ZM6.39406 27.4699C5.97582 29.8089 7.22718 32.0793 9.33786 33.0841L10.0518 31.5845C8.58176 30.8847 7.7492 29.3272 8.02903 27.7623L6.39406 27.4699Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.8892 30.2522C11.4481 29.6652 10.5932 28.1319 11.0926 26.6582C12.6325 22.1132 17.1248 18.8242 22.4266 18.8242C27.7285 18.8242 32.2208 22.1132 33.7607 26.6582C34.2601 28.1319 33.4052 29.6652 31.9641 30.2522C29.0207 31.4509 25.8008 32.1114 22.4266 32.1114C19.0525 32.1114 15.8326 31.4509 12.8892 30.2522Z" fill="black"/>
<ellipse cx="26.2447" cy="25.9098" rx="2.76817" ry="2.21453" fill="white"/>
<ellipse cx="18.3209" cy="25.9118" rx="2.76817" ry="2.21453" fill="white"/>
</svg>
`));
  var rt;
  var it = class extends et {
    constructor() {
      super("nwc.alby", "Alby NWC", "linear-gradient(180deg, #FFDE6E 63.72%, #F8C455 95.24%)", nt);
    }
    async _onClick() {
      const e8 = S3.NostrWebLNProvider.withNewSecret();
      await e8.initNWC({ name: "Bitcoin Connect" }), this._connect({ nwcUrl: e8.getNostrWalletConnectUrl(true) });
    }
  };
  it = c3([e4("bc-alby-nwc-connector")], it);
  var at = b(rt || (rt = ((e8) => e8)`<svg
  width="25"
  height="24"
  viewBox="0 0 25 24"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
  class="w-10 h-10"
  >
  <path
    fill-rule="evenodd"
    clip-rule="evenodd"
    d="M14.1287 5.03035L21.4952 12.43L21.4962 12.431C21.9034 12.84 22.3607 13.0639 22.7796 13.1062C23.1718 13.1459 23.5673 13.0322 23.9225 12.6949L19.9036 2.22631C19.4497 1.2345 18.1428 0.998839 17.3711 1.7739L14.1287 5.03035ZM21.0966 12.8275L21.0967 12.8277L21.0965 12.8278C22.0558 13.7912 23.3871 14.021 24.3507 13.062L21.0884 16.3089L19.5591 17.8311L18.4915 18.8936L16.6182 17.0135C17.526 15.6331 17.3781 13.7598 16.1662 12.5404L14.8908 11.2571C14.7095 11.0747 14.4176 11.0738 14.2351 11.2551L13.6055 11.8808L12.0093 10.2746C11.7323 9.99591 11.2744 10.0124 11.0176 10.3194C10.7928 10.5905 10.8315 10.9904 11.0786 11.239L12.6549 12.8251L11.4035 14.0683L9.8073 12.4622C9.53028 12.1835 9.07051 12.1979 8.81561 12.507C8.5928 12.7762 8.63155 13.1761 8.87864 13.4247L10.4549 15.0107L9.82725 15.6344C9.64479 15.8157 9.64392 16.1076 9.82523 16.29L11.1006 17.5733C12.3123 18.7926 14.1847 18.9525 15.5709 18.0538L17.4452 19.9349L16.8577 20.5195L14.8527 22.5151C13.8889 23.4742 12.3301 23.4706 11.3708 22.507L1.21706 12.3075C0.257903 11.3438 0.261373 9.78528 1.22516 8.82609L7.46087 2.61976C8.42465 1.66071 9.9834 1.66432 10.9427 2.62785L21.0966 12.8275Z"
    fill="white"
  />
</svg>`));
  var lt = class extends et {
    constructor() {
      super("nwc.generic", "NWC Generic", "#7E22CD", at);
    }
    async _onClick() {
      const e8 = prompt("Enter your Nostr Wallet Connect URL");
      e8 && this._connect({ nwcUrl: e8 });
    }
  };
  lt = c3([e4("bc-nwc-connector")], lt);
  var st;
  var ct;
  var dt;
  var pt = (e8) => e8;
  var ft = class extends Ne()(y3) {
    render() {
      return x(st || (st = pt` <div class="flex justify-center items-start flex-wrap">
      ${0}
      <bc-alby-nwc-connector></bc-alby-nwc-connector>
      <bc-nwc-connector></bc-nwc-connector>
    </div>`), window.webln ? x(ct || (ct = pt`<bc-extension-connector></bc-extension-connector>`)) : null);
    }
  };
  function ut() {
    return `background: -webkit-linear-gradient(${Je("primary")}, ${Je("secondary")});
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;`;
  }
  ft = c3([e4("bc-connector-list")], ft);
  var ht = b(dt || (dt = ((e8) => e8)`<svg width="16" height="17" viewBox="0 0 16 17" fill="none" xmlns="http://www.w3.org/2000/svg" class="w-5 h-5 hover-right-up">
<path d="M6.00008 4.50008H3.73341C3.36005 4.50008 3.17336 4.50008 3.03075 4.57274C2.90531 4.63666 2.80333 4.73865 2.73941 4.86409C2.66675 5.0067 2.66675 5.19338 2.66675 5.56675V12.7667C2.66675 13.1401 2.66675 13.3268 2.73941 13.4694C2.80333 13.5949 2.90531 13.6968 3.03075 13.7608C3.17336 13.8334 3.36005 13.8334 3.73342 13.8334H10.9334C11.3068 13.8334 11.4935 13.8334 11.6361 13.7608C11.7615 13.6968 11.8635 13.5949 11.9274 13.4694C12.0001 13.3268 12.0001 13.1401 12.0001 12.7667V10.5001M9.33341 3.16675H13.3334M13.3334 3.16675V7.16675M13.3334 3.16675L7.33341 9.16675" stroke="url(#paint0_linear_362_864)" stroke-width="1.33333" stroke-linecap="round" stroke-linejoin="round"/>
<defs>
<linearGradient id="paint0_linear_362_864" x1="8.00008" y1="3.16675" x2="8.00008" y2="13.8334" gradientUnits="userSpaceOnUse">
<stop stop-color=${0}/>
<stop offset="1" stop-color=${0}/>
</linearGradient>
</defs>
</svg>
`), Je("primary"), Je("secondary"));
  var gt;
  var Ct;
  var bt = (e8) => e8;
  function mt() {
    return x(gt || (gt = bt`<hr
    class="border-t w-full"
    style="border-color: ${0}"
  />`), Je("text-secondary"));
  }
  var yt = b(Ct || (Ct = ((e8) => e8)`<svg width="49" height="24" viewBox="0 0 49 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="w-16 h-16 -my-4">
<ellipse opacity="0.1" cx="7.70773" cy="21.5226" rx="3.4509" ry="0.637088" fill="black"/>
<path d="M11.0342 18.4211C12.817 18.4211 13.6285 14.4735 13.6285 12.9767C13.6285 11.8101 12.8235 11.103 11.7652 11.103C10.7135 11.103 9.85965 11.5553 9.84905 12.1153C9.84902 13.5933 9.5889 18.4211 11.0342 18.4211Z" fill="white" stroke=${0} stroke-width="0.530907"/>
<path d="M4.52264 18.4211C2.73985 18.4211 1.9284 14.4735 1.9284 12.9767C1.9284 11.8101 2.7334 11.103 3.79171 11.103C4.84341 11.103 5.69723 11.5553 5.70784 12.1153C5.70786 13.5933 5.96799 18.4211 4.52264 18.4211Z" fill="white" stroke=${0} stroke-width="0.530907"/>
<mask id="path-4-inside-1_362_874" fill="white">
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.6445 12.5235C12.6735 12.2374 12.352 12.0646 12.1046 12.2113C10.8114 12.9776 9.30208 13.4175 7.68997 13.4175C6.09291 13.4175 4.59668 12.9858 3.31165 12.2326C3.06376 12.0873 2.74334 12.2612 2.77318 12.547C2.9933 14.6548 4.14156 16.4192 5.71508 17.2405C6.15438 17.4698 6.46173 17.8751 6.77033 18.282C7.0197 18.6108 7.26988 18.9407 7.59116 19.1797C7.62857 19.2075 7.66755 19.2222 7.70759 19.2222C7.74762 19.2222 7.78658 19.2075 7.82397 19.1797C8.14538 18.9407 8.39562 18.6108 8.64504 18.2819C8.9536 17.875 9.26091 17.4698 9.70016 17.2405C11.2796 16.4162 12.4305 14.6418 12.6445 12.5235Z"/>
</mask>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.6445 12.5235C12.6735 12.2374 12.352 12.0646 12.1046 12.2113C10.8114 12.9776 9.30208 13.4175 7.68997 13.4175C6.09291 13.4175 4.59668 12.9858 3.31165 12.2326C3.06376 12.0873 2.74334 12.2612 2.77318 12.547C2.9933 14.6548 4.14156 16.4192 5.71508 17.2405C6.15438 17.4698 6.46173 17.8751 6.77033 18.282C7.0197 18.6108 7.26988 18.9407 7.59116 19.1797C7.62857 19.2075 7.66755 19.2222 7.70759 19.2222C7.74762 19.2222 7.78658 19.2075 7.82397 19.1797C8.14538 18.9407 8.39562 18.6108 8.64504 18.2819C8.9536 17.875 9.26091 17.4698 9.70016 17.2405C11.2796 16.4162 12.4305 14.6418 12.6445 12.5235Z" fill="#FFDF6F"/>
<path d="M5.71508 17.2405L5.96074 16.7698L5.71508 17.2405ZM6.77033 18.282L6.34731 18.6028H6.34731L6.77033 18.282ZM7.59116 19.1797L7.27429 19.6057L7.27429 19.6057L7.59116 19.1797ZM7.82397 19.1797L8.14076 19.6058L8.14076 19.6058L7.82397 19.1797ZM8.64504 18.2819L8.22202 17.9611L8.22202 17.9611L8.64504 18.2819ZM9.70016 17.2405L9.94582 17.7112H9.94582L9.70016 17.2405ZM12.1046 12.2113L12.3752 12.668L12.1046 12.2113ZM12.6445 12.5235L12.1163 12.4702L12.6445 12.5235ZM11.8339 11.7545C10.6205 12.4737 9.20424 12.8866 7.68997 12.8866V13.9484C9.39992 13.9484 11.0024 13.4815 12.3752 12.668L11.8339 11.7545ZM7.68997 12.8866C6.18981 12.8866 4.78593 12.4813 3.5801 11.7746L3.0432 12.6907C4.40743 13.4902 5.996 13.9484 7.68997 13.9484V12.8866ZM2.24515 12.6022C2.48098 14.8605 3.71574 16.7958 5.46941 17.7111L5.96074 16.7698C4.56738 16.0426 3.50562 14.4492 3.30122 12.4919L2.24515 12.6022ZM5.46941 17.7111C5.78479 17.8758 6.0236 18.1759 6.34731 18.6028L7.19335 17.9612C6.89987 17.5742 6.52397 17.0638 5.96074 16.7698L5.46941 17.7111ZM6.34731 18.6028C6.58755 18.9196 6.88185 19.3137 7.27429 19.6057L7.90804 18.7537C7.65791 18.5676 7.45184 18.302 7.19335 17.9612L6.34731 18.6028ZM7.27429 19.6057C7.38246 19.6861 7.5299 19.7531 7.70759 19.7531V18.6913C7.80519 18.6913 7.87468 18.7289 7.90803 18.7537L7.27429 19.6057ZM7.70759 19.7531C7.8852 19.7531 8.03259 19.6862 8.14076 19.6058L7.50719 18.7537C7.54057 18.7289 7.61005 18.6913 7.70759 18.6913V19.7531ZM8.14076 19.6058C8.53339 19.3138 8.82778 18.9195 9.06806 18.6027L8.22202 17.9611C7.96346 18.302 7.75738 18.5677 7.50719 18.7537L8.14076 19.6058ZM9.06806 18.6027C9.39174 18.1759 9.6305 17.8758 9.94582 17.7112L9.45451 16.7699C8.89133 17.0638 8.51547 17.5741 8.22202 17.9611L9.06806 18.6027ZM9.94582 17.7112C11.706 16.7925 12.9435 14.8462 13.1728 12.5769L12.1163 12.4702C11.9176 14.4373 10.8531 16.0399 9.45451 16.7699L9.94582 17.7112ZM3.5801 11.7746C3.28427 11.6012 2.93961 11.6167 2.67587 11.7666C2.40507 11.9206 2.20605 12.2278 2.24515 12.6022L3.30122 12.4919C3.30493 12.5275 3.29778 12.5713 3.27544 12.6121C3.25447 12.6503 3.22616 12.6752 3.20065 12.6897C3.15164 12.7176 3.09113 12.7188 3.0432 12.6907L3.5801 11.7746ZM12.3752 12.668C12.3274 12.6963 12.2669 12.6954 12.2177 12.6677C12.1921 12.6533 12.1637 12.6286 12.1426 12.5903C12.12 12.5496 12.1127 12.5057 12.1163 12.4702L13.1728 12.5769C13.2106 12.2021 13.0103 11.8954 12.7386 11.7425C12.4741 11.5936 12.1291 11.5796 11.8339 11.7545L12.3752 12.668Z" fill="black" mask="url(#path-4-inside-1_362_874)"/>
<ellipse cx="7.72545" cy="12.4621" rx="4.67198" ry="1.55733" fill="black" stroke="black" stroke-width="0.530907"/>
<path d="M3.97363 15.0811C3.97363 15.0811 6.27807 15.8597 7.76077 15.8597C9.24347 15.8597 11.5479 15.0811 11.5479 15.0811" stroke="black" stroke-width="0.530907" stroke-linecap="round"/>
<circle cx="1.05642" cy="1.05642" r="1.05642" transform="matrix(-1 0 0 1 4.38745 4.74609)" fill="black"/>
<path d="M3.15497 5.64404L5.12695 7.61603" stroke="black" stroke-width="0.528211"/>
<circle cx="11.9585" cy="5.80252" r="1.05642" fill="black"/>
<path d="M12.1522 5.64404L10.1802 7.61603" stroke="black" stroke-width="0.528211"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M3.63088 12.1065C3.0615 11.8354 2.73014 11.2267 2.84114 10.606C3.31755 7.94167 5.303 5.94336 7.67995 5.94336C10.0627 5.94336 12.052 7.95136 12.5222 10.6253C12.6316 11.2472 12.2975 11.8556 11.7262 12.1245C10.5037 12.6998 9.13817 13.0214 7.69756 13.0214C6.24199 13.0214 4.86309 12.6931 3.63088 12.1065Z" fill="#FFDF6F"/>
<path d="M12.5222 10.6253L12.7823 10.5796L12.5222 10.6253ZM11.7262 12.1245L11.8386 12.3635L11.7262 12.1245ZM2.84114 10.606L3.10112 10.6525L2.84114 10.606ZM3.63088 12.1065L3.7444 11.868L3.63088 12.1065ZM3.10112 10.6525C3.56146 8.07803 5.46436 6.20746 7.67995 6.20746V5.67925C5.14164 5.67925 3.07364 7.8053 2.58115 10.5595L3.10112 10.6525ZM7.67995 6.20746C9.90088 6.20746 11.8077 8.08716 12.2621 10.6711L12.7823 10.5796C12.2962 7.81556 10.2244 5.67925 7.67995 5.67925V6.20746ZM11.6137 11.8855C10.4257 12.4446 9.09849 12.7573 7.69756 12.7573V13.2855C9.17785 13.2855 10.5817 12.955 11.8386 12.3635L11.6137 11.8855ZM7.69756 12.7573C6.28209 12.7573 4.9419 12.4381 3.7444 11.868L3.51736 12.3449C4.78428 12.9481 6.20189 13.2855 7.69756 13.2855V12.7573ZM12.2621 10.6711C12.3498 11.1697 12.0828 11.6648 11.6137 11.8855L11.8386 12.3635C12.5122 12.0465 12.9134 11.3248 12.7823 10.5796L12.2621 10.6711ZM2.58115 10.5595C2.44814 11.3033 2.84611 12.0254 3.51736 12.3449L3.7444 11.868C3.2769 11.6455 3.01213 11.1501 3.10112 10.6525L2.58115 10.5595Z" fill="black"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M4.64674 11.4442C4.18843 11.2575 3.91656 10.7699 4.07537 10.3012C4.56513 8.8558 5.99378 7.80981 7.67991 7.80981C9.36604 7.80981 10.7947 8.8558 11.2845 10.3012C11.4433 10.7699 11.1714 11.2575 10.7131 11.4442C9.777 11.8254 8.75299 12.0355 7.67991 12.0355C6.60684 12.0355 5.58282 11.8254 4.64674 11.4442Z" fill="black"/>
<ellipse cx="8.895" cy="10.0634" rx="0.880351" ry="0.704281" fill="white"/>
<ellipse cx="6.37474" cy="10.0639" rx="0.880351" ry="0.704281" fill="white"/>
<path d="M25.3078 11.6284L24.3574 9.04272L23.4489 11.6284H25.3078ZM23.1274 5.99577H25.6712L29.2213 15.3882L26.7195 15.6398L26.0346 13.6271H22.75L22.0931 15.5H19.5633L23.1274 5.99577ZM32.463 15.5H29.9193V5.78612L32.463 5.63238V15.5ZM35.1432 15.5H33.8573V5.78612L36.4011 5.63238V14.2281L35.1432 15.5ZM35.5765 11.3629L34.8637 9.72758C35.0314 9.52259 35.2457 9.32691 35.5066 9.14055C35.7768 8.94488 36.075 8.78647 36.4011 8.66534C36.7272 8.54421 37.0627 8.48364 37.4074 8.48364C38.0783 8.48364 38.6747 8.60943 39.1965 8.86102C39.7183 9.1126 40.1283 9.49929 40.4264 10.0211C40.7339 10.5429 40.8877 11.2091 40.8877 12.0198C40.8877 12.8211 40.7339 13.492 40.4264 14.0324C40.1283 14.5729 39.709 14.9782 39.1685 15.2484C38.6374 15.5186 38.0131 15.6537 37.2956 15.6537C37.0161 15.6537 36.7366 15.6118 36.457 15.528C36.1868 15.4441 35.9166 15.3136 35.6464 15.1366C35.3855 14.9502 35.1246 14.708 34.8637 14.4098L35.5765 12.9143C35.8467 13.1659 36.1123 13.3615 36.3732 13.5013C36.6341 13.6318 36.8856 13.697 37.1279 13.697C37.3422 13.697 37.5332 13.6318 37.701 13.5013C37.8687 13.3709 38.0038 13.1799 38.1063 12.9283C38.2088 12.6767 38.26 12.3785 38.26 12.0338C38.26 11.689 38.2088 11.4001 38.1063 11.1672C38.0131 10.9249 37.8733 10.7432 37.687 10.6221C37.5099 10.501 37.2863 10.4404 37.0161 10.4404C36.7925 10.4404 36.5642 10.5243 36.3312 10.692C36.0983 10.8597 35.8467 11.0833 35.5765 11.3629ZM43.4036 15.528L43.4595 15.3742L41.0275 9.14055L43.3757 8.46967L44.7594 12.5509L46.0592 8.72125H48.589L45.6119 16.2967C45.4722 16.6601 45.2439 16.9955 44.9271 17.303C44.6103 17.6105 44.2422 17.8714 43.8229 18.0857C43.4036 18.3 42.9703 18.4584 42.5231 18.5609L41.6705 16.5902C41.8941 16.497 42.1271 16.3945 42.3693 16.2827C42.6209 16.1709 42.8445 16.0498 43.0402 15.9193C43.2359 15.7889 43.357 15.6584 43.4036 15.528Z" fill=${0}/>
</svg>
`), Je("text-tertiary", "black"), Je("text-tertiary", "black"), Je("text-tertiary", "black"));
  var wt;
  var xt;
  var vt;
  var Lt;
  var $t = (e8) => e8;
  var kt = (xt = class extends (wt = Ne()(m2)) {
    render() {
      return x(vt || (vt = $t`<button
      class="relative h-10 px-3 font-semibold font-sans shadow rounded-lg flex gap-2 justify-center items-center w-full ${0}"
    >
      <div
        class="absolute -z-10 top-0 left-0 w-full h-full border-2 border-solid border-transparent rounded-lg"
        style="
        background-image: linear-gradient(${0}, ${0}), linear-gradient(to bottom, ${0}, ${0});
        background-origin: border-box;
        background-clip: content-box, border-box;"
      ></div>
      <slot></slot>
    </button>`), Xe, Je("bg-primary"), Je("bg-primary"), Je("primary"), Je("secondary"));
    }
  }, xt.styles = [...wt.styles, i(Lt || (Lt = $t`
      :hover ::slotted(.hover-right) {
        transform: translateX(4px);
        transition: all 0.5s;
      }
      :hover ::slotted(.hover-right-up) {
        transform: translateX(4px) translateY(-4px);
        transition: all 0.5s;
      }
    `))], xt);
  kt = c3([e4("bci-button")], kt);
  var Mt;
  var St;
  var _t = (e8) => e8;
  var Zt = class extends Ne()(y3) {
    render() {
      return x(Mt || (Mt = _t`<div>
      <bc-navbar class="flex w-full" heading="About"></bc-navbar>
      <div class="font-sans text-sm w-full">
        <div class="px-8">
          <div class="font-bold mb-1" style="${0}">
            How does it work?
          </div>
          <p class="mb-2" style="color: ${0}">
            Bitcoin Connect is a way to connect to your lightning wallet from
            any browser.
          </p>
          <div
            style="color: ${0}"
            class="flex flex-col gap-3"
          >
            <p>
              💾 Your connection is saved in local storage, so next time you
              visit the site will connect automatically.
            </p>
            <p>
              💸 Make sure to set budgets and permissions for sites you do not
              trust.
            </p>
          </div>
        </div>

        <div class="flex gap-4 w-full my-6 px-8">
          <a
            href="https://getalby.github.io/bitcoin-connect"
            target="_blank"
            class="flex-1"
          >
            <bci-button>
              <span style="${0}">Learn more</span>
              ${0}
            </bci-button>
          </a>
          <a
            href="https://github.com/getAlby/bitcoin-connect"
            target="_blank"
            class="flex-1"
          >
            <bci-button>
              <span style="${0}">Use it</span>
              ${0}
            </bci-button>
          </a>
        </div>
        ${0}
        <div
          class="flex w-full justify-center items-center mt-4 gap-1 font-sans"
          style="color: ${0}"
        >
          <span class="block">Made with love by</span>
          ${0}
        </div>
      </div>
    </div>`), ut(), Je("text-secondary"), Je("text-secondary"), ut(), ht, ut(), ht, mt(), Je("text-secondary"), yt);
    }
  };
  Zt = c3([e4("bc-help")], Zt);
  var Ft = b(St || (St = ((e8) => e8)`
<svg width="17" height="16" viewBox="0 0 17 16" fill="none" xmlns="http://www.w3.org/2000/svg" class="hover-right">
<path d="M14 7.99999L6.5 7.99999M14 7.99999L11 11M14 7.99999L11 5M8 13.5H3.66667C3.29848 13.5 3 13.2015 3 12.8333L3 3.16667C3 2.79848 3.29848 2.5 3.66667 2.5L8 2.5" stroke="url(#paint0_linear_204_1760)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
<defs>
<linearGradient id="paint0_linear_204_1760" x1="8.5" y1="2.5" x2="8.5" y2="13.5" gradientUnits="userSpaceOnUse">
<stop stop-color=${0}/>
<stop offset="1" stop-color=${0}/>
</linearGradient>
</defs>
</svg>
`), Je("primary"), Je("secondary"));
  var Ot;
  var zt;
  var At = (e8) => e8;
  var jt = b(Ot || (Ot = At`
<svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="${0}" stroke-width="4"></circle>
      <path class="opacity-75" fill="${0}" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
    </svg>
`), Je("text-primary"), Je("text-primary"));
  var Et = b(zt || (zt = At`
<svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="${0}" stroke-width="4"></circle>
      <path class="opacity-75" fill="${0}" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
    </svg>
`), Je("text-secondary"), Je("text-secondary"));
  var Rt;
  var Tt;
  var Vt;
  var Dt;
  var Wt;
  var Ht = (e8) => e8;
  var Ut = class extends Ne()(y3) {
    render() {
      return x(Rt || (Rt = Ht`<div class="flex flex-col justify-center items-center w-full">
      ${0}
    </div>`), this._connecting ? x(Tt || (Tt = Ht`<div class="py-32">${0}</div>`), Et) : this._connected ? x(Vt || (Vt = Ht` <h1
              class="font-sans text-lg"
              style="color: ${0}"
            >
              Hello,
              <span class="font-bold" style="${0}">
                ${0}
              </span>
            </h1>

            <span
              class="font-sans text-xs font-medium mb-2 mt-8"
              style="color: ${0}"
              >Balance</span
            >

            <h2
              class="font-sans text-2xl mb-12"
              style="color: ${0}"
            >
              <span
                class="font-bold font-mono text-4xl align-bottom"
                style="${0}"
                >${0}</span
              >&nbsp;sats
            </h2>

            ${0}

            <span
              class="font-sans text-xs my-4"
              style="color: ${0}"
              >Connected through
              <span class="font-medium">${0}</span></span
            >

            <bci-button @click=${0}>
              ${0}
              <span style="${0}">Disconnect</span>
            </bci-button>`), Je("text-secondary"), ut(), this._alias || "Anon", Je("text-secondary"), Je("text-secondary"), ut(), this._balance || 0, mt(), Je("text-secondary"), this._connectorName, this._handleDisconnect, Ft, ut()) : x(Dt || (Dt = Ht`
            <h1
              class="font-sans my-8"
              style="color: ${0}"
            >
              How would you like to connect?
            </h1>

            <bc-connector-list />
          `), Je("text-secondary")));
    }
    _handleDisconnect() {
      C2.getState().disconnect();
    }
  };
  Ut = c3([e4("bc-start")], Ut);
  var Bt = b(Wt || (Wt = ((e8) => e8)`<svg width="24" height="25" viewBox="0 0 24 25" fill="none" xmlns="http://www.w3.org/2000/svg" class="w-8 h-8 ${0}">
<path d="M13.7929 16.5L10.1464 12.8536C9.95118 12.6583 9.95118 12.3417 10.1464 12.1464L13.7929 8.5" stroke=${0} stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`), Xe, Je("text-secondary"));
  var Nt;
  var It = (e8) => e8;
  var Pt = class extends Ne()(y3) {
    constructor() {
      super(...arguments), this.to = "/start";
    }
    render() {
      return x(Nt || (Nt = It`<div
      class="flex justify-center items-center gap-2 w-full relative pb-4"
    >
      <div class="absolute left-0 h-full flex items-center justify-center">
        <div
          class="cursor-pointer"
          @click=${0}
        >
          ${0}
        </div>
      </div>
      <div
        class="font-sans font-medium"
        style="color: ${0}"
      >
        ${0}
      </div>
    </div>`), () => C2.getState().setRoute(this.to), Bt, Je("text-secondary"), this.heading);
    }
  };
  c3([n5()], Pt.prototype, "heading", void 0), c3([n5()], Pt.prototype, "to", void 0), Pt = c3([e4("bc-navbar")], Pt);
  var Gt;
  var Yt;
  var qt = (e8) => e8;
  var Jt = { "/start": x(Gt || (Gt = qt`<bc-start class="flex w-full"></bc-start>`)), "/help": x(Yt || (Yt = qt`<bc-help class="flex w-full"></bc-help>`)) };
  var Xt;
  var Kt;
  var Qt = (e8) => e8;
  var eo = class extends Ne()(y3) {
    constructor() {
      super(), this._route = C2.getState().route, C2.subscribe((e8) => {
        this._route = e8.route;
      });
    }
    render() {
      return x(Xt || (Xt = Qt`<div class="flex flex-col w-full pt-8">
      ${0}
    </div>`), Jt[this._route]);
    }
  };
  c3([t3()], eo.prototype, "_route", void 0), eo = c3([e4("bc-router-outlet")], eo);
  var to = b(Kt || (Kt = ((e8) => e8)`<svg width="172" height="24" viewBox="0 0 172 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M21.5709 14.1773C20.3688 18.9988 15.4849 21.9331 10.6623 20.7307C5.84177 19.5287 2.90717 14.645 4.10993 9.82385C5.31156 5.00182 10.1954 2.06726 15.0166 3.26932C19.8388 4.47139 22.7731 9.35557 21.5709 14.1773Z" fill="url(#paint0_linear_204_1469)"/>
<path d="M14.525 13.9072C14.2043 15.1295 12.1482 14.4405 11.481 14.2658L12.0507 12.0991C12.7179 12.2746 14.86 12.6325 14.525 13.9072ZM14.8706 10.7298C14.5781 11.8416 12.867 11.2532 12.3113 11.1072L12.8279 9.14204C13.3835 9.28802 15.1753 9.57002 14.8706 10.7298Z" fill=${0}/>
<path d="M14.8706 10.7298C14.5781 11.8416 12.867 11.2532 12.3113 11.1072L12.8279 9.14204C13.3835 9.28802 15.1753 9.57002 14.8706 10.7298Z" fill=${0}/>
<path d="M14.525 13.9072C14.2043 15.1295 12.1482 14.4405 11.481 14.2658L12.0507 12.0991C12.7179 12.2746 14.86 12.6325 14.525 13.9072Z" fill=${0}/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M16.821 10.7722C17.0153 9.57701 16.1117 8.92174 14.8705 8.47652L15.2954 6.85952L14.3111 6.60095L13.8974 8.17533C13.6387 8.10737 13.3728 8.04297 13.1087 7.97915L13.5253 6.39439L12.5416 6.13582L12.1164 7.75226C11.9022 7.7006 11.6919 7.64957 11.4878 7.59607L11.489 7.59102L10.1316 7.23378L9.85555 8.28506C9.85555 8.28506 10.586 8.46223 10.5704 8.47243C10.9691 8.57733 11.038 8.84288 11.0232 9.05252L10.5392 10.8946L10.5374 10.9016L9.85895 13.4822C9.80848 13.6031 9.68216 13.7837 9.4035 13.711C9.41316 13.7255 8.68807 13.5228 8.68807 13.5228L8.18358 14.6468L9.46445 14.9834C9.70274 15.0463 9.93621 15.112 10.1661 15.174L9.73668 16.8095L10.7198 17.068L11.1451 15.4499C11.4136 15.5265 11.6742 15.5973 11.9294 15.6641L11.5056 17.2746L12.4899 17.5332L12.9192 15.9008C14.5989 16.2407 15.8666 16.1282 16.4188 14.6121C16.8638 13.3914 16.4219 12.6784 15.5419 12.206C16.1889 12.0654 16.6803 11.6472 16.821 10.7722ZM11.481 14.2658C12.1482 14.4405 14.2043 15.1295 14.525 13.9072C14.86 12.6325 12.7179 12.2746 12.0507 12.0991L11.481 14.2658ZM12.3113 11.1072C12.867 11.2532 14.5781 11.8416 14.8706 10.7298C15.1753 9.57002 13.3835 9.28802 12.8279 9.14204L12.3113 11.1072Z" fill=${0}/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M12.5567 10.0666L12.6908 9.55575C12.7532 9.3179 12.9967 9.1757 13.2345 9.23814C13.4724 9.30057 13.6146 9.544 13.5521 9.78185L13.418 10.2927L13.9288 10.4267C14.1666 10.4892 14.3088 10.7326 14.2464 10.9705C14.184 11.2083 13.9405 11.3505 13.7027 11.2881L13.1919 11.154L13.0578 11.6648C12.9954 11.9027 12.752 12.0449 12.5141 11.9824C12.2763 11.92 12.1341 11.6766 12.1965 11.4387L12.3306 10.9279L11.8197 10.7938C11.5819 10.7313 11.4397 10.4879 11.5021 10.2501C11.5645 10.0122 11.808 9.87002 12.0458 9.93246L12.5567 10.0666Z" fill="url(#paint1_linear_204_1469)"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M13.6265 12.9381L13.7606 12.4273C13.8231 12.1895 14.0665 12.0473 14.3043 12.1097C14.5422 12.1722 14.6844 12.4156 14.6219 12.6534L14.4879 13.1642L14.9986 13.2983C15.2365 13.3608 15.3787 13.6042 15.3162 13.842C15.2538 14.0799 15.0104 14.2221 14.7725 14.1597L14.2618 14.0256L14.1277 14.5364C14.0652 14.7743 13.8218 14.9165 13.5839 14.854C13.3461 14.7916 13.2039 14.5482 13.2663 14.3103L13.4004 13.7995L12.8896 13.6654C12.6517 13.6029 12.5095 13.3595 12.5719 13.1217C12.6344 12.8838 12.8778 12.7416 13.1157 12.804L13.6265 12.9381Z" fill="url(#paint2_linear_204_1469)"/>
<path d="M31.7822 8.43869C32.5104 8.43869 33.14 8.56764 33.6709 8.82554C34.2019 9.08344 34.6419 9.43237 34.9908 9.87232C35.3397 10.3123 35.5976 10.8281 35.7645 11.4197C35.9314 12.0114 36.0148 12.6485 36.0148 13.3312C36.0148 14.378 35.8176 15.3717 35.4231 16.3123C35.0439 17.2377 34.5205 18.0493 33.853 18.7472C33.1855 19.4298 32.3966 19.976 31.4864 20.3856C30.5761 20.78 29.59 20.9773 28.5281 20.9773C28.3915 20.9773 28.1488 20.9697 27.7999 20.9545C27.4661 20.9545 27.0793 20.9242 26.6393 20.8635C26.1994 20.8028 25.7291 20.7118 25.2284 20.5904C24.743 20.469 24.2803 20.3022 23.8403 20.0898L27.7771 3.54614L31.3043 3L29.8934 8.87105C30.1968 8.73451 30.5003 8.62832 30.8037 8.55247C31.1071 8.47661 31.4333 8.43869 31.7822 8.43869ZM28.8239 18.1783C29.3549 18.1783 29.8555 18.0493 30.3258 17.7914C30.7961 17.5335 31.1981 17.1922 31.5319 16.7674C31.8808 16.3274 32.1539 15.8344 32.3511 15.2882C32.5483 14.7421 32.6469 14.1732 32.6469 13.5815C32.6469 12.8534 32.5255 12.2845 32.2828 11.8748C32.0401 11.4652 31.5925 11.2604 30.9402 11.2604C30.7278 11.2604 30.4472 11.2984 30.0982 11.3742C29.7645 11.4501 29.4611 11.6094 29.188 11.8521L27.6861 18.0872C27.7771 18.1024 27.853 18.1176 27.9137 18.1327C27.9895 18.1479 28.0654 18.1631 28.1412 18.1783C28.2171 18.1783 28.3081 18.1783 28.4143 18.1783C28.5205 18.1783 28.657 18.1783 28.8239 18.1783Z" fill=${0}/>
<path d="M39.8423 20.6587H36.4744L39.3189 8.689H42.7095L39.8423 20.6587ZM41.4807 7.23262C41.0104 7.23262 40.5856 7.09608 40.2064 6.82301C39.8271 6.53477 39.6375 6.1024 39.6375 5.52592C39.6375 5.20733 39.6981 4.9115 39.8195 4.63843C39.956 4.35019 40.1305 4.10746 40.3429 3.91024C40.5553 3.69785 40.798 3.53097 41.0711 3.40961C41.3593 3.28824 41.6627 3.22756 41.9813 3.22756C42.4516 3.22756 42.8764 3.37168 43.2557 3.65992C43.6349 3.933 43.8246 4.35778 43.8246 4.93426C43.8246 5.25285 43.7563 5.55626 43.6198 5.8445C43.4984 6.11757 43.3315 6.3603 43.1191 6.57269C42.9067 6.76991 42.6564 6.9292 42.3682 7.05057C42.0951 7.17194 41.7993 7.23262 41.4807 7.23262Z" fill=${0}/>
<path d="M45.7179 5.70797L49.2451 5.16182L48.3804 8.689H52.1579L51.4752 11.4652H47.7205L46.7192 15.6523C46.6282 16.0013 46.5675 16.3274 46.5372 16.6309C46.522 16.9343 46.5599 17.1998 46.6509 17.4273C46.7571 17.6397 46.9316 17.8066 47.1743 17.9279C47.4171 18.0493 47.7508 18.11 48.1756 18.11C48.5397 18.11 48.8886 18.0797 49.2224 18.019C49.5713 17.9431 49.9202 17.8445 50.2691 17.7231L50.5195 20.3173C50.0643 20.4842 49.5713 20.6283 49.0403 20.7497C48.5093 20.8711 47.8798 20.9317 47.1516 20.9317C46.1048 20.9317 45.2932 20.78 44.7167 20.4766C44.1402 20.158 43.7306 19.7333 43.4878 19.2023C43.2451 18.6561 43.1389 18.0341 43.1693 17.3363C43.1996 16.6384 43.3058 15.9027 43.4878 15.129L45.7179 5.70797Z" fill=${0}/>
<path d="M51.8249 15.8799C51.8249 14.8483 51.9918 13.8774 52.3255 12.9671C52.6593 12.0569 53.1372 11.2604 53.7592 10.5778C54.3812 9.89507 55.1321 9.35651 56.012 8.96208C56.9071 8.56764 57.9008 8.37042 58.993 8.37042C59.6757 8.37042 60.2826 8.43869 60.8135 8.57522C61.3597 8.69659 61.8527 8.86347 62.2927 9.07586L61.1321 11.7156C60.8287 11.5942 60.5101 11.488 60.1764 11.397C59.8578 11.2908 59.4633 11.2377 58.993 11.2377C57.8552 11.2377 56.9602 11.6245 56.3078 12.3982C55.6555 13.1568 55.3293 14.196 55.3293 15.5158C55.3293 16.2895 55.4962 16.9191 55.83 17.4046C56.1637 17.8748 56.7781 18.11 57.6732 18.11C58.1132 18.11 58.5379 18.0645 58.9475 17.9735C59.3572 17.8824 59.7212 17.7687 60.0398 17.6321L60.2901 20.3401C59.8654 20.507 59.3951 20.6511 58.8793 20.7724C58.3786 20.909 57.7642 20.9773 57.036 20.9773C56.0955 20.9773 55.299 20.8407 54.6467 20.5676C53.9943 20.2946 53.4558 19.9305 53.031 19.4754C52.6062 19.0051 52.2952 18.4589 52.098 17.8369C51.9159 17.2149 51.8249 16.5626 51.8249 15.8799Z" fill=${0}/>
<path d="M66.4588 20.9773C65.6548 20.9773 64.9569 20.8559 64.3652 20.6132C63.7736 20.3704 63.2805 20.0291 62.8861 19.5891C62.5068 19.1492 62.2186 18.6334 62.0214 18.0417C61.8242 17.4349 61.7256 16.7674 61.7256 16.0392C61.7256 15.129 61.8697 14.2187 62.1579 13.3085C62.4613 12.3982 62.9013 11.579 63.4778 10.8508C64.0543 10.1226 64.7597 9.53097 65.5941 9.07586C66.4285 8.60556 67.3842 8.37042 68.4613 8.37042C69.2502 8.37042 69.9405 8.49178 70.5321 8.73451C71.139 8.97724 71.632 9.31859 72.0113 9.75853C72.4057 10.1985 72.7015 10.7219 72.8988 11.3287C73.096 11.9204 73.1946 12.5803 73.1946 13.3085C73.1946 14.2187 73.0505 15.129 72.7622 16.0392C72.474 16.9494 72.0492 17.7687 71.4879 18.4968C70.9266 19.225 70.2211 19.8243 69.3716 20.2946C68.5372 20.7497 67.5663 20.9773 66.4588 20.9773ZM68.1427 11.2377C67.6421 11.2377 67.2022 11.3818 66.8229 11.67C66.4436 11.9583 66.125 12.3224 65.8671 12.7623C65.6092 13.2023 65.412 13.6877 65.2755 14.2187C65.1541 14.7345 65.0934 15.2276 65.0934 15.6979C65.0934 16.4716 65.2148 17.0708 65.4575 17.4956C65.7003 17.9052 66.1402 18.11 66.7774 18.11C67.278 18.11 67.718 17.9659 68.0972 17.6776C68.4765 17.3894 68.7951 17.0253 69.053 16.5853C69.3109 16.1454 69.5005 15.6675 69.6219 15.1517C69.7584 14.6207 69.8267 14.1201 69.8267 13.6498C69.8267 12.8761 69.7053 12.2845 69.4626 11.8748C69.2199 11.4501 68.7799 11.2377 68.1427 11.2377Z" fill=${0}/>
<path d="M77.0226 20.6587H73.6547L76.4992 8.689H79.8898L77.0226 20.6587ZM78.661 7.23262C78.1907 7.23262 77.7659 7.09608 77.3867 6.82301C77.0074 6.53477 76.8178 6.1024 76.8178 5.52592C76.8178 5.20733 76.8785 4.9115 76.9998 4.63843C77.1364 4.35019 77.3108 4.10746 77.5232 3.91024C77.7356 3.69785 77.9783 3.53097 78.2514 3.40961C78.5396 3.28824 78.8431 3.22756 79.1616 3.22756C79.6319 3.22756 80.0567 3.37168 80.436 3.65992C80.8152 3.933 81.0049 4.35778 81.0049 4.93426C81.0049 5.25285 80.9366 5.55626 80.8001 5.8445C80.6787 6.11757 80.5118 6.3603 80.2994 6.57269C80.0871 6.76991 79.8367 6.9292 79.5485 7.05057C79.2754 7.17194 78.9796 7.23262 78.661 7.23262Z" fill=${0}/>
<path d="M82.3976 9.23515C82.6555 9.15929 82.9362 9.07586 83.2396 8.98483C83.5582 8.87864 83.9071 8.78761 84.2864 8.71176C84.6808 8.62073 85.1132 8.55247 85.5835 8.50696C86.0689 8.44627 86.6151 8.41593 87.2219 8.41593C89.012 8.41593 90.2409 8.93173 90.9084 9.96334C91.5759 10.9949 91.6897 12.4058 91.2497 14.196L89.7023 20.6587H86.3116L87.8135 14.3325C87.9046 13.9381 87.9728 13.5588 88.0184 13.1947C88.079 12.8154 88.079 12.4893 88.0184 12.2162C87.9577 11.9279 87.8135 11.7004 87.586 11.5335C87.3736 11.3515 87.0398 11.2604 86.5847 11.2604C86.1448 11.2604 85.6972 11.3059 85.2421 11.397L83.0348 20.6587H79.6441L82.3976 9.23515Z" fill=${0}/>
<path d="M99.3141 21C98.328 21 97.4556 20.8559 96.6971 20.5676C95.9537 20.2794 95.3317 19.8698 94.8311 19.3388C94.3305 18.8078 93.9512 18.1707 93.6933 17.4273C93.4506 16.6688 93.3292 15.8192 93.3292 14.8786C93.3292 13.5133 93.5416 12.2086 93.9664 10.9646C94.4063 9.72061 95.0208 8.62073 95.8096 7.66498C96.6137 6.70923 97.577 5.9507 98.6996 5.38938C99.8223 4.8129 101.074 4.52465 102.454 4.52465C103.638 4.52465 104.578 4.64602 105.276 4.88875C105.989 5.13148 106.497 5.35904 106.801 5.57143L105.891 7.39191C105.542 7.16435 105.064 6.95196 104.457 6.75474C103.865 6.54235 103.16 6.43616 102.341 6.43616C101.294 6.43616 100.353 6.68647 99.5189 7.18711C98.6845 7.67257 97.979 8.30974 97.4025 9.09861C96.8261 9.87232 96.3861 10.7522 96.0827 11.7383C95.7793 12.7092 95.6276 13.6726 95.6276 14.6283C95.6276 17.5866 96.9095 19.0657 99.4733 19.0657C100.019 19.0657 100.505 19.0278 100.93 18.952C101.37 18.8761 101.757 18.7927 102.09 18.7016C102.424 18.5955 102.72 18.4817 102.978 18.3603C103.236 18.2389 103.463 18.1327 103.66 18.0417L103.934 19.9532C103.751 20.0594 103.509 20.1732 103.205 20.2946C102.917 20.4159 102.576 20.5297 102.181 20.6359C101.787 20.7421 101.347 20.8255 100.861 20.8862C100.376 20.9621 99.8602 21 99.3141 21Z" fill=${0}/>
<path d="M109.377 20.9545C108.133 20.9545 107.155 20.5904 106.442 19.8622C105.744 19.1188 105.395 18.1024 105.395 16.8129C105.395 15.933 105.516 15.0076 105.759 14.0367C106.017 13.0657 106.419 12.1707 106.965 11.3515C107.511 10.5322 108.217 9.85714 109.081 9.32617C109.946 8.7952 110.993 8.52971 112.222 8.52971C113.466 8.52971 114.437 8.90139 115.134 9.64476C115.847 10.3729 116.204 11.3818 116.204 12.6713C116.204 13.5512 116.075 14.4766 115.817 15.4475C115.574 16.4185 115.18 17.3135 114.634 18.1327C114.088 18.952 113.382 19.6271 112.518 20.158C111.653 20.689 110.606 20.9545 109.377 20.9545ZM109.741 19.1568C110.424 19.1568 111.031 18.9595 111.562 18.5651C112.108 18.1707 112.563 17.67 112.927 17.0632C113.306 16.4412 113.595 15.7585 113.792 15.0152C113.989 14.2718 114.088 13.5512 114.088 12.8534C114.088 12.0796 113.921 11.4652 113.587 11.0101C113.253 10.555 112.677 10.3274 111.858 10.3274C111.175 10.3274 110.561 10.5247 110.014 10.9191C109.483 11.3135 109.028 11.8217 108.649 12.4437C108.285 13.0506 108.004 13.7257 107.807 14.469C107.61 15.2124 107.511 15.933 107.511 16.6309C107.511 17.4046 107.678 18.019 108.012 18.4741C108.346 18.9292 108.922 19.1568 109.741 19.1568Z" fill=${0}/>
<path d="M119.132 20.6587H117.016L119.747 9.28066C120.445 9.06827 121.196 8.90139 122 8.78003C122.819 8.64349 123.547 8.57522 124.184 8.57522C124.867 8.57522 125.451 8.67383 125.936 8.87105C126.437 9.0531 126.839 9.311 127.143 9.64476C127.446 9.96334 127.666 10.3578 127.802 10.8281C127.954 11.2832 128.03 11.7838 128.03 12.33C128.03 12.6789 128 13.0506 127.939 13.445C127.878 13.8243 127.802 14.2111 127.711 14.6056L126.255 20.6587H124.139L125.481 15.0607C125.588 14.6359 125.686 14.2035 125.777 13.7636C125.883 13.3236 125.936 12.9065 125.936 12.512C125.936 11.9052 125.77 11.4046 125.436 11.0101C125.102 10.6005 124.48 10.3957 123.57 10.3957C123.191 10.3957 122.819 10.4185 122.455 10.464C122.091 10.5095 121.787 10.5702 121.545 10.646L119.132 20.6587Z" fill=${0}/>
<path d="M131.211 20.6587H129.095L131.825 9.28066C132.523 9.06827 133.274 8.90139 134.078 8.78003C134.897 8.64349 135.626 8.57522 136.263 8.57522C136.945 8.57522 137.529 8.67383 138.015 8.87105C138.516 9.0531 138.918 9.311 139.221 9.64476C139.524 9.96334 139.744 10.3578 139.881 10.8281C140.033 11.2832 140.108 11.7838 140.108 12.33C140.108 12.6789 140.078 13.0506 140.017 13.445C139.957 13.8243 139.881 14.2111 139.79 14.6056L138.334 20.6587H136.217L137.56 15.0607C137.666 14.6359 137.765 14.2035 137.856 13.7636C137.962 13.3236 138.015 12.9065 138.015 12.512C138.015 11.9052 137.848 11.4046 137.514 11.0101C137.181 10.6005 136.559 10.3957 135.648 10.3957C135.269 10.3957 134.897 10.4185 134.533 10.464C134.169 10.5095 133.866 10.5702 133.623 10.646L131.211 20.6587Z" fill=${0}/>
<path d="M144.086 14.4463C144.966 14.4159 145.77 14.3628 146.498 14.287C147.226 14.196 147.856 14.0518 148.387 13.8546C148.918 13.6422 149.327 13.3616 149.616 13.0126C149.919 12.6637 150.071 12.2086 150.071 11.6473C150.071 11.5107 150.04 11.3666 149.98 11.2149C149.934 11.0632 149.843 10.9267 149.707 10.8053C149.585 10.6688 149.411 10.5626 149.183 10.4867C148.956 10.3957 148.675 10.3502 148.341 10.3502C147.81 10.3502 147.31 10.464 146.839 10.6915C146.384 10.9191 145.975 11.2225 145.61 11.6018C145.246 11.9659 144.935 12.3982 144.677 12.8989C144.42 13.3843 144.222 13.9001 144.086 14.4463ZM146.248 20.9545C145.474 20.9545 144.806 20.8483 144.245 20.6359C143.684 20.4083 143.214 20.1049 142.834 19.7257C142.455 19.3312 142.174 18.8761 141.992 18.3603C141.81 17.8445 141.719 17.2984 141.719 16.7219C141.719 15.6599 141.878 14.6359 142.197 13.6498C142.516 12.6637 142.971 11.7914 143.562 11.0329C144.154 10.2743 144.875 9.6751 145.724 9.23515C146.574 8.78003 147.537 8.55247 148.614 8.55247C149.236 8.55247 149.767 8.63591 150.207 8.80278C150.662 8.95449 151.026 9.16688 151.299 9.43995C151.588 9.71302 151.8 10.0316 151.937 10.3957C152.073 10.7446 152.141 11.1087 152.141 11.488C152.141 12.201 152.012 12.8078 151.755 13.3085C151.497 13.7939 151.155 14.2035 150.731 14.5373C150.306 14.8711 149.805 15.129 149.229 15.311C148.667 15.4931 148.076 15.6372 147.454 15.7434C146.847 15.8496 146.225 15.9254 145.588 15.9709C144.966 16.0013 144.374 16.0316 143.813 16.0619C143.798 16.1833 143.79 16.2819 143.79 16.3578C143.79 16.4336 143.79 16.4943 143.79 16.5398C143.79 16.8888 143.828 17.2225 143.904 17.5411C143.995 17.8445 144.154 18.1176 144.382 18.3603C144.609 18.5879 144.92 18.7699 145.315 18.9065C145.724 19.043 146.255 19.1113 146.908 19.1113C147.196 19.1113 147.492 19.0885 147.795 19.043C148.114 18.9823 148.409 18.914 148.683 18.8382C148.971 18.7472 149.221 18.6637 149.433 18.5879C149.661 18.4968 149.82 18.4134 149.911 18.3376L150.093 20.1353C149.79 20.3022 149.297 20.4766 148.614 20.6587C147.947 20.8559 147.158 20.9545 146.248 20.9545Z" fill=${0}/>
<path d="M153.042 16.426C153.042 15.3944 153.194 14.4008 153.497 13.445C153.816 12.4893 154.278 11.6473 154.885 10.9191C155.492 10.1909 156.236 9.61441 157.115 9.18964C157.995 8.74969 159.004 8.52971 160.142 8.52971C160.643 8.52971 161.12 8.56764 161.576 8.64349C162.031 8.70417 162.463 8.83312 162.873 9.03034L162.076 10.8053C161.833 10.6688 161.545 10.5626 161.211 10.4867C160.893 10.4109 160.476 10.3729 159.96 10.3729C159.217 10.3729 158.549 10.5398 157.957 10.8736C157.366 11.1922 156.858 11.6245 156.433 12.1707C156.023 12.7016 155.705 13.3236 155.477 14.0367C155.265 14.7345 155.158 15.4627 155.158 16.2212C155.158 16.6157 155.196 16.9874 155.272 17.3363C155.363 17.6852 155.515 17.9962 155.727 18.2693C155.94 18.5272 156.22 18.732 156.569 18.8837C156.933 19.0354 157.388 19.1113 157.935 19.1113C158.208 19.1113 158.496 19.0885 158.799 19.043C159.103 18.9823 159.383 18.914 159.641 18.8382C159.899 18.7623 160.127 18.6865 160.324 18.6106C160.536 18.5196 160.688 18.4362 160.779 18.3603L160.961 20.158C160.673 20.3401 160.225 20.5145 159.619 20.6814C159.012 20.8635 158.321 20.9545 157.548 20.9545C156.82 20.9545 156.175 20.8483 155.614 20.6359C155.052 20.4083 154.582 20.0974 154.203 19.7029C153.823 19.2933 153.535 18.8154 153.338 18.2693C153.141 17.708 153.042 17.0936 153.042 16.426Z" fill=${0}/>
<path d="M166.358 20.9773C165.22 20.9773 164.386 20.7269 163.855 20.2263C163.324 19.7257 163.059 18.9975 163.059 18.0417C163.059 17.4197 163.165 16.6233 163.377 15.6523L165.812 5.52592L168.019 5.16182L167.132 8.82554H171.16L170.727 10.6005H166.7L165.448 15.8344C165.266 16.5474 165.175 17.1694 165.175 17.7004C165.175 18.201 165.311 18.5651 165.585 18.7927C165.858 19.0051 166.313 19.1113 166.95 19.1113C167.39 19.1113 167.822 19.043 168.247 18.9065C168.672 18.7547 168.998 18.6182 169.226 18.4968L169.385 20.2946C169.157 20.4311 168.77 20.5752 168.224 20.7269C167.678 20.8938 167.056 20.9773 166.358 20.9773Z" fill=${0}/>
<defs>
<linearGradient id="paint0_linear_204_1469" x1="12.8403" y1="3" x2="12.8403" y2="21.0002" gradientUnits="userSpaceOnUse">
<stop stop-color=${0}/>
<stop offset="1" stop-color=${0}/>
</linearGradient>
<linearGradient id="paint1_linear_204_1469" x1="13.2345" y1="9.23812" x2="12.5141" y2="11.9824" gradientUnits="userSpaceOnUse">
<stop stop-color=${0}/>
<stop offset="1" stop-color=${0}/>
</linearGradient>
<linearGradient id="paint2_linear_204_1469" x1="14.3043" y1="12.1097" x2="13.5839" y2="14.854" gradientUnits="userSpaceOnUse">
<stop stop-color=${0}/>
<stop offset="1" stop-color=${0}/>
</linearGradient>
</defs>
</svg>
`), Je("bg-primary"), Je("bg-primary"), Je("bg-primary"), Je("bg-primary"), Je("text-secondary"), Je("text-secondary"), Je("text-secondary"), Je("text-secondary"), Je("text-secondary"), Je("text-secondary"), Je("text-secondary"), Je("text-secondary"), Je("text-secondary"), Je("text-secondary"), Je("text-secondary"), Je("text-secondary"), Je("text-secondary"), Je("text-secondary"), Je("primary"), Je("secondary"), Je("primary"), Je("secondary"), Je("primary"), Je("secondary"));
  var oo;
  var no = b(oo || (oo = ((e8) => e8)`<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="w-7 h-7 ${0}">
<path d="M6 6L18 18" stroke=${0} stroke-width="1.5" stroke-linecap="round"/>
<path d="M18 6L6.00001 18" stroke=${0} stroke-width="1.5" stroke-linecap="round"/>
</svg>
`), Xe, Je("text-secondary"), Je("text-secondary"));
  var ro;
  var io = b(ro || (ro = ((e8) => e8)`<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 14 14" fill="none" class="w-5 h-5 ${0}">
        <path fill=${0} fill-rule="evenodd" d="M7 1.333a5.667 5.667 0 1 0 0 11.334A5.667 5.667 0 0 0 7 1.334ZM.333 7a6.667 6.667 0 1 1 13.334 0A6.667 6.667 0 0 1 .333 7Z" clip-rule="evenodd"/><path fill=${0} fill-rule="evenodd" d="M7.258 4.68c-.505-.035-.986.204-1.154.543a.5.5 0 0 1-.896-.445c.402-.808 1.344-1.149 2.118-1.096.401.027.816.161 1.14.444C8.8 4.42 9 4.843 9 5.361c0 .774-.523 1.232-.867 1.533l-.052.046c-.39.344-.58.548-.58.893a.5.5 0 0 1-1 0c0-.833.54-1.31.9-1.627.007-.006.013-.01.018-.016.41-.362.581-.537.581-.829 0-.242-.084-.387-.194-.483-.12-.106-.31-.182-.548-.198Z" clip-rule="evenodd"/>
        <path fill=${0} d="M6.333 9.667a.667.667 0 1 1 1.334 0 .667.667 0 0 1-1.333 0Z"/>
    </svg>`), Xe, Je("text-secondary"), Je("text-secondary"), Je("text-secondary"));
  var ao;
  var lo = (e8) => e8;
  var so = class extends Ne()(y3) {
    render() {
      return x(ao || (ao = lo`<div
      class="flex justify-center items-center gap-2 w-full relative"
    >
      <div
        class="absolute right-0 h-full flex items-center justify-center gap-2"
      >
        <div
          class="cursor-pointer"
          @click=${0}
        >
          ${0}
        </div>
        <div class="cursor-pointer" @click=${0}>
          ${0}
        </div>
      </div>
      ${0}
    </div>`), () => C2.getState().setRoute("/help"), io, this._handleClose, no, to);
    }
    _handleClose() {
      var e8;
      null == (e8 = this.onClose) || e8.call(this);
    }
  };
  c3([n5()], so.prototype, "onClose", void 0), so = c3([e4("bc-modal-header")], so);
  var co;
  var po;
  var fo = (e8) => e8;
  var uo = class extends Ne()(y3) {
    constructor() {
      super(), this._closing = false, this.open = false, this._handleClose = () => {
        this._closing = true, setTimeout(() => {
          var e8;
          this.open = false, this._closing = false, C2.getState().setRoute("/start"), null == (e8 = this.onClose) || e8.call(this);
        }, 200);
      }, C2.subscribe((e8, t5) => {
        e8.connected === t5.connected || e8.connected || this._handleClose();
      });
    }
    connectedCallback() {
      super.connectedCallback(), h4("bc:modalopened");
    }
    disconnectedCallback() {
      super.disconnectedCallback(), h4("bc:modalclosed");
    }
    render() {
      return this.open ? x(co || (co = fo` <div
      class="fixed top-0 left-0 w-full h-full flex justify-center items-end sm:items-center z-[21000]"
    >
      <div
        class="absolute top-0 left-0 w-full h-full ${0}"
        style="background: ${0}"
      ></div>
      <div
        class="transition-all p-4 pt-6 pb-8 rounded-3xl shadow-2xl flex flex-col justify-center items-center w-full max-w-md max-sm:rounded-b-none
    ${0}"
        style="background: ${0}"
      >
        <bc-modal-header
          class="flex w-full"
          .onClose=${0}
        ></bc-modal-header>
        <bc-router-outlet class="flex w-full"></bc-router-outlet>
      </div>
    </div>`), this._closing ? "animate-lighten" : "animate-darken", Je("bg-secondary"), this._closing ? "animate-fade-out" : "animate-fade-in", Je("bg-primary"), this._handleClose) : null;
    }
  };
  c3([n5({ attribute: "on-close" })], uo.prototype, "onClose", void 0), c3([t3()], uo.prototype, "_closing", void 0), c3([n5()], uo.prototype, "open", void 0), uo = c3([e4("bc-modal")], uo);
  var ho = b(po || (po = ((e8) => e8)`
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M20.467 9.58364C20.8686 7.1131 19.0009 5.75862 16.4352 4.83834L17.3135 1.49591L15.279 0.961432L14.4238 4.21577C13.889 4.07528 13.3395 3.94217 12.7935 3.81025L13.6547 0.534467L11.6213 0L10.7424 3.34125C10.2995 3.23448 9.86483 3.12899 9.44296 3.01841L9.44542 3.00797L6.63962 2.26953L6.06909 4.44258C6.06909 4.44258 7.579 4.80879 7.54676 4.82989C8.37077 5.04672 8.51324 5.59562 8.48275 6.02896L7.48221 9.83672L7.47855 9.8512L6.07612 15.1853C5.97179 15.4351 5.71068 15.8086 5.13466 15.6583C5.15463 15.6882 3.65584 15.2692 3.65584 15.2692L2.61304 17.5927L5.26067 18.2884C5.55635 18.3665 5.84844 18.4466 6.13748 18.5259L6.13789 18.526L6.13977 18.5265L6.14124 18.5269C6.33241 18.5794 6.52226 18.6314 6.71093 18.6823L5.82337 22.063L7.85559 22.5975L8.73456 19.2527C9.28955 19.4109 9.8284 19.5573 10.3557 19.6953L9.47987 23.0244L11.5144 23.5589L12.4019 20.1846C15.8739 20.8873 18.4943 20.6548 19.6357 17.5209C20.5555 14.9976 19.6421 13.5238 17.8231 12.5473C19.1605 12.2567 20.1761 11.3922 20.467 9.58364ZM11.6527 8.12503L11.9298 7.06916C12.0589 6.57751 12.5621 6.28358 13.0537 6.41263C13.5454 6.54169 13.8393 7.04487 13.7103 7.53652L13.4331 8.59239L14.4889 8.86954C14.9805 8.99859 15.2744 9.50178 15.1454 9.99342C15.0163 10.4851 14.5131 10.779 14.0215 10.6499L12.9657 10.3728L12.6885 11.4287C12.5595 11.9204 12.0563 12.2143 11.5646 12.0852C11.073 11.9562 10.7791 11.453 10.9081 10.9613L11.1853 9.90544L10.1293 9.62823C9.63766 9.49917 9.34372 8.99599 9.47278 8.50434C9.60184 8.0127 10.105 7.71876 10.5967 7.84782L11.6527 8.12503ZM14.1402 13.004L13.863 14.0599L12.807 13.7827C12.3154 13.6536 11.8122 13.9476 11.6832 14.4392C11.5541 14.9309 11.848 15.4341 12.3397 15.5631L13.3957 15.8403L13.1185 16.8962C12.9894 17.3879 13.2834 17.891 13.775 18.0201C14.2667 18.1492 14.7699 17.8552 14.8989 17.3636L15.1761 16.3077L16.2319 16.5848C16.7235 16.7139 17.2267 16.42 17.3557 15.9283C17.4848 15.4367 17.1909 14.9335 16.6992 14.8044L15.6435 14.5273L15.9206 13.4714C16.0497 12.9798 15.7557 12.4766 15.2641 12.3475C14.7725 12.2185 14.2693 12.5124 14.1402 13.004Z" fill="${0}"/>
</svg>`), Je("text-primary"));
  var go;
  var Co = b(go || (go = ((e8) => e8)`<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12ZM8.69253 8.74209L16.3304 10.8053L16.6668 9.34348L9.02893 7.2803L8.69253 8.74209ZM14.2194 5.69235L13.8127 7.46639L12.3649 7.07388L12.7717 5.29984L14.2194 5.69235ZM11.2272 18.7L11.6352 16.9263L10.1872 16.535L9.77913 18.3087L11.2272 18.7ZM15.6482 13.7661L8.01124 11.6995L8.34708 10.2376L15.984 12.3042L15.6482 13.7661ZM7.33193 14.6559L14.9696 16.7197L15.3059 15.2579L7.66823 13.1941L7.33193 14.6559Z" fill="currentColor"/>
</svg>`));
  var bo;
  var mo = b(bo || (bo = ((e8) => e8)`
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">

<path stroke-width="1.5" stroke="${0}" stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>`), Je("text-primary"));
  var yo;
  var wo = (e8) => e8;
  function xo() {
    return x(yo || (yo = wo`<div
    class="absolute top-0 left-0 w-full h-full rounded-lg border-2 opacity-10 pointer-events-none"
    style="border-color: ${0}"
  ></div>`), Je("bg-primary"));
  }
  var vo;
  var Lo;
  var $o;
  var ko;
  var Mo;
  var So;
  var _o = (e8) => e8;
  var Zo = class extends Ne()(y3) {
    constructor() {
      super(), this._modalOpen = false, this.disabled = false, this._closeModal = () => {
        this._modalOpen = false;
      };
    }
    render() {
      const e8 = this._connecting || !this._connected && this._modalOpen, t5 = this.iconOnly || this.connectedIconOnly && this._connected;
      return x(vo || (vo = _o`<div>
      <div
        class="relative inline-flex ${0} cursor-pointer ${0}"
        style="${0}"
        @click=${0}
      >
        ${0}
        <button
          class="${0} 
          relative font-medium font-sans shadow rounded-lg flex gap-2 justify-center items-center
          ${0}"
          style="${0}"
          ?disabled=${0}
        >
          ${0}
          ${0}
          ${0}
        </button>
        ${0}
      </div>

      <bc-modal
        .open=${0}
        .onClose=${0}
      ></bc-modal>
    </div>`), Xe, this._connected && !t5 ? "rounded-lg gap-2 justify-center items-center" : "", this._connected && !t5 ? `background: linear-gradient(180deg, #fff6 0%, #fff0 100%), linear-gradient(180deg, ${Je("bg-secondary")}, ${Je("bg-secondary")} 100%)` : "", this._onClick, this._connected ? xo() : null, t5 ? "w-8 h-8" : "h-10 px-4", this.disabled ? "bg-gray-300 opacity-50" : "", !this.disabled && `
            background: linear-gradient(180deg, ${Je("tertiary", Je("primary"))} 0%, ${Je("tertiary", Je("secondary"))} 100%);
            color: ${Je("text-primary")};
          `, this.disabled, xo(), e8 ? jt : this._connected ? t5 ? mo : null : ho, t5 ? null : x(Lo || (Lo = _o`<span class="font-semibold">
                ${0}
              </span>`), e8 ? x($o || ($o = _o`Connecting...`)) : this._connected ? x(ko || (ko = _o`${0}`), this._alias || "Connected") : x(Mo || (Mo = _o`Connect Wallet`))), this._connected && !t5 && void 0 !== this._balance ? x(So || (So = _o`<span
              class="font-medium font-sans mr-2 flex justify-center items-center gap-0.5"
              style="color: ${0}"
              >${0}<span class="font-mono">${0}</span></span
            >`), Je("text-tertiary"), Co, this._balance) : null, this._modalOpen, this._closeModal);
    }
    _onClick() {
      this._modalOpen = true;
    }
  };
  c3([t3()], Zo.prototype, "_modalOpen", void 0), c3([n5({ attribute: "icon-only", type: Boolean })], Zo.prototype, "iconOnly", void 0), c3([n5({ attribute: "connected-icon-only", type: Boolean })], Zo.prototype, "connectedIconOnly", void 0), c3([n5({ type: Boolean })], Zo.prototype, "disabled", void 0), Zo = c3([e4("bc-button")], Zo);
})();
/*! Bundled license information:

crypto-js/ripemd160.js:
  (** @preserve
  	(c) 2012 by Cédric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)

crypto-js/mode-ctr-gladman.js:
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
